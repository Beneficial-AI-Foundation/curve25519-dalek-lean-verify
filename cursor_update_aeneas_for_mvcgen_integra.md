# Update Aeneas for mvcgen integration
_Exported on 2025/11/20 at GMT+8 17:44:24 from Cursor (1.7.28)_

---

**User**

Aeneas extracts Rust code to Lean representing the original code using Lean's do, let notation for imperative programs. Aeneas includes the tactic progress which allows one to step through the imperative programs and apply spec theorems.

Later, after Aeneas and progress was already used in some production projects, the Lean developers introduced mvcgen (monadic verification condition generation) and the related framework (official documentation).

This task is to update Aeneas so that mvcgen works smoothly with the output generated by Aeneas.

It shouldn't be too hard to make it work and Son Ho offers guidance at all stages.

After the update, it will be possible to use both progress and mvcgen to verify programs which have been extracted by Aeneas.

Step 1: Introduce the Hoare triple
Define an instance of Hoare triple from Std.do for Aeneas. The doc for mvcgen actually uses Aeneas as an example for it! See also the mention of Aeneas in Graf's overview.

---

**Cursor**


Exploring the codebase to locate Aeneas code and any existing Hoare triple or mvcgen integration.



Checking the Aeneas package structure and searching for existing do notation and monad definitions:



Exploring the Aeneas Lean backend to find where to add the Hoare triple instance:



Checking the Aeneas Result monad definition and searching for mvcgen documentation:



Checking where Result is defined as a monad:



Searching for mvcgen and Hoare triple documentation in Lean's standard library:



Checking if Std.Do is available and reviewing its structure:



Creating a file in the Aeneas package to add the Hoare triple instance. Checking the Aeneas package structure to determine where to place it:



Creating a file in the Aeneas package to add the Hoare triple instance for mvcgen. Adding it to the Std namespace:



Creating a file to add the Hoare triple instance. Checking if Std.Do is available in the current Lean version:



Creating a file to add the Hoare triple instance for mvcgen. Adding it to the Aeneas.Std namespace:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp {α : Type u} (x : Result α) (Q : α → Prop) : Prop :=
  match x with
  | ok v => Q v
  | fail _ => False
  | div => False

/-- WP instance for `Result` monad -/
instance : WP Result where
  wp := Result.wp
  wp_pure {α} (a : α) (Q : α → Prop) : Result.wp (pure a) Q = Q a := by
    simp [Result.wp, Pure.pure, ok]
  wp_bind {α β} (x : Result α) (f : α → Result β) (Q : β → Prop) :
    Result.wp (x >>= f) Q = Result.wp x (fun a => Result.wp (f a) Q) := by
    simp [Result.wp, bind]
    cases x <;> simp
    case ok v => rfl
    case fail e => rfl
    case div => rfl

end Std

end Aeneas

```


Adding the import to `Aeneas/Std.lean` and checking for compilation errors:


```lean4
import Aeneas.Std.Alloc
import Aeneas.Std.Array
import Aeneas.Std.Core
import Aeneas.Std.Mvcgen
import Aeneas.Std.Primitives
import Aeneas.Std.PrimitivesLemmas
import Aeneas.Std.Scalar
import Aeneas.Std.Slice
import Aeneas.Std.Vec
import Aeneas.Tuples

```


Checking the WP type class structure in Std.Do:



Trying a different approach: checking what Std.Do provides and creating a minimal test file:



Fixing the WP instance. WP likely requires PostShape. Updating the definition:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp {α : Type u} (x : Result α) (Q : α → Prop) : Prop :=
  match x with
  | ok v => Q v
  | fail _ => False
  | div => False

/-- WP instance for `Result` monad using the default PostShape -/
instance : WP Result PostShape.default where
  wp := Result.wp
  wp_pure {α} (a : α) (Q : α → Prop) : Result.wp (pure a) Q = Q a := by
    simp [Result.wp, Pure.pure, ok]
  wp_bind {α β} (x : Result α) (f : α → Result β) (Q : β → Prop) :
    Result.wp (x >>= f) Q = Result.wp x (fun a => Result.wp (f a) Q) := by
    simp [Result.wp, bind]
    cases x <;> simp
    case ok v => rfl
    case fail e => rfl
    case div => rfl

end Std

end Aeneas


```


Trying a simpler approach. Checking the WP structure and creating a minimal working version:



Checking if Std.Do exists and what it provides:



Trying a simpler approach: creating a basic WP instance structure that can be refined. Checking if we need to add a dependency or if the structure is different:



Std.Do exists. Creating a test file to inspect its structure:



Inspecting PostShape and PredTrans:



Checking PostCond, Assertion, and examples of WP instances:



Searching for existing WP instances in the Lean installation:



Inspecting the Id WP instance to understand the pattern:



Checking PostCond and Assertion for PostShape.pure:



Creating a WP instance for Result using PostShape.pure. Updating the file:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q v
  | fail _ => False
  | div => False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [Result.wp_apply]
      intro Q1 Q2
      ext
      cases x <;> simp
      case ok v => rfl
      case fail e => rfl
      case div => rfl
  }

end Std

end Aeneas



```


Checking the actual types of PostCond and Assertion:



Fixing the types: `PostCond α PostShape.pure = α → Prop` and `Assertion PostShape.pure = Prop`.


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q.1 v
  | fail _ => False
  | div => False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [Result.wp_apply]
      intro Q1 Q2
      ext
      cases x <;> simp
      case ok v => rfl
      case fail e => rfl
      case div => rfl
  }

end Std

end Aeneas




```


Checking the Assertion definition more carefully:



Checking how to represent False in Type:



Checking how to construct Assertion values:



Checking ExceptConds and fixing the code:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q.1 v
  | fail _ => ULift.up False
  | div => ULift.up False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [Result.wp_apply]
      intro Q1 Q2
      ext
      cases x <;> simp
      case ok v => rfl
      case fail e => rfl
      case div => rfl
  }

end Std

end Aeneas





```


Fixing the conjunctive proof. Checking what it requires:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q.1 v
  | fail _ => ULift.up False
  | div => ULift.up False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [Result.wp_apply, PredTrans.Conjunctive]
      intro Q1 Q2
      cases x <;> simp
      case ok v => rfl
      case fail e => rfl
      case div => rfl
  }

end Std

end Aeneas






```


Fixing the conjunctive proof:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q.1 v
  | fail _ => ULift.up False
  | div => ULift.up False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [Result.wp_apply, PredTrans.Conjunctive]
      intro Q1 Q2
      cases x <;> simp [Result.wp_apply]
      case ok v =>
        simp [PostCond.and]
        rfl
      case fail e => rfl
      case div => rfl
  }

end Std

end Aeneas







```


Fixing the proof structure:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q.1 v
  | fail _ => ULift.up False
  | div => ULift.up False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [PredTrans.Conjunctive]
      intro Q1 Q2
      cases x <;> simp [Result.wp_apply, PostCond.and]
      case ok v => rfl
      case fail e => rfl
      case div => rfl
  }

end Std

end Aeneas








```


Trying a different proof approach:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q.1 v
  | fail _ => ULift.up False
  | div => ULift.up False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [PredTrans.Conjunctive]
      intro Q1 Q2
      match x with
      | ok v => simp [Result.wp_apply, PostCond.and]
      | fail e => simp [Result.wp_apply]
      | div => simp [Result.wp_apply]
  }

end Std

end Aeneas









```


Removing the unused simp argument and verifying the proof:


```lean4
import Lean
import Aeneas.Std.Primitives
import Std.Do

namespace Aeneas

namespace Std

open Result
open Std.Do

/-!
# mvcgen Integration for Aeneas

This file provides the Hoare triple instance for Aeneas's `Result` monad,
enabling `mvcgen` to work with programs extracted by Aeneas.

The `WP` (Weakest Precondition) instance allows `Std.Do.Triple` to generate
verification conditions for imperative programs written using Aeneas's `Result` monad.
-/

/-- Weakest precondition transformer for `Result` monad -/
def Result.wp_apply {α : Type u} (x : Result α) (Q : PostCond α PostShape.pure) : Assertion PostShape.pure :=
  match x with
  | ok v => Q.1 v
  | fail _ => ULift.up False
  | div => ULift.up False

/-- WP instance for `Result` monad using PostShape.pure -/
instance : WP Result PostShape.pure where
  wp := fun {α} (x : Result α) => {
    apply := Result.wp_apply x
    conjunctive := by
      simp [PredTrans.Conjunctive]
      intro Q1 Q2
      match x with
      | ok v => simp [Result.wp_apply]
      | fail e => simp [Result.wp_apply]
      | div => simp [Result.wp_apply]
  }

end Std

end Aeneas










```


The file compiles. Verifying integration and creating a summary:



Verifying the file can be imported:



## Summary

Added a Hoare triple instance for Aeneas's `Result` monad to enable `mvcgen` integration.

### Created Files:
1. **`.lake/packages/aeneas/backends/lean/Aeneas/Std/Mvcgen.lean`** — New file containing:
   - `Result.wp_apply`: Weakest precondition transformer for the `Result` monad
   - `WP Result PostShape.pure` instance: Enables `Std.Do.Triple` to work with Aeneas's `Result` monad

### Modified Files:
2. **`.lake/packages/aeneas/backends/lean/Aeneas/Std.lean`** — Added import for `Mvcgen.lean`

### Implementation Details:
- Uses `PostShape.pure` (simplest postcondition shape)
- Handles all three `Result` cases: `ok`, `fail`, and `div`
- The `conjunctive` property proof structure is in place (may need refinement with guidance)

The file compiles without errors. This enables `mvcgen` to generate verification conditions for imperative programs extracted by Aeneas, working alongside the existing `progress` tactic.

The proof for the `conjunctive` property may need refinement; the structure is correct and ready for further development with Son Ho's guidance.


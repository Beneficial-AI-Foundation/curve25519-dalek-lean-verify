# Rust to Lean Specification Generator

## Purpose
Generate a Lean 4 specification skeleton from a Rust function in the curve25519-dalek verification project. The generated specification will include proper structure, imports, documentation, and `sorry` placeholders for the proof.

## What You'll Do

### Step 1: Parse and Locate the Rust Function
1. Parse the function identifier provided by the user (e.g., `MontgomeryPoint::mul_base`, `field::FieldElement51::add`, or a full path)
2. Search `functions.json` to find metadata about the function:
   - Full Rust path and module
   - Source file location with line numbers
   - Expected Lean function name (from Aeneas extraction)
   - Current verification status
3. If not in `functions.json`, search the Rust codebase directly:
   - Look in `curve25519-dalek/src/` directory
   - Use grep to find function definitions matching the pattern
   - Determine the module path from the file structure

### Step 2: Read and Analyze the Rust Function
1. Read the Rust source file at the identified location
2. Extract the function signature:
   - Function name
   - Parameters and their types
   - Return type
   - Generic parameters and trait bounds
   - Whether it's a method (has `&self` or `self`)
3. Read any documentation comments (`///` or `//!`) above the function
4. Identify key algorithmic elements:
   - Loop structures that might need invariants
   - Array/slice operations that need bounds
   - Arithmetic operations that might overflow
   - Conditional branches that affect correctness
5. Note any preconditions or assumptions in comments

### Step 3: Determine the Lean Output Path
1. Convert the Rust module path to the Lean directory structure:
   ```
   Rust: curve25519-dalek/src/backend/serial/u64/field.rs::FieldElement51::add
   → Lean: Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Add.lean

   Rust: curve25519-dalek/src/montgomery.rs::MontgomeryPoint::mul_base
   → Lean: Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulBase.lean
   ```
2. Path conversion rules:
   - Module path segments → Title case directory names
   - Struct/type names → Title case directory names
   - Function names → Title case file names (e.g., `mul_base` → `MulBase.lean`)
   - Backend paths: `backend/serial/u64` → `Backend/Serial/U64`
3. Create the directory if it doesn't exist

### Step 4: Generate the Lean Specification File
Generate a Lean file following the project's established pattern. Include:

#### 4.1 File Header
```lean
/-
Copyright (c) 2026 Beneficial AI Foundation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: [Generated by Claude Code]
-/
```

#### 4.2 Imports
```lean
import Curve25519Dalek.Funs
import Curve25519Dalek.Defs
-- Add module-specific imports as needed based on function dependencies
```

#### 4.3 Module Documentation
```lean
/-! # [Function Name in Title Case]

Specification and proof for `[Full Rust Path]`.

[Brief description from Rust doc comments or inferred from function signature]

**Source**: curve25519-dalek/src/[path]:[line_numbers]
-/

open Aeneas.Std Result

namespace [rust_module_path_in_lean]
```

#### 4.4 Natural Language Specification Comments
```lean
/-
## Function Overview
[Describe what the function does in mathematical/algorithmic terms]

## Natural Language Specification

### Preconditions:
- [List input constraints, e.g., "Input field element must have limbs < 2^53"]
- [List invariants that must hold before the function]

### Postconditions:
- [List output guarantees, e.g., "Output field element represents the sum modulo p"]
- [List properties that must hold after the function]

### Key Algorithm Steps:
1. [Step 1]
2. [Step 2]
...

### Notes:
- [Any implementation-specific details]
- [Edge cases or special handling]
-/
```

#### 4.5 Specification Theorem
Generate the theorem following the project's pattern:

```lean
@[progress]
theorem [function_name]_spec [parameters_with_types] [preconditions] :
    ∃ result, [lean_function_name] [arguments] = ok result ∧
    [postcondition_1] ∧
    [postcondition_2] ∧
    ... := by
  sorry
```

**Key patterns to follow:**
- Always use `@[progress]` attribute
- Return type pattern: `∃ result, function_call = ok result ∧ [properties]`
- For array/field operations, include:
  - Element-wise specifications: `(∀ i < n, result[i]!.val = ...)`
  - Bound specifications: `(∀ i < n, result[i]!.val < bound)`
  - Natural number interpretation: `Field51_as_Nat result = ...` or `U8x32_as_Nat result = ...`
- For boolean results: Use `↔` for equivalences (e.g., `result.val = 1#u8 ↔ condition`)
- For point operations: Specify geometric meaning when applicable

#### 4.6 Close Namespace
```lean
end [namespace]
```

### Step 5: Provide User Guidance
After generating the file, provide the user with:
1. The full path of the generated Lean file
2. A summary of what needs to be filled in:
   - Specific preconditions to add based on function requirements
   - Specific postconditions to verify
   - Any helper lemmas that might be needed
3. Suggestions for next steps:
   - Running `nice -n 19 lake build` to check syntax. Do not run `lake build` since the compilation of the project is quite computationally expensive.
   - Using the `lean4-theorem-proving` skill to start filling in the proof
   - Reviewing similar specifications in the same module for patterns

## Key Guidelines

### For Array/Field Element Operations:
- Use `Array U64 5#usize` for FieldElement51 (5 limbs, 51 bits each)
- Use `Array U64 5#usize` for Scalar52 (5 limbs, 52 bits each)
- Use `Array U8 32#usize` for encoded points (32 bytes)
- Include bounds for limb values (e.g., `< 2^51`, `< 2^52`, `< 2^53`)
- Use interpretation functions:
  - `Field51_as_Nat` for field element natural number interpretation
  - `Scalar52_as_Nat` for scalar natural number interpretation
  - `U8x32_as_Nat` for byte array natural number interpretation

### For Mathematical Specifications:
- Reference constants from `Curve25519Dalek.Defs`:
  - `p : Nat := 2^255 - 19` (field prime)
  - `L : Nat := ...` (group order)
  - `d : Nat := ...` (Edwards curve parameter)
  - `a : Int := -1` (Edwards curve parameter)
- Use modular arithmetic explicitly (e.g., `... % p = ...`)

### For Control Flow:
- Identify loops that may need invariants (note them in comments)
- Identify branches that affect correctness (specify both cases)
- Note any early returns or error conditions

### For Method Calls (self):
- If the function is a method, the first parameter should be the struct type
- Example: `add_spec (a b : Array U64 5#usize)` for `a.add(b)`

### Error Handling:
- DO NOT fail if the function is not found in `functions.json` - search Rust code directly
- If the Rust function cannot be located, ask the user for clarification
- If the function signature is complex (generics, lifetimes), generate a best-effort spec and note limitations

### File Operations:
- ALWAYS create the full directory path if it doesn't exist
- Use absolute paths for all file operations
- Check if a spec file already exists and warn the user before overwriting

## Example Invocation

User: `/rust-to-lean-spec FieldElement51::add`

Expected output:
1. Search `functions.json` for metadata
2. Read `curve25519-dalek/src/backend/serial/u64/field.rs`
3. Locate the `add` function implementation
4. Generate `Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Add.lean`
5. Provide user with path and next steps

## Important Notes

- This skill generates a SKELETON with `sorry` - the user must fill in the actual proof
- The generated specification is a starting point - it may need refinement based on:
  - Deeper understanding of the algorithm
  - Interactions with other functions
  - Proof complexity
- Always preserve the project's coding style and conventions
- Reference existing specifications in the same module for consistency
- The generated natural language spec should be detailed enough to guide proof development

## Success Criteria

A successful spec generation includes:
1. ✅ Correct file path following project conventions
2. ✅ All required imports
3. ✅ Comprehensive documentation with source reference
4. ✅ Natural language specification with pre/postconditions
5. ✅ Syntactically valid Lean theorem with proper types
6. ✅ `sorry` placeholder for the proof
7. ✅ Clear guidance for the user on next steps
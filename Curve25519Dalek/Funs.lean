-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [curve25519_dalek]: function definitions
import Aeneas
import Curve25519Dalek.Types
import Curve25519Dalek.FunsExternal
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace curve25519_dalek

/- Trait implementation: [subtle::{core::convert::From<u8> for subtle::Choice}]
   Source: '/home/oliver/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs', lines 236:0-236:24
   Name pattern: [core::convert::From<subtle::Choice, u8>] -/
@[reducible]
def core.convert.FromsubtleChoiceU8 : core.convert.From subtle.Choice U8 := {
  from_ := subtle.FromsubtleChoiceU8.from
}

/- Trait implementation: [subtle::{subtle::ConditionallySelectable for u64}]
   Source: '/home/oliver/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs', lines 511:8-537:10
   Name pattern: [subtle::ConditionallySelectable<u64>] -/
@[reducible]
def subtle.ConditionallySelectableU64 : subtle.ConditionallySelectable U64 := {
  coremarkerCopyInst := core.marker.CopyU64
  conditional_select := subtle.ConditionallySelectableU64.conditional_select
}

/- [curve25519_dalek::backend::serial::u64::constants::L]
   Source: 'curve25519-dalek/src/backend/serial/u64/constants.rs', lines 127:0-133:3 -/
@[global_simps]
def backend.serial.u64.constants.L_body
  : Result backend.serial.u64.scalar.Scalar52 :=
  ok
    Array.make 5#usize [
      671914833335277#u64, 3916664325105025#u64, 1367801#u64, 0#u64,
      17592186044416#u64
      ]
@[global_simps, irreducible]
def backend.serial.u64.constants.L : backend.serial.u64.scalar.Scalar52 :=
  eval_global backend.serial.u64.constants.L_body

/- [curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::reduce::LOW_51_BIT_MASK]
   Source: 'curve25519-dalek/src/backend/serial/u64/field.rs', lines 291:8-291:54 -/
@[global_simps]
def backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK_body
  : Result U64 :=
  do
  let i ← 1#u64 <<< 51#i32
  i - 1#u64
@[global_simps, irreducible]
def backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK : U64 :=
  eval_global
    backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK_body

/- [curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::reduce]:
   Source: 'curve25519-dalek/src/backend/serial/u64/field.rs', lines 290:4-323:5 -/
def backend.serial.u64.field.FieldElement51.reduce
  (limbs : Array U64 5#usize) :
  Result backend.serial.u64.field.FieldElement51
  :=
  do
  let i ← Array.index_usize limbs 0#usize
  let c0 ← i >>> 51#i32
  let i1 ← Array.index_usize limbs 1#usize
  let c1 ← i1 >>> 51#i32
  let i2 ← Array.index_usize limbs 2#usize
  let c2 ← i2 >>> 51#i32
  let i3 ← Array.index_usize limbs 3#usize
  let c3 ← i3 >>> 51#i32
  let i4 ← Array.index_usize limbs 4#usize
  let c4 ← i4 >>> 51#i32
  let i5 ←
    (↑(i &&& backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK)
      : Result U64)
  let limbs1 ← Array.update limbs 0#usize i5
  let i6 ← Array.index_usize limbs1 1#usize
  let i7 ←
    (↑(i6 &&& backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK)
      : Result U64)
  let limbs2 ← Array.update limbs1 1#usize i7
  let i8 ← Array.index_usize limbs2 2#usize
  let i9 ←
    (↑(i8 &&& backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK)
      : Result U64)
  let limbs3 ← Array.update limbs2 2#usize i9
  let i10 ← Array.index_usize limbs3 3#usize
  let i11 ←
    (↑(i10 &&&
      backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK) : Result
      U64)
  let limbs4 ← Array.update limbs3 3#usize i11
  let i12 ← Array.index_usize limbs4 4#usize
  let i13 ←
    (↑(i12 &&&
      backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK) : Result
      U64)
  let limbs5 ← Array.update limbs4 4#usize i13
  let i14 ← c4 * 19#u64
  let i15 ← Array.index_usize limbs5 0#usize
  let i16 ← i15 + i14
  let limbs6 ← Array.update limbs5 0#usize i16
  let i17 ← Array.index_usize limbs6 1#usize
  let i18 ← i17 + c0
  let limbs7 ← Array.update limbs6 1#usize i18
  let i19 ← Array.index_usize limbs7 2#usize
  let i20 ← i19 + c1
  let limbs8 ← Array.update limbs7 2#usize i20
  let i21 ← Array.index_usize limbs8 3#usize
  let i22 ← i21 + c2
  let limbs9 ← Array.update limbs8 3#usize i22
  let i23 ← Array.index_usize limbs9 4#usize
  let i24 ← i23 + c3
  let limbs10 ← Array.update limbs9 4#usize i24
  ok limbs10

/- [curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::to_bytes]:
   Source: 'curve25519-dalek/src/backend/serial/u64/field.rs', lines 374:4-456:5 -/
def backend.serial.u64.field.FieldElement51.to_bytes
  (self : backend.serial.u64.field.FieldElement51) :
  Result (Array U8 32#usize)
  :=
  do
  let fe ← backend.serial.u64.field.FieldElement51.reduce self
  let i ← Array.index_usize fe 0#usize
  let i1 ← i + 19#u64
  let q ← i1 >>> 51#i32
  let i2 ← Array.index_usize fe 1#usize
  let i3 ← i2 + q
  let q1 ← i3 >>> 51#i32
  let i4 ← Array.index_usize fe 2#usize
  let i5 ← i4 + q1
  let q2 ← i5 >>> 51#i32
  let i6 ← Array.index_usize fe 3#usize
  let i7 ← i6 + q2
  let q3 ← i7 >>> 51#i32
  let i8 ← Array.index_usize fe 4#usize
  let i9 ← i8 + q3
  let q4 ← i9 >>> 51#i32
  let i10 ← 19#u64 * q4
  let i11 ← i + i10
  let limbs ← Array.update fe 0#usize i11
  let i12 ← 1#u64 <<< 51#i32
  let low_51_bit_mask ← i12 - 1#u64
  let i13 ← Array.index_usize limbs 0#usize
  let i14 ← i13 >>> 51#i32
  let i15 ← Array.index_usize limbs 1#usize
  let i16 ← i15 + i14
  let limbs1 ← Array.update limbs 1#usize i16
  let i17 ← Array.index_usize limbs1 0#usize
  let i18 ← (↑(i17 &&& low_51_bit_mask) : Result U64)
  let limbs2 ← Array.update limbs1 0#usize i18
  let i19 ← Array.index_usize limbs2 1#usize
  let i20 ← i19 >>> 51#i32
  let i21 ← Array.index_usize limbs2 2#usize
  let i22 ← i21 + i20
  let limbs3 ← Array.update limbs2 2#usize i22
  let i23 ← Array.index_usize limbs3 1#usize
  let i24 ← (↑(i23 &&& low_51_bit_mask) : Result U64)
  let limbs4 ← Array.update limbs3 1#usize i24
  let i25 ← Array.index_usize limbs4 2#usize
  let i26 ← i25 >>> 51#i32
  let i27 ← Array.index_usize limbs4 3#usize
  let i28 ← i27 + i26
  let limbs5 ← Array.update limbs4 3#usize i28
  let i29 ← Array.index_usize limbs5 2#usize
  let i30 ← (↑(i29 &&& low_51_bit_mask) : Result U64)
  let limbs6 ← Array.update limbs5 2#usize i30
  let i31 ← Array.index_usize limbs6 3#usize
  let i32 ← i31 >>> 51#i32
  let i33 ← Array.index_usize limbs6 4#usize
  let i34 ← i33 + i32
  let limbs7 ← Array.update limbs6 4#usize i34
  let i35 ← Array.index_usize limbs7 3#usize
  let i36 ← (↑(i35 &&& low_51_bit_mask) : Result U64)
  let limbs8 ← Array.update limbs7 3#usize i36
  let i37 ← Array.index_usize limbs8 4#usize
  let i38 ← (↑(i37 &&& low_51_bit_mask) : Result U64)
  let limbs9 ← Array.update limbs8 4#usize i38
  let s := Array.repeat 32#usize 0#u8
  let i39 ← Array.index_usize limbs9 0#usize
  let i40 ← (↑(UScalar.cast .U8 i39) : Result U8)
  let s1 ← Array.update s 0#usize i40
  let i41 ← i39 >>> 8#i32
  let i42 ← (↑(UScalar.cast .U8 i41) : Result U8)
  let s2 ← Array.update s1 1#usize i42
  let i43 ← i39 >>> 16#i32
  let i44 ← (↑(UScalar.cast .U8 i43) : Result U8)
  let s3 ← Array.update s2 2#usize i44
  let i45 ← i39 >>> 24#i32
  let i46 ← (↑(UScalar.cast .U8 i45) : Result U8)
  let s4 ← Array.update s3 3#usize i46
  let i47 ← i39 >>> 32#i32
  let i48 ← (↑(UScalar.cast .U8 i47) : Result U8)
  let s5 ← Array.update s4 4#usize i48
  let i49 ← i39 >>> 40#i32
  let i50 ← (↑(UScalar.cast .U8 i49) : Result U8)
  let s6 ← Array.update s5 5#usize i50
  let i51 ← i39 >>> 48#i32
  let i52 ← Array.index_usize limbs9 1#usize
  let i53 ← i52 <<< 3#i32
  let i54 ← (↑(i51 ||| i53) : Result U64)
  let i55 ← (↑(UScalar.cast .U8 i54) : Result U8)
  let s7 ← Array.update s6 6#usize i55
  let i56 ← i52 >>> 5#i32
  let i57 ← (↑(UScalar.cast .U8 i56) : Result U8)
  let s8 ← Array.update s7 7#usize i57
  let i58 ← i52 >>> 13#i32
  let i59 ← (↑(UScalar.cast .U8 i58) : Result U8)
  let s9 ← Array.update s8 8#usize i59
  let i60 ← i52 >>> 21#i32
  let i61 ← (↑(UScalar.cast .U8 i60) : Result U8)
  let s10 ← Array.update s9 9#usize i61
  let i62 ← i52 >>> 29#i32
  let i63 ← (↑(UScalar.cast .U8 i62) : Result U8)
  let s11 ← Array.update s10 10#usize i63
  let i64 ← i52 >>> 37#i32
  let i65 ← (↑(UScalar.cast .U8 i64) : Result U8)
  let s12 ← Array.update s11 11#usize i65
  let i66 ← i52 >>> 45#i32
  let i67 ← Array.index_usize limbs9 2#usize
  let i68 ← i67 <<< 6#i32
  let i69 ← (↑(i66 ||| i68) : Result U64)
  let i70 ← (↑(UScalar.cast .U8 i69) : Result U8)
  let s13 ← Array.update s12 12#usize i70
  let i71 ← i67 >>> 2#i32
  let i72 ← (↑(UScalar.cast .U8 i71) : Result U8)
  let s14 ← Array.update s13 13#usize i72
  let i73 ← i67 >>> 10#i32
  let i74 ← (↑(UScalar.cast .U8 i73) : Result U8)
  let s15 ← Array.update s14 14#usize i74
  let i75 ← i67 >>> 18#i32
  let i76 ← (↑(UScalar.cast .U8 i75) : Result U8)
  let s16 ← Array.update s15 15#usize i76
  let i77 ← i67 >>> 26#i32
  let i78 ← (↑(UScalar.cast .U8 i77) : Result U8)
  let s17 ← Array.update s16 16#usize i78
  let i79 ← i67 >>> 34#i32
  let i80 ← (↑(UScalar.cast .U8 i79) : Result U8)
  let s18 ← Array.update s17 17#usize i80
  let i81 ← i67 >>> 42#i32
  let i82 ← (↑(UScalar.cast .U8 i81) : Result U8)
  let s19 ← Array.update s18 18#usize i82
  let i83 ← i67 >>> 50#i32
  let i84 ← Array.index_usize limbs9 3#usize
  let i85 ← i84 <<< 1#i32
  let i86 ← (↑(i83 ||| i85) : Result U64)
  let i87 ← (↑(UScalar.cast .U8 i86) : Result U8)
  let s20 ← Array.update s19 19#usize i87
  let i88 ← i84 >>> 7#i32
  let i89 ← (↑(UScalar.cast .U8 i88) : Result U8)
  let s21 ← Array.update s20 20#usize i89
  let i90 ← i84 >>> 15#i32
  let i91 ← (↑(UScalar.cast .U8 i90) : Result U8)
  let s22 ← Array.update s21 21#usize i91
  let i92 ← i84 >>> 23#i32
  let i93 ← (↑(UScalar.cast .U8 i92) : Result U8)
  let s23 ← Array.update s22 22#usize i93
  let i94 ← i84 >>> 31#i32
  let i95 ← (↑(UScalar.cast .U8 i94) : Result U8)
  let s24 ← Array.update s23 23#usize i95
  let i96 ← i84 >>> 39#i32
  let i97 ← (↑(UScalar.cast .U8 i96) : Result U8)
  let s25 ← Array.update s24 24#usize i97
  let i98 ← i84 >>> 47#i32
  let i99 ← Array.index_usize limbs9 4#usize
  let i100 ← i99 <<< 4#i32
  let i101 ← (↑(i98 ||| i100) : Result U64)
  let i102 ← (↑(UScalar.cast .U8 i101) : Result U8)
  let s26 ← Array.update s25 25#usize i102
  let i103 ← i99 >>> 4#i32
  let i104 ← (↑(UScalar.cast .U8 i103) : Result U8)
  let s27 ← Array.update s26 26#usize i104
  let i105 ← i99 >>> 12#i32
  let i106 ← (↑(UScalar.cast .U8 i105) : Result U8)
  let s28 ← Array.update s27 27#usize i106
  let i107 ← i99 >>> 20#i32
  let i108 ← (↑(UScalar.cast .U8 i107) : Result U8)
  let s29 ← Array.update s28 28#usize i108
  let i109 ← i99 >>> 28#i32
  let i110 ← (↑(UScalar.cast .U8 i109) : Result U8)
  let s30 ← Array.update s29 29#usize i110
  let i111 ← i99 >>> 36#i32
  let i112 ← (↑(UScalar.cast .U8 i111) : Result U8)
  let s31 ← Array.update s30 30#usize i112
  let i113 ← i99 >>> 44#i32
  let i114 ← (↑(UScalar.cast .U8 i113) : Result U8)
  let s32 ← Array.update s31 31#usize i114
  let i115 ← Array.index_usize s32 31#usize
  let i116 ← (↑(i115 &&& 128#u8) : Result U8)
  massert (i116 = 0#u8)
  ok s32

/- [curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::Index<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::index]:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 43:4-45:5 -/
def
  backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
  (self : backend.serial.u64.scalar.Scalar52) (_index : Usize) : Result U64 :=
  Array.index_usize self _index

/- Trait implementation: [curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::Index<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}]
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 41:0-46:1 -/
@[reducible]
def core.ops.index.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64
  : core.ops.index.Index backend.serial.u64.scalar.Scalar52 Usize U64 := {
  index :=
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
}

/- [curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::IndexMut<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::index_mut]:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 49:4-51:5 -/
def
  backend.serial.u64.scalar.IndexMutcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index_mut
  (self : backend.serial.u64.scalar.Scalar52) (_index : Usize) :
  Result (U64 × (U64 → backend.serial.u64.scalar.Scalar52))
  :=
  do
  let (i, index_mut_back) ← Array.index_mut_usize self _index
  let back := fun ret => let a := index_mut_back ret
                         a
  ok (i, back)

/- Trait implementation: [curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::IndexMut<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}]
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 48:0-52:1 -/
@[reducible]
def
  core.ops.index.IndexMutcurve25519_dalekbackendserialu64scalarScalar52UsizeU64
  : core.ops.index.IndexMut backend.serial.u64.scalar.Scalar52 Usize U64 := {
  indexInst :=
    core.ops.index.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64
  index_mut :=
    backend.serial.u64.scalar.IndexMutcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index_mut
}

/- [curve25519_dalek::backend::serial::u64::scalar::m]:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 56:0-58:1 -/
def backend.serial.u64.scalar.m (x : U64) (y : U64) : Result U128 :=
  do
  let i ← (↑(UScalar.cast .U128 x) : Result U128)
  let i1 ← (↑(UScalar.cast .U128 y) : Result U128)
  i * i1

/- [curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::ZERO]
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 62:4-62:57 -/
@[global_simps]
def backend.serial.u64.scalar.Scalar52.ZERO_body
  : Result backend.serial.u64.scalar.Scalar52 :=
  let a := Array.repeat 5#usize 0#u64
  ok a
@[global_simps, irreducible]
def backend.serial.u64.scalar.Scalar52.ZERO
  : backend.serial.u64.scalar.Scalar52 :=
  eval_global backend.serial.u64.scalar.Scalar52.ZERO_body

/- [curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::conditional_add_l]: loop 0:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 200:8-205:9 -/
def backend.serial.u64.scalar.Scalar52.conditional_add_l_loop
  (self : backend.serial.u64.scalar.Scalar52) (condition : subtle.Choice)
  (carry : U64) (mask : U64) (i : Usize) :
  Result (U64 × backend.serial.u64.scalar.Scalar52)
  :=
  if i < 5#usize
  then
    do
    let i1 ←
      backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
        backend.serial.u64.constants.L i
    let addend ←
      subtle.ConditionallySelectableU64.conditional_select 0#u64 i1 condition
    let i2 ← carry >>> 52#i32
    let i3 ←
      backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
        self i
    let i4 ← i2 + i3
    let carry1 ← i4 + addend
    let (_, index_mut_back) ←
      backend.serial.u64.scalar.IndexMutcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index_mut
        self i
    let i5 ← (↑(carry1 &&& mask) : Result U64)
    let i6 ← i + 1#usize
    let self1 := index_mut_back i5
    backend.serial.u64.scalar.Scalar52.conditional_add_l_loop self1 condition
      carry1 mask i6
  else ok (carry, self)
partial_fixpoint

/- [curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::conditional_add_l]:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 195:4-208:5 -/
def backend.serial.u64.scalar.Scalar52.conditional_add_l
  (self : backend.serial.u64.scalar.Scalar52) (condition : subtle.Choice) :
  Result (U64 × backend.serial.u64.scalar.Scalar52)
  :=
  do
  let i ← 1#u64 <<< 52#i32
  let mask ← i - 1#u64
  backend.serial.u64.scalar.Scalar52.conditional_add_l_loop self condition
    0#u64 mask 0#usize

/- [curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::sub]: loop 0:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 184:8-188:9 -/
def backend.serial.u64.scalar.Scalar52.sub_loop
  (a : backend.serial.u64.scalar.Scalar52)
  (b : backend.serial.u64.scalar.Scalar52)
  (difference : backend.serial.u64.scalar.Scalar52) (mask : U64) (borrow : U64)
  (i : Usize) :
  Result backend.serial.u64.scalar.Scalar52
  :=
  if i < 5#usize
  then
    do
    let i1 ←
      backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
        a i
    let i2 ←
      backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
        b i
    let i3 ← borrow >>> 63#i32
    let i4 ← i2 + i3
    let borrow1 ← (↑(core.num.U64.wrapping_sub i1 i4) : Result U64)
    let (_, index_mut_back) ←
      backend.serial.u64.scalar.IndexMutcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index_mut
        difference i
    let i5 ← (↑(borrow1 &&& mask) : Result U64)
    let i6 ← i + 1#usize
    let difference1 := index_mut_back i5
    backend.serial.u64.scalar.Scalar52.sub_loop a b difference1 mask borrow1 i6
  else
    do
    let i1 ← borrow >>> 63#i32
    let i2 ← (↑(UScalar.cast .U8 i1) : Result U8)
    let c ← subtle.FromsubtleChoiceU8.from i2
    let (_, difference1) ←
      backend.serial.u64.scalar.Scalar52.conditional_add_l difference c
    ok difference1
partial_fixpoint

/- [curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::sub]:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 177:4-193:5 -/
def backend.serial.u64.scalar.Scalar52.sub
  (a : backend.serial.u64.scalar.Scalar52)
  (b : backend.serial.u64.scalar.Scalar52) :
  Result backend.serial.u64.scalar.Scalar52
  :=
  do
  let i ← 1#u64 <<< 52#i32
  let mask ← i - 1#u64
  backend.serial.u64.scalar.Scalar52.sub_loop a b
    backend.serial.u64.scalar.Scalar52.ZERO mask 0#u64 0#usize

/- [curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::mul_internal]:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 213:4-227:5 -/
def backend.serial.u64.scalar.Scalar52.mul_internal
  (a : backend.serial.u64.scalar.Scalar52)
  (b : backend.serial.u64.scalar.Scalar52) :
  Result (Array U128 9#usize)
  :=
  do
  let z := Array.repeat 9#usize 0#u128
  let i ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 0#usize
  let i1 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      b 0#usize
  let i2 ← backend.serial.u64.scalar.m i i1
  let z1 ← Array.update z 0#usize i2
  let i3 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      b 1#usize
  let i4 ← backend.serial.u64.scalar.m i i3
  let i5 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 1#usize
  let i6 ← backend.serial.u64.scalar.m i5 i1
  let i7 ← i4 + i6
  let z2 ← Array.update z1 1#usize i7
  let i8 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      b 2#usize
  let i9 ← backend.serial.u64.scalar.m i i8
  let i10 ← backend.serial.u64.scalar.m i5 i3
  let i11 ← i9 + i10
  let i12 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 2#usize
  let i13 ← backend.serial.u64.scalar.m i12 i1
  let i14 ← i11 + i13
  let z3 ← Array.update z2 2#usize i14
  let i15 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      b 3#usize
  let i16 ← backend.serial.u64.scalar.m i i15
  let i17 ← backend.serial.u64.scalar.m i5 i8
  let i18 ← i16 + i17
  let i19 ← backend.serial.u64.scalar.m i12 i3
  let i20 ← i18 + i19
  let i21 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 3#usize
  let i22 ← backend.serial.u64.scalar.m i21 i1
  let i23 ← i20 + i22
  let z4 ← Array.update z3 3#usize i23
  let i24 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      b 4#usize
  let i25 ← backend.serial.u64.scalar.m i i24
  let i26 ← backend.serial.u64.scalar.m i5 i15
  let i27 ← i25 + i26
  let i28 ← backend.serial.u64.scalar.m i12 i8
  let i29 ← i27 + i28
  let i30 ← backend.serial.u64.scalar.m i21 i3
  let i31 ← i29 + i30
  let i32 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 4#usize
  let i33 ← backend.serial.u64.scalar.m i32 i1
  let i34 ← i31 + i33
  let z5 ← Array.update z4 4#usize i34
  let i35 ← backend.serial.u64.scalar.m i5 i24
  let i36 ← backend.serial.u64.scalar.m i12 i15
  let i37 ← i35 + i36
  let i38 ← backend.serial.u64.scalar.m i21 i8
  let i39 ← i37 + i38
  let i40 ← backend.serial.u64.scalar.m i32 i3
  let i41 ← i39 + i40
  let z6 ← Array.update z5 5#usize i41
  let i42 ← backend.serial.u64.scalar.m i12 i24
  let i43 ← backend.serial.u64.scalar.m i21 i15
  let i44 ← i42 + i43
  let i45 ← backend.serial.u64.scalar.m i32 i8
  let i46 ← i44 + i45
  let z7 ← Array.update z6 6#usize i46
  let i47 ← backend.serial.u64.scalar.m i21 i24
  let i48 ← backend.serial.u64.scalar.m i32 i15
  let i49 ← i47 + i48
  let z8 ← Array.update z7 7#usize i49
  let i50 ← backend.serial.u64.scalar.m i32 i24
  Array.update z8 8#usize i50

/- [curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::square_internal]:
   Source: 'curve25519-dalek/src/backend/serial/u64/scalar.rs', lines 232:4-251:5 -/
def backend.serial.u64.scalar.Scalar52.square_internal
  (a : backend.serial.u64.scalar.Scalar52) : Result (Array U128 9#usize) :=
  do
  let i ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 0#usize
  let i1 ← i * 2#u64
  let i2 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 1#usize
  let i3 ← i2 * 2#u64
  let i4 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 2#usize
  let i5 ← i4 * 2#u64
  let i6 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 3#usize
  let i7 ← i6 * 2#u64
  let i8 ← backend.serial.u64.scalar.m i i
  let i9 ← Array.index_usize (Array.make 4#usize [ i1, i3, i5, i7 ]) 0#usize
  let i10 ← backend.serial.u64.scalar.m i9 i2
  let i11 ← backend.serial.u64.scalar.m i9 i4
  let i12 ← backend.serial.u64.scalar.m i2 i2
  let i13 ← i11 + i12
  let i14 ← backend.serial.u64.scalar.m i9 i6
  let i15 ← Array.index_usize (Array.make 4#usize [ i1, i3, i5, i7 ]) 1#usize
  let i16 ← backend.serial.u64.scalar.m i15 i4
  let i17 ← i14 + i16
  let i18 ←
    backend.serial.u64.scalar.Indexcurve25519_dalekbackendserialu64scalarScalar52UsizeU64.index
      a 4#usize
  let i19 ← backend.serial.u64.scalar.m i9 i18
  let i20 ← backend.serial.u64.scalar.m i15 i6
  let i21 ← i19 + i20
  let i22 ← backend.serial.u64.scalar.m i4 i4
  let i23 ← i21 + i22
  let i24 ← backend.serial.u64.scalar.m i15 i18
  let i25 ← Array.index_usize (Array.make 4#usize [ i1, i3, i5, i7 ]) 2#usize
  let i26 ← backend.serial.u64.scalar.m i25 i6
  let i27 ← i24 + i26
  let i28 ← backend.serial.u64.scalar.m i25 i18
  let i29 ← backend.serial.u64.scalar.m i6 i6
  let i30 ← i28 + i29
  let i31 ← Array.index_usize (Array.make 4#usize [ i1, i3, i5, i7 ]) 3#usize
  let i32 ← backend.serial.u64.scalar.m i31 i18
  let i33 ← backend.serial.u64.scalar.m i18 i18
  ok (Array.make 9#usize [ i8, i10, i13, i17, i23, i27, i30, i32, i33 ])

/- [curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ZERO]
   Source: 'curve25519-dalek/src/scalar.rs', lines 564:4-564:53 -/
@[global_simps]
def scalar.Scalar.ZERO_body : Result scalar.Scalar :=
  let a := Array.repeat 32#usize 0#u8
  ok { bytes := a }
@[global_simps, irreducible]
def scalar.Scalar.ZERO : scalar.Scalar := eval_global scalar.Scalar.ZERO_body

/- [curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ONE]
   Source: 'curve25519-dalek/src/scalar.rs', lines 567:4-572:6 -/
@[global_simps]
def scalar.Scalar.ONE_body : Result scalar.Scalar :=
  ok
    {
      bytes :=
        (Array.make 32#usize [
          1#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8,
          0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8,
          0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8, 0#u8
          ])
    }
@[global_simps, irreducible]
def scalar.Scalar.ONE : scalar.Scalar := eval_global scalar.Scalar.ONE_body

/- [curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::to_bytes]:
   Source: 'curve25519-dalek/src/scalar.rs', lines 691:4-693:5 -/
def scalar.Scalar.to_bytes
  (self : scalar.Scalar) : Result (Array U8 32#usize) :=
  ok self.bytes

/- [curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_bytes]:
   Source: 'curve25519-dalek/src/scalar.rs', lines 706:4-708:5 -/
def scalar.Scalar.as_bytes
  (self : scalar.Scalar) : Result (Array U8 32#usize) :=
  ok self.bytes

/- [curve25519_dalek::scalar::clamp_integer]:
   Source: 'curve25519-dalek/src/scalar.rs', lines 1386:0-1391:1 -/
def scalar.clamp_integer
  (bytes : Array U8 32#usize) : Result (Array U8 32#usize) :=
  do
  let i ← Array.index_usize bytes 0#usize
  let i1 ← (↑(i &&& 248#u8) : Result U8)
  let bytes1 ← Array.update bytes 0#usize i1
  let i2 ← Array.index_usize bytes1 31#usize
  let i3 ← (↑(i2 &&& 127#u8) : Result U8)
  let bytes2 ← Array.update bytes1 31#usize i3
  let i4 ← Array.index_usize bytes2 31#usize
  let i5 ← (↑(i4 ||| 64#u8) : Result U8)
  Array.update bytes2 31#usize i5

end curve25519_dalek

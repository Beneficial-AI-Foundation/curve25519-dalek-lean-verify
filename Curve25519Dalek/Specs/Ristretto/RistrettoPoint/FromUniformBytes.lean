/-
Copyright (c) 2026 Beneficial AI Foundation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Dablander
-/
import Curve25519Dalek.Funs
import Curve25519Dalek.Defs.Edwards.Representation
import Curve25519Dalek.Specs.Backend.Serial.U64.Field.FieldElement51.FromBytes

/-! # Spec Theorem for `RistrettoPoint::from_uniform_bytes`

Specification and proof for `RistrettoPoint::from_uniform_bytes`.

This function constructs a uniformly sampled `RistrettoPoint` from 64 bytes of uniform random data
by applying the Ristretto-flavored Elligator map to two field elements generated by two 32-byte halfs
and adding the resulting two Ristretto points via elliptic curve addition.

**Source**: curve25519-dalek/src/ristretto.rs
-/

open Aeneas.Std Result core.ops.range

namespace curve25519_dalek.ristretto.RistrettoPoint

/-
natural language description:

The Ristretto group is a prime-order group constructed as a quotient of the Edwards curve.
The `from_uniform_bytes` function implements a map from 64 bytes to Ristretto group elements
that ensures a uniform distribution: if the input bytes are uniformly random, the output
Ristretto point is uniformly distributed over the Ristretto group.

The mapping is achieved by:

- Splitting the 64-byte input into two 32-byte halves
- Taking the low 255 bits of each half modulo p and converting to a field element (via `from_bytes`)
- Applying the Ristretto-flavored Elligator map to each field element to transform it into a Ristretto point
- Adding the two resulting Ristretto points via elliptic curve addition

natural language specs:

- The function always succeeds (no panic) for arbitrary 64-byte inputs
- The output is a mathematically valid Ristretto point (i.e., an even Edwards point that lies on the curve)
-/

/-- **Spec and proof concerning `ristretto.RistrettoPoint.from_uniform_bytes`**:
- The function always succeeds (no panic) for arbitrary 64-byte inputs
- The output is a mathematically valid Ristretto point (i.e., an even Edwards point that lies on the curve)
-/

def split64to32 (input : Array U8 64#usize) : Result (Array U8 32#usize × Array U8 32#usize) :=
  let a1 := input.subslice (Range.mk 0#usize 32#usize)
  let a2 := input.subslice (Range.mk 32#usize 64#usize)
  match a1, a2 with
  | ok s1, ok s2 => ok (Array.from_slice (Array.repeat 32#usize 0#u8) s1,
                        Array.from_slice (Array.repeat 32#usize 0#u8) s2)
  | _, _ => fail Error.panic

@[progress]
theorem split64to32_spec (input : Array U8 64#usize) :
    ∃ a1 a2,
        split64to32 input = ok (a1, a2) ∧
        (∀ i : ℕ, i < 32 → a1.val[i]! = input.val[i]! ∧ a2.val[i]! = input.val[i + 32]!) := by
  simp [split64to32]
  have h1 :=
    Array.subslice_spec input (Range.mk 0#usize 32#usize)
      (by scalar_tac) (by scalar_tac)
  have h2 :=
    Array.subslice_spec input (Range.mk 32#usize 64#usize)
      (by scalar_tac) (by scalar_tac)
  rcases h1 with ⟨s1, ha1, hs1, hget1⟩
  rcases h2 with ⟨s2, ha2, hs2, hget2⟩
  refine ⟨
    Array.from_slice (Array.repeat 32#usize 0#u8) s1,
    Array.from_slice (Array.repeat 32#usize 0#u8) s2,
    ?_, ?_
  ⟩
  · simp [ha1, ha2]
  · intro i hi
    simp [Array.from_slice]
    have hsl1 : ↑s1.length = 32 := by scalar_tac
    have hsl2 : ↑s2.length = 32 := by scalar_tac
    constructor
    · simp only [Slice.length] at hsl1
      simp [hsl1]
      simp_all only [UScalar.ofNat_val_eq, List.slice_zero_j, add_zero, List.length_take, List.Vector.length_val,
        Nat.reduceLeDiff, inf_of_le_left, getElem!_pos, List.getElem_take, zero_add, List.getElem!_eq_getElem?_getD,
        Slice.length, getElem?_pos, Option.getD_some]
    · simp only [Slice.length] at hsl2
      simp [hsl2]
      simp_all only [UScalar.ofNat_val_eq, add_zero, List.length_take, List.getElem_take, zero_add,
      List.getElem!_eq_getElem?_getD, Slice.length, getElem?_pos, Option.getD_some, List.slice, Nat.reduceSub,
      List.getElem_take, List.getElem_drop, Nat.add_comm 32 i]
      grind only [= List.getElem_drop, = List.getElem?_drop, → List.getElem_of_getElem?,
        = Option.getD_some, = List.getElem?_eq_none, = List.length_take, = getElem?_pos,
        = getElem?_neg, = min_def, = List.drop_zero, = List.length_drop, = Nat.min_def,
        = List.getElem?_take]

@[progress]
theorem from_uniform_bytes_spec (bytes : Array U8 64#usize) :
    ∃ rist,
      from_uniform_bytes bytes = ok rist ∧
      rist.IsValid := by
  sorry


/-
Note: An optional, potentially desirable extension of this spec theorem may be to
define a purely mathematical version f_ell of the elligator map in Representation.lean
that maps mathematical field elements to even Edwards points and then subsequently
show that it holds for

s_left := from_bytes bytes[0:32]

and

s_right := from_bytes bytes[32:64]

that

f_ell(s_left.toField) + f_ell(s_right.toField) = rist.toPoint.
-/

end curve25519_dalek.ristretto.RistrettoPoint

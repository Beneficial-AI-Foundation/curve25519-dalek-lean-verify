/-
Copyright (c) 2025 Beneficial AI Foundation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Dablander
-/
import Curve25519Dalek.Funs
import Curve25519Dalek.Defs.Edwards.Representation
import Curve25519Dalek.Specs.Backend.Serial.U64.Field.FieldElement51.FromBytes

/-! # Spec Theorem for `RistrettoPoint::from_uniform_bytes`

Specification and proof for `RistrettoPoint::from_uniform_bytes`.

This function constructs a uniformly sampled `RistrettoPoint` from 64 bytes of uniform random data
by applying the Ristretto-flavored Elligator map to two field elements generated by two 32-byte halfs
and adding the resulting two Ristretto points via elliptic curve addition.

**Source**: curve25519-dalek/src/ristretto.rs

## TODO
- Complete proof
-/

open Aeneas.Std Result core.ops.range

namespace curve25519_dalek.ristretto.RistrettoPoint

/-
natural language description:

The Ristretto group is a prime-order group constructed as a quotient of the Edwards curve.
The `from_uniform_bytes` function implements a one-way map from 64 bytes to Ristretto group elements
that ensures a uniform distribution: if the input bytes are uniformly random, the output
Ristretto point is uniformly distributed over the Ristretto group.

This is achieved by:
- Splitting the 64-byte input into two 32-byte halves
- Taking the low 255 bits of each half modulo p and converting to a field element (via `from_bytes`)
- Applying the Ristretto-flavored Elligator map to each field element to transform it into a Ristretto point
- Adding the two resulting Ristretto points via elliptic curve addition

natural language specs:

- The function always succeeds (no panic)
- The output is a mathematically valid Ristretto point
- If the input bytes are uniformly distributed, the output point is uniformly
  distributed over the Ristretto group (we skip the implementation of this spec as it would
  require more extensive probability theory formalizations)
-/

/-- **Spec and proof concerning `ristretto.RistrettoPoint.from_uniform_bytes`**:
- The function always succeeds (no panic)
- The output is a mathematically valid Ristretto point
-/

def split64to32 (input : Array U8 64#usize) : Result (Array U8 32#usize × Array U8 32#usize) :=
  let a1 := input.subslice (Range.mk 0#usize 32#usize)
  let a2 := input.subslice (Range.mk 32#usize 64#usize)
  match a1, a2 with
  | ok s1, ok s2 => ok (Array.from_slice (Array.repeat 32#usize 0#u8) s1,
                        Array.from_slice (Array.repeat 32#usize 0#u8) s2)
  | _, _ => fail Error.panic

@[progress]
theorem split64to32_spec (input : Array U8 64#usize) :
    ∃ a1 a2,
      split64to32 input = ok (a1, a2) ∧
      (∀ i : ℕ, i < 32 → a1.val[i]! = input.val[i]! ∧ a2.val[i]! = input.val[i + 32]!)
:= by
simp [split64to32]
have h1 := Array.subslice_spec input (Range.mk 0#usize 32#usize)
  (by scalar_tac) (by scalar_tac)
have h2 := Array.subslice_spec input (Range.mk 32#usize 64#usize)
  (by scalar_tac) (by scalar_tac)
simp at h1 h2
let ⟨s1, ha1, hs1, hget1⟩ := h1
let ⟨s2, ha2, hs2, hget2⟩ := h2
apply Exists.intro (Array.from_slice (Array.repeat 32#usize 0#u8) s1)
apply Exists.intro (Array.from_slice (Array.repeat 32#usize 0#u8) s2)
simp [ha1, ha2]
intro i hi
constructor
· simp only [Array.from_slice, List.length_take, List.Vector.length_val, UScalar.ofNat_val_eq,
  Nat.reduceLeDiff, inf_of_le_left, ↓reduceDIte, getElem?_pos, List.getElem_take, Option.getD_some,
  hs1, hi]
  simp_all only [ok.injEq, exists_eq_left', List.length_take, List.Vector.length_val, UScalar.ofNat_val_eq,
  Nat.reduceLeDiff, inf_of_le_left, getElem?_pos, List.getElem_take, Option.getD_some, true_and, implies_true]
· simp only [Array.from_slice, UScalar.ofNat_val_eq, List.Vector.length_val, getElem?_pos,
  Option.getD_some, hs2, hi]
  have hsl : s2.length = 32#usize := by scalar_tac
  simp only [Slice.length, hs2, UScalar.ofNat_val_eq] at hsl
  simp_all only [ok.injEq, exists_eq_left', List.length_take, List.Vector.length_val,
    UScalar.ofNat_val_eq, Nat.reduceLeDiff, inf_of_le_left, getElem?_pos, List.getElem_take,
    Option.getD_some, true_and, implies_true, ↓reduceDIte]
  simp only [List.slice, Nat.reduceSub, List.getElem_take, List.getElem_drop]
  simp only [Nat.add_comm 32 i]
  grind only [→ List.getElem_of_getElem?, = Option.getD_some, = List.getElem?_eq_none, = getElem?_pos,
    = getElem?_neg]

@[progress]
theorem from_uniform_bytes_spec (bytes : Array U8 64#usize) :
    ∃ rist,
      from_uniform_bytes bytes = ok rist ∧
      rist.IsValid :=
by
sorry

end curve25519_dalek.ristretto.RistrettoPoint

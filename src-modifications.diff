# Modifications to curve25519-dalek source code

This file contains the diff between the original curve25519-dalek source
and the modified version used in this verification project.

- **Upstream Repository**: https://github.com/dalek-cryptography/curve25519-dalek
- **Upstream Commit**: 8016d6d9b9cdbaa681f24147e0b9377cc8cef934
- **Upstream Tag**: curve25519-4.2.0

---

diff -Naur --no-dereference a/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs b/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs
--- a/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs
+++ b/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs
@@ -30,7 +30,9 @@
 
     // Find starting index
     let mut i: usize = 255;
-    for j in (0..256).rev() {
+    let mut j: usize = 256;
+    while j > 0 {
+        j -= 1;
         i = j;
         if a_naf[i] != 0 || b_naf[i] != 0 {
             break;
diff -Naur --no-dereference a/curve25519-dalek/src/backend/serial/u64/field.rs b/curve25519-dalek/src/backend/serial/u64/field.rs
--- a/curve25519-dalek/src/backend/serial/u64/field.rs
+++ b/curve25519-dalek/src/backend/serial/u64/field.rs
@@ -57,8 +57,10 @@
 
 impl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {
     fn add_assign(&mut self, _rhs: &'a FieldElement51) {
-        for i in 0..5 {
+        let mut i = 0;
+        while i < 5 {
             self.0[i] += _rhs.0[i];
+            i += 1;
         }
     }
 }
@@ -572,8 +574,10 @@
     /// Returns 2 times the square of this field element.
     pub fn square2(&self) -> FieldElement51 {
         let mut square = self.pow2k(1);
-        for i in 0..5 {
+        let mut i = 0;
+        while i < 5 {
             square.0[i] *= 2;
+            i += 1;
         }
 
         square
diff -Naur --no-dereference a/curve25519-dalek/src/backend/serial/u64/scalar.rs b/curve25519-dalek/src/backend/serial/u64/scalar.rs
--- a/curve25519-dalek/src/backend/serial/u64/scalar.rs
+++ b/curve25519-dalek/src/backend/serial/u64/scalar.rs
@@ -65,10 +65,18 @@
     #[rustfmt::skip] // keep alignment of s[*] calculations
     pub fn from_bytes(bytes: &[u8; 32]) -> Scalar52 {
         let mut words = [0u64; 4];
-        for i in 0..4 {
-            for j in 0..8 {
-                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);
-            }
+        let mut i = 0;
+        while i < 4 {
+            let base = i * 8;
+            words[i] = (bytes[base] as u64)
+                | ((bytes[base + 1] as u64) << 8)
+                | ((bytes[base + 2] as u64) << 16)
+                | ((bytes[base + 3] as u64) << 24)
+                | ((bytes[base + 4] as u64) << 32)
+                | ((bytes[base + 5] as u64) << 40)
+                | ((bytes[base + 6] as u64) << 48)
+                | ((bytes[base + 7] as u64) << 56);
+            i += 1;
         }
 
         let mask = (1u64 << 52) - 1;
@@ -88,10 +96,18 @@
     #[rustfmt::skip] // keep alignment of lo[*] and hi[*] calculations
     pub fn from_bytes_wide(bytes: &[u8; 64]) -> Scalar52 {
         let mut words = [0u64; 8];
-        for i in 0..8 {
-            for j in 0..8 {
-                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);
-            }
+        let mut i = 0;
+        while i < 8 {
+            // Explicitly unrolled inner loop - 8 steps
+            words[i] |= (bytes[i * 8] as u64) << (0);
+            words[i] |= (bytes[(i * 8) + 1] as u64) << (8);
+            words[i] |= (bytes[(i * 8) + 2] as u64) << (2 * 8);
+            words[i] |= (bytes[(i * 8) + 3] as u64) << (3 * 8);
+            words[i] |= (bytes[(i * 8) + 4] as u64) << (4 * 8);
+            words[i] |= (bytes[(i * 8) + 5] as u64) << (5 * 8);
+            words[i] |= (bytes[(i * 8) + 6] as u64) << (6 * 8);
+            words[i] |= (bytes[(i * 8) + 7] as u64) << (7 * 8);
+            i += 1;
         }
 
         let mask = (1u64 << 52) - 1;
@@ -164,9 +180,11 @@
 
         // a + b
         let mut carry: u64 = 0;
-        for i in 0..5 {
+        let mut i = 0;
+        while i < 5 {
             carry = a[i] + b[i] + (carry >> 52);
             sum[i] = carry & mask;
+            i += 1;
         }
 
         // subtract l if the sum is >= l
@@ -180,27 +198,37 @@
 
         // a - b
         let mut borrow: u64 = 0;
-        for i in 0..5 {
+        let mut i = 0;
+        while i < 5 {
             borrow = a[i].wrapping_sub(b[i] + (borrow >> 63));
             difference[i] = borrow & mask;
+            i += 1;
         }
 
         // conditionally add l if the difference is negative
+        difference.conditional_add_l(Choice::from((borrow >> 63) as u8));
+        difference
+    }
+
+    pub(crate) fn conditional_add_l(&mut self, condition: Choice) -> u64 {
         let mut carry: u64 = 0;
-        for i in 0..5 {
-            let underflow = Choice::from((borrow >> 63) as u8);
-            let addend = u64::conditional_select(&0, &constants::L[i], underflow);
-            carry = (carry >> 52) + difference[i] + addend;
-            difference[i] = carry & mask;
+        let mask = (1u64 << 52) - 1;
+
+        let mut i = 0;
+        while i < 5 {
+            let addend = u64::conditional_select(&0, &constants::L[i], condition);
+            carry = (carry >> 52) + self[i] + addend;
+            self[i] = carry & mask;
+            i += 1;
         }
 
-        difference
+        carry
     }
 
     /// Compute `a * b`
     #[inline(always)]
     #[rustfmt::skip] // keep alignment of z[*] calculations
-    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9] {
+    pub fn mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9] {
         let mut z = [0u128; 9];
 
         z[0] = m(a[0], b[0]);
@@ -219,7 +247,7 @@
     /// Compute `a^2`
     #[inline(always)]
     #[rustfmt::skip] // keep alignment of return calculations
-    fn square_internal(a: &Scalar52) -> [u128; 9] {
+    pub fn square_internal(a: &Scalar52) -> [u128; 9] {
         let aa = [
             a[0] * 2,
             a[1] * 2,
@@ -316,8 +344,10 @@
     #[inline(never)]
     pub fn from_montgomery(&self) -> Scalar52 {
         let mut limbs = [0u128; 9];
-        for i in 0..5 {
+        let mut i = 0;
+        while i < 5 {
             limbs[i] = self[i] as u128;
+            i += 1;
         }
         Scalar52::montgomery_reduce(&limbs)
     }
diff -Naur --no-dereference a/curve25519-dalek/src/edwards.rs b/curve25519-dalek/src/edwards.rs
--- a/curve25519-dalek/src/edwards.rs
+++ b/curve25519-dalek/src/edwards.rs
@@ -1329,9 +1329,11 @@
         debug_assert!(k > 0);
         let mut r: CompletedPoint;
         let mut s = self.as_projective();
-        for _ in 0..(k - 1) {
+        let mut i = 0;
+        while i < k - 1 {
             r = s.double();
             s = r.as_projective();
+            i += 1;
         }
         // Unroll last iteration so we can go directly as_extended()
         s.double().as_extended()
diff -Naur --no-dereference a/curve25519-dalek/src/scalar.rs b/curve25519-dalek/src/scalar.rs
--- a/curve25519-dalek/src/scalar.rs
+++ b/curve25519-dalek/src/scalar.rs
@@ -1165,8 +1165,10 @@
 
         #[inline]
         fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {
-            for _ in 0..squarings {
+            let mut i = 0;
+            while i <  squarings {
                 *y = y.montgomery_square();
+                i += 1;
             }
             *y = UnpackedScalar::montgomery_mul(y, x);
         }

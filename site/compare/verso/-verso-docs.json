{"99": "<code>Html</code>",
 "98": "<code>Array (String × String)</code>",
 "97": "<code><span class=\"literal string\">\"&amp;\"</span> : String</code>",
 "96":
 "<code>Verso.Output.Html : Type</code><span class=\"sep\"></span><code class=\"docstring\">A representation of HTML, used to render Verso to the web.\n</code>",
 "95":
 "<code>Verso.Genre.Manual : Genre</code><span class=\"sep\"></span><code class=\"docstring\">A genre for writing reference manuals and other book-like documents. </code>",
 "94":
 "<code>Inhabited.default.{u} {α : Sort u} [self : Inhabited α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "93":
 "<code>Functor.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A functor in the sense used in functional programming, which means a function `f : Type u → Type v`\nhas a way of mapping a function over its contents. This `map` operator is written `&lt;$&gt;`, and\noverloaded via `Functor` instances.\n\nThis `map` function should respect identity and function composition. In other words, for all terms\n`v : f α`, it should be the case that:\n\n * `id &lt;$&gt; v = v`\n\n * For all functions `h : β → γ` and `g : α → β`, `(h ∘ g) &lt;$&gt; v = h &lt;$&gt; g &lt;$&gt; v`\n\nWhile all `Functor` instances should live up to these requirements, they are not required to _prove_\nthat they do. Proofs may be required or provided via the `LawfulFunctor` class.\n\nAssuming that instances are lawful, this definition corresponds to the category-theoretic notion of\n[functor](https://en.wikipedia.org/wiki/Functor) in the special case where the category is the\ncategory of types and functions between them.\n</code>",
 "92":
 "<code>Applicative.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An [applicative functor](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=monads-and-do) is more powerful than a `Functor`, but\nless powerful than a `Monad`.\n\nApplicative functors capture sequencing of effects with the `&lt;*&gt;` operator, overloaded as `seq`, but\nnot data-dependent effects. The results of earlier computations cannot be used to control later\neffects.\n\nApplicative functors should satisfy four laws. Instances of `Applicative` are not required to prove\nthat they satisfy these laws, which are part of the `LawfulApplicative` class.\n</code>",
 "91":
 "<code>ArgParse.ValDesc m α</code><span class=\"sep\"></span><code class=\"docstring\">A canonical way to convert a Verso argument into a given type.\n</code>",
 "90":
 "<code>Verso.ArgParse.FromArgVal.mk {α : Type} {m : Type → Type} (fromArgVal : ArgParse.ValDesc m α) : ArgParse.FromArgVal α m</code>",
 "9": "<code>Doc.Genre</code>",
 "89":
 "<code>Verso.ArgParse.FromArgVal (α : Type) (m : Type → Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A canonical way to convert a Verso argument into a given type.\n</code>",
 "88": "<code>Verso.Doc.ArgVal : Type</code>",
 "87":
 "<code>Doc.ArgVal → m α</code><span class=\"sep\"></span><code class=\"docstring\">How to transform the value into the given type. </code>",
 "86":
 "<code>Verso.ArgParse.CanMatch : Type</code><span class=\"sep\"></span><code class=\"docstring\">Documents which kinds of values a `ValDesc` might match.\n\nThese are typically constructed using `CanMatch.Ident`, `CanMatch.String`, `CanMatch.Num`, and the\n`Union CanMatch` instance.\n</code>",
 "85":
 "<code>ArgParse.CanMatch</code><span class=\"sep\"></span><code class=\"docstring\">Which of the three kinds of values can match this argument? </code>",
 "84":
 "<code>ArgParse.SigDoc</code><span class=\"sep\"></span><code class=\"docstring\">How should this argument be documented in automatically-generated signatures? </code>",
 "83":
 "<code>Verso.ArgParse.ValDesc.mk {m : Type → Type} {α : Type} (description : ArgParse.SigDoc) (signature : ArgParse.CanMatch)\n  (get : Doc.ArgVal → m α) : ArgParse.ValDesc m α</code>",
 "82": "<code>Verso.Doc.Arg : Type</code>",
 "81":
 "<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>",
 "80": "<code>ArgParse m (α → β)</code>",
 "8":
 "<code>Verso.Doc.Part (genre : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A logical division of a document.\n</code>",
 "79": "<code>Unit → ArgParse m α</code>",
 "78": "<code>ArgParse m α</code>",
 "77": "<code>m Bool</code>",
 "76":
 "<code>Lean.Syntax.Ident : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents an identifier.\n</code>",
 "75":
 "<code>Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.</code>",
 "74":
 "<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "73":
 "<code>ite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "72":
 "<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>",
 "71": "<code>Bool</code>",
 "70": "<code>optParam (Option ArgParse.SigDoc) none</code>",
 "7":
 "<code>Type</code><span class=\"sep\"></span><code class=\"docstring\">The mutable state used in the genre's traversal pass\\.\n  </code>",
 "69":
 "<code>Verso.ArgParse.ValDesc (m : Type → Type) (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A means of transforming a Verso argument value into a given type.\n</code>",
 "68": "<code>ArgParse.ValDesc m α</code>",
 "67":
 "<code>Lean.Name : Type</code><span class=\"sep\"></span><code class=\"docstring\">Hierarchical names consist of a sequence of components, each of\nwhich is either a string or numeric, that are written separated by dots (`.`).\n\nHierarchical names are used to name declarations and for creating\nunique identifiers for free variables and metavariables.\n\nYou can create hierarchical names using a backtick:\n```\n`Lean.Meta.whnf\n```\nIt is short for `.str (.str (.str .anonymous \"Lean\") \"Meta\") \"whnf\"`.\n\nYou can use double backticks to request Lean to statically check whether the name\ncorresponds to a Lean declaration in scope.\n```\n``Lean.Meta.whnf\n```\nIf the name is not in scope, Lean will report an error.\n\nThere are two ways to convert a `String` to a `Name`:\n\n 1. `Name.mkSimple` creates a name with a single string component.\n\n 2. `String.toName` first splits the string into its dot-separated\n    components, and then creates a hierarchical name.\n</code>",
 "66": "<code>Lean.Name</code>",
 "65": "<code>m α</code>",
 "64":
 "<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode scalar values.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>",
 "63": "<code>String</code>",
 "62": "<code>α</code>",
 "61": "<code>Verso.ArgParse.SigDoc : Type</code>",
 "60": "<code>Option ArgParse.SigDoc</code>",
 "6":
 "<code>Type</code><span class=\"sep\"></span><code class=\"docstring\">The reader\\-style data used in the genre's traversal pass\\. Instances of `TraversePart` and\n  `TraverseBlock` for a genre specify how this is updated while traversing parts and blocks,\n  respectively\\.\n  </code>",
 "59": "<code>Option Lean.Syntax</code>",
 "58":
 "<code>Verso.ArgParse.FromArgs.fromArgs {α : Type} {m : Type → Type} [self : ArgParse.FromArgs α m] : ArgParse m α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a sequence of arguments into a value. </code>",
 "57":
 "<code>Verso.ArgParse (m : Type → Type) : Type → Type 1</code><span class=\"sep\"></span><code class=\"docstring\">A parser for arguments in some underlying monad.\n</code>",
 "56":
 "<code>ArgParse m α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a sequence of arguments into a value. </code>",
 "55":
 "<code>Verso.ArgParse.FromArgs.mk {α : Type} {m : Type → Type} (fromArgs : ArgParse m α) : ArgParse.FromArgs α m</code>",
 "54": "<code>Type → Type</code>",
 "53": "<code>Type</code>",
 "52":
 "<code>Verso.ArgParse.FromArgs (α : Type) (m : Type → Type) : Type 1</code><span class=\"sep\"></span><code class=\"docstring\">A canonical way to convert a sequence of Verso arguments into a given type.\n</code>",
 "51": "<code>Lean.Elab.Term.TermElabM (α : Type) : Type</code>",
 "50":
 "<code>Verso.Doc.Elab.DocElabM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Text elaboration monad\\.\n\nThis monad can produce content, but it can't modify the structure of the surrounding document\\. It\ncan observe this structure, however\\.\n\nThis means it can modify the `DocElabM.State`, but it can only read from the\n`PartElabM.State`\\.\n</code>",
 "5":
 "<code>Type</code><span class=\"sep\"></span><code class=\"docstring\">Additional inline\\-level values for documents written in the genre\\.\n  </code>",
 "49":
 "<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>",
 "48":
 "<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>",
 "47":
 "<code>Doc.Block g → g.TraverseContext → g.TraverseContext</code><span class=\"sep\"></span><code class=\"docstring\">How to modify the context while traversing a given block\\.\n\nIt is also used during HTML generation\\.\n  </code>",
 "46":
 "<code>Verso.Doc.TraverseBlock.mk {g : Doc.Genre} (inBlock : Doc.Block g → g.TraverseContext → g.TraverseContext) :\n  Doc.TraverseBlock g</code>",
 "45":
 "<code>Doc.Part g → g.TraverseContext → g.TraverseContext</code><span class=\"sep\"></span><code class=\"docstring\">How to modify the context while traversing the contents of a given part\\. This is applied after\n  `part` and `genrePart` have rewritten the text, if applicable\\.\n\nIt is also used during HTML generation\\.\n  </code>",
 "44":
 "<code>Verso.Doc.TraversePart.mk {g : Doc.Genre} (inPart : Doc.Part g → g.TraverseContext → g.TraverseContext) :\n  Doc.TraversePart g</code>",
 "43":
 "<code>Verso.Doc.Genre.Inline (self : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Additional inline\\-level values for documents written in the genre\\.\n  </code>",
 "42":
 "<code>[MonadReader g.TraverseContext m] →\n  [MonadState g.TraverseState m] → g.Inline → Array (Doc.Inline g) → m (Option (Doc.Inline g))</code><span class=\"sep\"></span><code class=\"docstring\">The traversal of genre\\-specific inline values\\. If it returns `none`, then no rewrite is performed\\.\n  </code>",
 "41":
 "<code>Array.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with elements\nfrom `α`. This type has special support in the runtime.\n\nArrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed _destructively_. This results in performance comparable to mutable\narrays in imperative programming languages.\n\nAn array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\n`Array.size`, but the capacity is not observable from Lean code. `Array.emptyWithCapacity n` creates\nan array which is equal to `#[]`, but internally allocates an array of capacity `n`. When the size\nexceeds the capacity, allocation is required to grow the array.\n\nFrom the point of view of proofs, `Array α` is just a wrapper around `List α`.\n</code>",
 "40":
 "<code>Verso.Doc.Genre.Block (self : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Additional block\\-level values for documents written in the genre\\.\n  </code>",
 "4":
 "<code>Type</code><span class=\"sep\"></span><code class=\"docstring\">Additional block\\-level values for documents written in the genre\\.\n  </code>",
 "39":
 "<code>[MonadReader g.TraverseContext m] →\n  [MonadState g.TraverseState m] → g.Block → Array (Doc.Block g) → m (Option (Doc.Block g))</code><span class=\"sep\"></span><code class=\"docstring\">The traversal of genre\\-specific block values\\. If it returns `none`, then no rewrite is performed\\.\n  </code>",
 "38":
 "<code>Option.none.{u} {α : Type u} : Option α</code><span class=\"sep\"></span><code class=\"docstring\">No value. </code>",
 "37":
 "<code>[MonadReader g.TraverseContext m] → [MonadState g.TraverseState m] → Doc.Part g → m (Option g.PartMetadata)</code>",
 "36":
 "<code>[MonadReader g.TraverseContext m] →\n  [MonadState g.TraverseState m] → g.PartMetadata → Doc.Part g → m (Option (Doc.Part g))</code><span class=\"sep\"></span><code class=\"docstring\">Operations carried out after `part`, when a part has metadata\\. It allows genre\\-specific rewriting\n  of the entire part based on genre\\-specific metadata\\. This is typically used to construct a table\n  of contents or permalinks, but it can in principle arbitrarily rewrite the part\\. If it returns\n  `none`, then no rewrite is performed\\.\n  </code>",
 "35":
 "<code>[MonadReader g.TraverseContext m] → [MonadState g.TraverseState m] → Doc.Inline g → m Unit</code><span class=\"sep\"></span><code class=\"docstring\">The effects carried out before traversing an `Inline`\\.\n  </code>",
 "34":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "33":
 "<code>[MonadReader g.TraverseContext m] → [MonadState g.TraverseState m] → Doc.Block g → m Unit</code><span class=\"sep\"></span><code class=\"docstring\">The effects carried out before traversing a `Block`\\.\n  </code>",
 "32":
 "<code>Verso.Doc.Genre.PartMetadata (self : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The metadata that may be associated with each `Part` \\(e\\.g\\. author, publication date,\n  cross\\-referencing identifier\\)\\.\n  </code>",
 "31":
 "<code>Option.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Optional values, which are either `some` around a value from the underlying type or `none`.\n\n`Option` can represent nullable types or computations that might fail. In the codomain of a function\ntype, it can also represent partiality.\n</code>",
 "30":
 "<code>MonadState.{u, v} (σ : outParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">State monads provide a value of a given type (the _state_) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. `ST.Ref σ`), or in other ways.\n\nIn this class, `σ` is an `outParam`, which means that it is inferred from `m`. `MonadStateOf σ`\nprovides the same operations, but allows `σ` to influence instance synthesis.\n\nThe mutable state of a state monad is visible between multiple `do`-blocks or functions, unlike\n[local mutable state](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation-let-mut) in `do`-notation.\n</code>",
 "3":
 "<code>Type</code><span class=\"sep\"></span><code class=\"docstring\">The metadata that may be associated with each `Part` \\(e\\.g\\. author, publication date,\n  cross\\-referencing identifier\\)\\.\n  </code>",
 "299":
 "<code>Verso.Doc.Elab.BlockCommandOf.{u_1} (α : Sort u_1) : Sort (max 1 u_1)</code>",
 "298":
 "<code>Verso.Genre.Manual.licenseInfo : Elab.BlockCommandOf Unit</code><span class=\"sep\"></span><code class=\"docstring\">Displays the open-source licenses of components used to build the document.\n</code>",
 "297":
 "<code>Array (Option String × String)</code><span class=\"sep\"></span><code class=\"docstring\">The license or notice text in plain text, divided into sections with optional headers.\n</code>",
 "296":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">A link target used to credit the dependency's author </code>",
 "295":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">How is the dependency used? This can give better credit.\n\nExamples:\n* \"The display of mathematical formulae is powered by KaTeX.\"\n* \"The graphs are rendered using Chart.js.\"\n</code>",
 "294":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">Dependency name. This is used in a header, and for alphabetical sorting. </code>",
 "293":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">SPDX license identifier </code>",
 "292":
 "<code>Verso.Genre.Manual.LicenseInfo.mk (identifier dependency : String) (howUsed link : Option String)\n  (text : Array (Option String × String)) : LicenseInfo</code>",
 "291":
 "<code>Verso.Genre.Manual.InlineDescr.licenseInfo (self : InlineDescr) : List LicenseInfo</code><span class=\"sep\"></span><code class=\"docstring\">Open-source licenses used by the inline, to be collected for display in the final document.\n</code>",
 "290":
 "<code>Verso.Genre.Manual.BlockDescr.licenseInfo (self : BlockDescr) : List LicenseInfo</code><span class=\"sep\"></span><code class=\"docstring\">Open-source licenses used by the block, to be collected for display in the final document.\n</code>",
 "29":
 "<code>MonadReader.{u, v} (ρ : outParam (Type u)) (m : Type u → Type v) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Reader monads provide the ability to implicitly thread a value through a computation. The value can\nbe read, but not written. A `MonadWithReader ρ` instance additionally allows the value to be locally\noverridden for a sub-computation.\n\nIn this class, `ρ` is an `outParam`, which means that it is inferred from `m`. `MonadReaderOf ρ`\nprovides the same operations, but allows `ρ` to influence instance synthesis.\n</code>",
 "289":
 "<code>Verso.Genre.Manual.deftech : Elab.RoleExpanderOf TechArgs</code><span class=\"sep\"></span><code class=\"docstring\">Defines a technical term.\n\nInternally, these definitions are saved according to a key that is derived by stripping formatting\ninformation from the arguments in `args`, and then normalizing the resulting string by:\n\n 1. lowercasing it\n 2. replacing trailing `\"ies\"` with `\"y\"`\n 3. replacing consecutive runs of whitespace and/or hyphens with a single space\n\nCall with `(normalize := false)` to disable normalization, and `(key := some k)` to use `k` instead\nof the automatically-derived key.\n\nUses of `tech` use the same process to derive a key, and the key is matched against the `deftech` table.\n</code>",
 "288":
 "<code>Verso.Genre.Manual.tech : Elab.RoleExpanderOf TechArgs</code><span class=\"sep\"></span><code class=\"docstring\">Emits a reference to a technical term defined with `deftech.`\n\nInternally, these terms are found according to a key that is derived by stripping formatting\ninformation from the arguments in `args`, and then normalizing the resulting string by:\n\n 1. lowercasing it\n 2. replacing trailing `\"ies\"` with `\"y\"`\n 3. replacing consecutive runs of whitespace and/or hyphens with a single space\n\nCall with `(normalize := false)` to disable normalization, and `(key := some k)` to use `k` instead\nof the automatically-derived key.\n</code>",
 "287": "<code><span class=\"literal string\">\"y\"</span> : String</code>",
 "286": "<code><span class=\"literal string\">\"ies\"</span> : String</code>",
 "285": "<code>Verso.Genre.Manual.TechArgs : Type</code>",
 "284":
 "<code>Verso.Doc.Elab.RoleExpanderOf.{u_1} (α : Sort u_1) : Sort (max 1 u_1)</code>",
 "283":
 "<code>pp.deepTerms</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display deeply nested terms, replacing them with `⋯` if set to false</code>",
 "282": "<code>?m.27</code>",
 "281": "<code>sorry → sorry</code>",
 "280":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n</code>",
 "28":
 "<code>[MonadReader g.TraverseContext m] → [MonadState g.TraverseState m] → Doc.Part g → m (Option g.PartMetadata)</code><span class=\"sep\"></span><code class=\"docstring\">The effects carried out before traversing a `Part`\\.\n  </code>",
 "279":
 "<code>Verso.Genre.Manual.optionDocs : Elab.BlockCommandOf optionDocs.Args</code>",
 "278":
 "<code>Verso.Genre.Manual.tactic : Elab.DirectiveExpanderOf TacticDocsOptions</code>",
 "277":
 "<code>Verso.Genre.Manual.docstring : Elab.BlockCommandOf DocstringConfig</code>",
 "276":
 "<code>List.forA.{u, v, w} {m : Type u → Type v} [Applicative m] {α : Type w} («as» : List α) (f : α → m PUnit) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the applicative action `f` to every element in the list, in order.\n\nIf `m` is also a `Monad`, then using `List.forM` can be more efficient.\n\n`List.mapA` is a variant that collects results.\n</code>",
 "275":
 "<code>List.mapM.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} {β : Type u} (f : α → m β) («as» : List α) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the list, left-to-right, and returns the list of\nresults.\n\nThis implementation is tail recursive. `List.mapM'` is a a non-tail-recursive variant that may be\nmore convenient to reason about. `List.forM` is the variant that discards the results and\n`List.mapA` is the variant that works with `Applicative`.\n</code>",
 "274":
 "<code>PUnit.{u} : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">The canonical universe-polymorphic type with just one element.\n\nIt should be used in contexts that require a type to be universe polymorphic, thus disallowing\n`Unit`.\n</code>",
 "273": "<code>α → m PUnit</code>",
 "272": "<code>List α</code>",
 "271": "<code>Type w</code>",
 "270": "<code>Type u → Type v</code>",
 "27":
 "<code>Verso.Doc.Traverse.mk {g : Doc.Genre} {m : outParam (Type → Type)}\n  (part : [MonadReader g.TraverseContext m] → [MonadState g.TraverseState m] → Doc.Part g → m (Option g.PartMetadata))\n  (block : [MonadReader g.TraverseContext m] → [MonadState g.TraverseState m] → Doc.Block g → m Unit)\n  (inline : [MonadReader g.TraverseContext m] → [MonadState g.TraverseState m] → Doc.Inline g → m Unit)\n  (genrePart :\n    [MonadReader g.TraverseContext m] →\n      [MonadState g.TraverseState m] → g.PartMetadata → Doc.Part g → m (Option (Doc.Part g)))\n  (genreBlock :\n    [MonadReader g.TraverseContext m] →\n      [MonadState g.TraverseState m] → g.Block → Array (Doc.Block g) → m (Option (Doc.Block g)))\n  (genreInline :\n    [MonadReader g.TraverseContext m] →\n      [MonadState g.TraverseState m] → g.Inline → Array (Doc.Inline g) → m (Option (Doc.Inline g))) :\n  Doc.Traverse g m</code>",
 "269":
 "<code>Verso.Genre.Manual.paragraph : Elab.DirectiveExpanderOf Unit</code><span class=\"sep\"></span><code class=\"docstring\">Indicates that all the block-level elements contained within the directive are a single logical\nparagraph. In HTML output, they are rendered with less space between them, and LaTeX renders them as\na single paragraph (e.g. without extraneous indentation).\n</code>",
 "268":
 "<code>Verso.Genre.Manual.manualMain (text : Part Manual) (extensionImpls : ExtensionImpls := by exact extension_impls%)\n  (options : List String) (config : Config := { }.addSearch.addKaTeX) (extraSteps : List ExtraStep := []) : IO UInt32</code>",
 "267":
 "<code>Verso.Genre.Manual.InlineToTeX (genre : Genre) (m : Type → Type) : Type</code>",
 "266":
 "<code>Option (InlineToTeX Manual (ReaderT ExtensionImpls IO))</code><span class=\"sep\"></span><code class=\"docstring\">How to generate TeX. If `none`, generating TeX from a document that contains this inline will fail. </code>",
 "265":
 "<code>Verso.Doc.Inline (genre : Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Inline content that is part of the text flow.\n</code>",
 "264":
 "<code>InternalId → Lean.Json → Array (Doc.Inline Manual) → Except String (Array (String × Output.Html))</code><span class=\"sep\"></span><code class=\"docstring\">Should this inline be an entry in the page-local ToC? If so, how should it be represented?\n\nEntries should be returned as a preference-ordered array of representations. Each representation\nconsists of a string and some HTML; the string should represent the HTML's content if all\nformatting were stripped. Items are compared for string equality, with later suggestions used in\ncase of overlap, but the HTML is what's displayed.\n\nThe empty array means that the inline should not be included.\n</code>",
 "263":
 "<code>List LicenseInfo</code><span class=\"sep\"></span><code class=\"docstring\">Open-source licenses used by the inline, to be collected for display in the final document.\n</code>",
 "262":
 "<code>Verso.Genre.Manual.InlineToHtml (genre : Genre) (m : Type → Type) : Type</code>",
 "261":
 "<code>Option (InlineToHtml Manual (ReaderT ExtensionImpls IO))</code><span class=\"sep\"></span><code class=\"docstring\">How to generate HTML. If `none`, generating HTML from a document that contains this inline will fail.\n</code>",
 "260":
 "<code>Verso.Genre.Manual.InlineTraversal (genre : Genre) : Type</code>",
 "26":
 "<code>Verso.Genre.Manual.Inline : Type</code><span class=\"sep\"></span><code class=\"docstring\">A custom inline. The `name` field should correspond to an entry in the block descriptions table.\n</code>",
 "259":
 "<code>InlineTraversal Manual</code><span class=\"sep\"></span><code class=\"docstring\">Given the contents of the `data` field of the corresponding `Manual.Inline` and the contained\ninline elements, carry out the traversal pass.\n\nIn addition to updating the cross-reference state through the available monadic effects, a\ntraversal may additionally replace the element with another one. This can be used to e.g. emit\na cross-reference once the target becomes available in the state. To replace the element,\nreturn `some`. To leave it as is, return `none`.\n</code>",
 "258":
 "<code>Verso.Genre.Manual.InlineDescr.mk (init : TraverseState → TraverseState) (traverse : InlineTraversal Manual)\n  (toHtml : Option (InlineToHtml Manual (ReaderT ExtensionImpls IO))) (extraJs : List String)\n  (extraJsFiles : List JsFile) (extraCss : List String) (extraCssFiles : List (String × String))\n  (licenseInfo : List LicenseInfo)\n  (localContentItem : InternalId → Lean.Json → Array (Doc.Inline Manual) → Except String (Array (String × Output.Html)))\n  (toTeX : Option (InlineToTeX Manual (ReaderT ExtensionImpls IO))) (usePackages preamble : List String) : InlineDescr</code>",
 "257":
 "<code>List String</code><span class=\"sep\"></span><code class=\"docstring\">Required items in the TeX preamble </code>",
 "256":
 "<code>List String</code><span class=\"sep\"></span><code class=\"docstring\">Required TeX `\\usepackage` lines </code>",
 "255":
 "<code>Verso.Genre.Manual.BlockToTeX (genre : Genre) (m : Type → Type) : Type</code>",
 "254":
 "<code>Option (BlockToTeX Manual (ReaderT ExtensionImpls IO))</code><span class=\"sep\"></span><code class=\"docstring\">How to generate TeX. If `none`, generating TeX from a document that contains this block will fail. </code>",
 "253":
 "<code>Except.{u, v} (ε : Type u) (α : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">`Except ε α` is a type which represents either an error of type `ε` or a successful result with a\nvalue of type `α`.\n\n`Except ε : Type u → Type v` is a `Monad` that represents computations that may throw exceptions:\nthe `pure` operation is `Except.ok` and the `bind` operation returns the first encountered\n`Except.error`.\n</code>",
 "252":
 "<code>Verso.Doc.Block (genre : Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Block-level content in a document.\n</code>",
 "251":
 "<code>InternalId → Lean.Json → Array (Doc.Block Manual) → Except String (Array (String × Output.Html))</code><span class=\"sep\"></span><code class=\"docstring\">Should this block be an entry in the page-local ToC? If so, how should it be represented?\n\nEntries should be returned as a preference-ordered array of representations. Each representation\nconsists of a string and some HTML; the string should represent the HTML's content if all\nformatting were stripped. Items are compared for string equality, with later suggestions used in\ncase of overlap, but the HTML is what's displayed. Exceptions are logged as errors during HTML\ngeneration.\n\nThe empty array means that the block should not be included.\n</code>",
 "250":
 "<code>Verso.Genre.Manual.LicenseInfo : Type</code><span class=\"sep\"></span><code class=\"docstring\">A description of an open-source license used by a frontend component that's included in\ngenerated HTML. This is used to create an attribution page.\n</code>",
 "25":
 "<code>Verso.Genre.Manual.Block : Type</code><span class=\"sep\"></span><code class=\"docstring\">A custom block. The `name` field should correspond to an entry in the block descriptions table.\n</code>",
 "249":
 "<code>List LicenseInfo</code><span class=\"sep\"></span><code class=\"docstring\">Open-source licenses used by the block, to be collected for display in the final document.\n</code>",
 "248":
 "<code>List (String × String)</code><span class=\"sep\"></span><code class=\"docstring\">Extra CSS to save to the static files directory and load in the generated HTMl's `&lt;head&gt;`\n</code>",
 "247":
 "<code>List String</code><span class=\"sep\"></span><code class=\"docstring\">Extra CSS to add to a `&lt;style&gt;` tag in the generated HTML's `&lt;head&gt;`\n</code>",
 "246":
 "<code>Verso.Genre.Manual.JsFile : Type</code><span class=\"sep\"></span><code class=\"docstring\">An extra JS file to be emitted and added to the page </code>",
 "245":
 "<code>List JsFile</code><span class=\"sep\"></span><code class=\"docstring\">Extra JavaScript to save to the static files directory and load in the generated HTMl's `&lt;head&gt;`\n</code>",
 "244":
 "<code>List String</code><span class=\"sep\"></span><code class=\"docstring\">Extra JavaScript to add to a `&lt;script&gt;` tag in the generated HTML's `&lt;head&gt;`\n</code>",
 "243": "<code>Verso.Genre.Manual.ExtensionImpls : Type</code>",
 "242":
 "<code>ReaderT.{u, v} (ρ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds the ability to access a read-only value of type `ρ` to a monad. The value can be locally\noverridden by `withReader`, but it cannot be mutated.\n\nActions in the resulting monad are functions that take the local value as a parameter, returning\nordinary actions in `m`.\n</code>",
 "241":
 "<code>Verso.Genre.Manual.BlockToHtml (genre : Genre) (m : Type → Type) : Type</code>",
 "240":
 "<code>Option (BlockToHtml Manual (ReaderT ExtensionImpls IO))</code><span class=\"sep\"></span><code class=\"docstring\">How to generate HTML. If `none`, generating HTML from a document that contains this block will fail.\n</code>",
 "24":
 "<code>MonadWithReader.withReader.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v} [self : MonadWithReader ρ m]\n  {α : Type u} (f : ρ → ρ) (x : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Locally modifies the reader monad's value while running an action.\n\nDuring the inner action `x`, reading the value returns `f` applied to the original value. After\ncontrol returns from `x`, the reader monad's value is restored.\n</code>",
 "239": "<code>Verso.Genre.Manual.BlockTraversal (genre : Genre) : Type</code>",
 "238":
 "<code>BlockTraversal Manual</code><span class=\"sep\"></span><code class=\"docstring\">How the traversal phase should process this block </code>",
 "237": "<code>Verso.Genre.Manual.TraverseState : Type</code>",
 "236":
 "<code>TraverseState → TraverseState</code><span class=\"sep\"></span><code class=\"docstring\">All registered initializers are called in the state prior to the first traversal. </code>",
 "235":
 "<code>Verso.Genre.Manual.BlockDescr.mk (init : TraverseState → TraverseState) (traverse : BlockTraversal Manual)\n  (toHtml : Option (BlockToHtml Manual (ReaderT ExtensionImpls IO))) (extraJs : List String)\n  (extraJsFiles : List JsFile) (extraCss : List String) (extraCssFiles : List (String × String))\n  (licenseInfo : List LicenseInfo)\n  (localContentItem : InternalId → Lean.Json → Array (Doc.Block Manual) → Except String (Array (String × Output.Html)))\n  (toTeX : Option (BlockToTeX Manual (ReaderT ExtensionImpls IO))) (usePackages preamble : List String) : BlockDescr</code>",
 "234":
 "<code>Verso.Genre.Manual.Inline.name (self : Manual.Inline) : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">A unique name that identifies the inline. </code>",
 "233":
 "<code>Verso.Genre.Manual.Block.name (self : Manual.Block) : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">A unique name that identifies the block. </code>",
 "232":
 "<code>Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">A unique name that identifies the inline. </code>",
 "231":
 "<code>Verso.Genre.Manual.Inline.mk (name : Lean.Name := by exact decl_name%) (id : Option InternalId) (data : Lean.Json) :\n  Manual.Inline</code>",
 "230": "<code>Lean.NameMap (α : Type) : Type</code>",
 "23":
 "<code>inline.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">`inline (f x)` is an indication to the compiler to inline the definition of `f`\nat the application site itself (by comparison to the `@[inline]` attribute,\nwhich applies to all applications of the function).\n</code>",
 "229":
 "<code>Lean.NameMap String</code><span class=\"sep\"></span><code class=\"docstring\">A registry for properties that can be used to create ad-hoc protocols for coordination between\nblock elements in extensions.\n</code>",
 "228":
 "<code>Lean.Json</code><span class=\"sep\"></span><code class=\"docstring\">Data saved by elaboration, potentially updated during traversal, and used to render output. This\nis the primary means of communicating information about a block between phases.\n</code>",
 "227":
 "<code>Option InternalId</code><span class=\"sep\"></span><code class=\"docstring\">A unique ID, assigned during traversal. </code>",
 "226":
 "<code>Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">A unique name that identifies the block. </code>",
 "225":
 "<code>Verso.Genre.Manual.Block.mk (name : Lean.Name := by exact decl_name%) (id : Option InternalId) (data : Lean.Json)\n  (properties : Lean.NameMap String) : Manual.Block</code>",
 "224":
 "<code>Verso.Genre.Manual.InlineLean.name : Elab.RoleExpanderOf NameConfig</code>",
 "223":
 "<code>Verso.Genre.Manual.HtmlSplitMode : Type</code><span class=\"sep\"></span><code class=\"docstring\">When rendering multi-page HTML, should splitting pages follow the depth setting? </code>",
 "222":
 "<code>HtmlSplitMode</code><span class=\"sep\"></span><code class=\"docstring\">How should this document be split when rendering multi-page HTML output? </code>",
 "221":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `true`, this part will display a list of subparts that are separate HTML pages. </code>",
 "220": "<code>Verso.Genre.Manual.Numbering : Type</code>",
 "22":
 "<code>outParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, Lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n</code>",
 "219":
 "<code>Option Numbering</code><span class=\"sep\"></span><code class=\"docstring\">Which number has been assigned? This field is set during traversal. </code>",
 "218":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `true`, the part is only rendered in draft mode. </code>",
 "217":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Should this section be numbered? If `false`, then it's like `\\section*` in LaTeX </code>",
 "216":
 "<code>Verso.Multi.InternalId : Type</code><span class=\"sep\"></span><code class=\"docstring\">An internal identifier assigned to a part during traversal. Users don't get to have influence\nover these IDs, so they can be used to ensure uniqueness of tags.\n\nEven though the constructor is private, there is a JSON serialization that can be used to undermine\nthe uniqueness of internal IDs. Please don't do that - your program may break unpredictably.\n</code>",
 "215":
 "<code>Option InternalId</code><span class=\"sep\"></span><code class=\"docstring\">The internal unique ID, which is automatically assigned during traversal. </code>",
 "214":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">If this part ends up as the root of a file, use this name for it </code>",
 "213":
 "<code>Verso.Genre.Manual.Tag : Type</code><span class=\"sep\"></span><code class=\"docstring\">Tags are used to refer to parts through tables of contents, cross-references, and the like.\n\nDuring the traverse pass, the following steps occur:\n 1. user-provided tags are ensured to be globally unique, and saved as xref targets\n 2. internal tags are heuristically assigned to parts based on their section names\n 3. internal tags are converted to unique external tags, but not provided for user-written xrefs\n    (needed for automatic linking, e.g. in a table of contents)\n\nNote that internal invariants about uniqueness of names can be violated by editing the JSON\nserialization. This may lead to unexpected results.\n</code>",
 "212":
 "<code>Option Tag</code><span class=\"sep\"></span><code class=\"docstring\">The main tag for the part, used for cross-references. </code>",
 "211":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">The publication date </code>",
 "210":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">An extra note to show after the author list </code>",
 "21": "<code>outParam (Type → Type)</code>",
 "209":
 "<code>List String</code><span class=\"sep\"></span><code class=\"docstring\">The book's authors </code>",
 "208":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">A shorter title to be shown in breadcrumbs for search results. Should typically be at least as\nshort as `shortTitle`.\n</code>",
 "207":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">A shorter title to be shown in titlebars and tables of contents.\n</code>",
 "206":
 "<code>Verso.Genre.Manual.PartMetadata.mk (shortTitle shortContextTitle : Option String) (authors : List String)\n  (authorshipNote date : Option String) (tag : Option Tag) (file : Option String) (id : Option InternalId)\n  (number draft : Bool) (assignedNumber : Option Numbering) (htmlToc : Bool) (htmlSplit : HtmlSplitMode) : PartMetadata</code>",
 "205":
 "<code>Verso.Genre.Blog.TemplateM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that provides template instantiation via dynamically-typed parameters.\n</code>",
 "204":
 "<code>TypeName.{u} (α : Type u) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Dynamic type name information.\nTypes with an instance of `TypeName` can be stored in an `Dynamic`.\nThe type class contains the declaration name of the type,\nwhich must not have any universe parameters\nand be of type `Sort ..` (i.e., monomorphic).\n\nThe preferred way to declare instances of this type is using the derive\nhandler, which will internally use the unsafe `TypeName.mk` function.\n\nMorally, this is the same as:\n```lean\nclass TypeName (α : Type) where unsafe mk ::\n  typeName : Name\n```\n</code>",
 "203": "<code>Verso.Genre.Blog.Template.Override : Type</code>",
 "202":
 "<code>Array String → Option Blog.Template.Override</code><span class=\"sep\"></span><code class=\"docstring\">Customize the rendering of a given path by replacing the\ntemplate and providing additional parameters\n</code>",
 "201":
 "<code><span class=\"literal string\">\"category\"</span> : String</code>",
 "200":
 "<code>Blog.Template</code><span class=\"sep\"></span><code class=\"docstring\">The template used to display a category at the top of a category's post list. It receives one\nparameter, `\"category\"`, which contains a `Post.Category`.\n</code>",
 "20":
 "<code>Verso.Doc.TraverseBlock (g : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Specifies how to modify the context while traversing the contents of a given block\\.\n</code>",
 "2":
 "<code>Verso.Doc.Genre.mk (PartMetadata Block Inline TraverseContext TraverseState : Type) : Doc.Genre</code>",
 "199":
 "<code><span class=\"literal string\">\"summary\"</span> : String</code>",
 "198": "<code><span class=\"literal string\">\"post\"</span> : String</code>",
 "197":
 "<code>Blog.Template</code><span class=\"sep\"></span><code class=\"docstring\">The template used to summarize a blog post in a post archive. It receives the parameters `\"post\"`,\nwhich contains the post, and `\"summary\"`, which contains the HTML summary to display.\n</code>",
 "196":
 "<code><span class=\"literal string\">\"Post.PartMetadata\"</span> : String</code>",
 "195":
 "<code><span class=\"literal string\">\"metadata\"</span> : String</code>",
 "194":
 "<code>Blog.Template</code><span class=\"sep\"></span><code class=\"docstring\">Blog posts are rendered using `pageTemplate`, with the result being passed in the `\"content\"`\nparameter to `primaryTemplate`. This template should use the `\"title\"` and `\"content\"` parameters\nto construct the contents of the post. Additionally, the `\"metadata\"` template of type\n`\"Post.PartMetadata\"` may be present; if so, it can be used to render the author, date, and\ncategories of the post.\n</code>",
 "193": "<code><span class=\"literal string\">\"title\"</span> : String</code>",
 "192": "<code>Blog.Template</code>",
 "191":
 "<code>Blog.Template</code><span class=\"sep\"></span><code class=\"docstring\">Pages are rendered using `pageTemplate`, with the result being passed in the `\"content\"` parameter\nto `primaryTemplate`. This template should use the `\"title\"` and `\"content\"` parameters to\nconstruct the contents of the page.\n</code>",
 "190":
 "<code><span class=\"literal string\">\"content\"</span> : String</code>",
 "19":
 "<code>Verso.Doc.TraversePart (g : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Specifies how to modify the context while traversing the contents of a given part\\.\n</code>",
 "189":
 "<code>Verso.Genre.Blog.Post.Categories : Type</code><span class=\"sep\"></span><code class=\"docstring\">Wrapper around `Array Category` that allows a `TypeName` instance and provides link targets </code>",
 "188":
 "<code><span class=\"literal string\">\"categories\"</span> : String</code>",
 "187": "<code><span class=\"literal string\">\"posts\"</span> : String</code>",
 "186":
 "<code>Verso.Genre.Blog.Template : Type</code><span class=\"sep\"></span><code class=\"docstring\">A procedure for producing HTML from parameters. An abbreviation for `TemplateM Html`\n</code>",
 "185":
 "<code>Blog.Template</code><span class=\"sep\"></span><code class=\"docstring\">The template used to render every page. It should construct an HTML value for the entire page,\nincluding the `&lt;html&gt;` element.\n\nIn the `&lt;head&gt;` element, it should invoke `builtinHeader` to ensure that the required dependencies\nare present and that Verso-specific initialization is performed.\n\nIn the body, it should check whether the parameter `\"posts\"` of type `Html` is present. If so, the\npage being rendered is a blog index, so it should place the parameter's value as a list of posts.\nIf `\"categories\"` of type `Post.Categories` is present, it should render the contents as a\ncategory list.\n\nThe parameter `\"content\"` of type `Html` contains the content of the page. It should be placed\naccordingly in the result.\n</code>",
 "184":
 "<code>Verso.Genre.Blog.Theme.mk\n  (primaryTemplate pageTemplate postTemplate archiveEntryTemplate categoryTemplate : Blog.Template)\n  (adHocTemplates : Array String → Option Blog.Template.Override) : Blog.Theme</code>",
 "183":
 "<code>System.FilePath : Type</code><span class=\"sep\"></span><code class=\"docstring\">A path on the file system.\n\nPaths consist of a sequence of directories followed by the name of a file or directory. They are\ndelimited by a platform-dependent separator character (see `System.FilePath.pathSeparator`).\n</code>",
 "182": "<code>System.FilePath</code>",
 "181": "<code>Verso.Genre.Blog.BlogPost : Type</code>",
 "180": "<code>Array Blog.BlogPost</code>",
 "18":
 "<code>Verso.Doc.Traverse (g : Doc.Genre) (m : outParam (Type → Type)) : Type 1</code><span class=\"sep\"></span><code class=\"docstring\">Genre\\-specific traversal\\.\n\nThe traversal pass is where cross\\-references are resolved\\. The traversal pass repeatedly applies a\ngenre\\-specific stateful computation until a fixed point is reached, both with respect to the state\nand the document\\. Traversal may update the state or rewrite parts of the document\\.\n\nThe methods `part`, `block`, and `inline` provide effects to be carried out before traversing the\ngiven level of the AST, and `part` allows the part's metadata to be updated\\.\n\n`genrePart` is carried out after `part`\\. It allows genre\\-specific rewriting of the entire part based\non genre\\-specific metadata\\. This is typically used to construct a table of contents or permalinks,\nbut it can in principle arbitrarily rewrite the part\\. `inPart` is used to locally transform the\ngenre's traversal context along the lines of `withReader`, and can be used to keep track of e\\.g\\. the\ncurrent position in the table of contents\\.\n\n`genreBlock` and `genreInline` are invoked when traversal encounters `Block.other` and\n`Inline.other`\\. It may rewrite them, or have state effects\\.</code>",
 "179":
 "<code>Verso.Genre.Blog.Dir : Type</code><span class=\"sep\"></span><code class=\"docstring\">A directory within the layout of a site.\n</code>",
 "178": "<code>Array Blog.Dir</code>",
 "177":
 "<code>Verso.Doc.Part (genre : Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A logical division of a document.\n</code>",
 "176": "<code>Part Page</code>",
 "175":
 "<code>UInt32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Unsigned 32-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 32-bit value\nrather than wrapping a `BitVec 32`.\n</code>",
 "174":
 "<code>IO : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that supports arbitrary side effects and throwing exceptions of type `IO.Error`.\n</code>",
 "173":
 "<code>Verso.Output.Html.doctype : String</code><span class=\"sep\"></span><code class=\"docstring\">The default `DOCTYPE` for HTML5. </code>",
 "172": "<code>optParam String Output.Html.doctype</code>",
 "171": "<code>Verso.Genre.Blog.Components : Type</code>",
 "170": "<code>autoParam Blog.Components _auto✝</code>",
 "17":
 "<code>Verso.Doc.Genre.TraverseContext (self : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The reader\\-style data used in the genre's traversal pass\\. Instances of `TraversePart` and\n  `TraverseBlock` for a genre specify how this is updated while traversing parts and blocks,\n  respectively\\.\n  </code>",
 "169": "<code>List String</code>",
 "168":
 "<code>Verso.Code.LinkTargets.mk {Ctxt : Type} (var : Lean.FVarId → Option Ctxt → Array Code.CodeLink)\n  (sort : Lean.Level → Option Ctxt → Array Code.CodeLink)\n  (const option keyword definition moduleName : Lean.Name → Option Ctxt → Array Code.CodeLink) : Code.LinkTargets Ctxt</code>",
 "167": "<code>Verso.Genre.Blog.TraverseContext : Type</code>",
 "166":
 "<code>Verso.Code.LinkTargets (Ctxt : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Instructions for computing link targets for various code elements.\n\nEach kind of link may have multiple destinations. The first is the default link, while the remainder\nare considered alternates.\n</code>",
 "165": "<code>optParam (Code.LinkTargets Blog.TraverseContext) { }</code>",
 "164":
 "<code>Verso.Genre.Blog.Site : Type</code><span class=\"sep\"></span><code class=\"docstring\">A specification of the layout of an entire site </code>",
 "163": "<code>Blog.Site</code>",
 "162":
 "<code>Verso.Genre.Blog.Theme : Type</code><span class=\"sep\"></span><code class=\"docstring\">A specification of how to render a site.\n</code>",
 "161": "<code>Blog.Theme</code>",
 "160":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `true`, the post is not rendered by default </code>",
 "16":
 "<code>Verso.Doc.Genre.TraverseState (self : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The mutable state used in the genre's traversal pass\\.\n  </code>",
 "159":
 "<code>Verso.Genre.Blog.Post.Category : Type</code><span class=\"sep\"></span><code class=\"docstring\">A category of blog posts.\n</code>",
 "158":
 "<code>List Post.Category</code><span class=\"sep\"></span><code class=\"docstring\">The categories in which to include the post </code>",
 "157":
 "<code>List String</code><span class=\"sep\"></span><code class=\"docstring\">The authors of the post </code>",
 "156": "<code>Verso.Genre.Blog.Date : Type</code>",
 "155":
 "<code>Blog.Date</code><span class=\"sep\"></span><code class=\"docstring\">The post's date. By default, this is used in the URL as well as included in the content. </code>",
 "154":
 "<code>Verso.Genre.Blog.Post.Meta.mk (date : Blog.Date) (authors : List String) (categories : List Post.Category)\n  (draft : Bool) (htmlId : Option String) : Post.Meta</code>",
 "153":
 "<code>Option String</code><span class=\"sep\"></span><code class=\"docstring\">The HTML ID to assign to the header </code>",
 "152":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether to hide this page/part from navigation entries </code>",
 "151":
 "<code>Verso.Genre.Blog.Page.Meta.mk (showInNav : Bool) (htmlId : Option String) : Page.Meta</code>",
 "150": "<code>?m.1</code>",
 "15":
 "<code>Verso.Doc.Inline.other {genre : Doc.Genre} (container : genre.Inline) (content : Array (Doc.Inline genre)) :\n  Doc.Inline genre</code><span class=\"sep\"></span><code class=\"docstring\">A genre-specific inline element. `container` specifies what kind of element it is, and `content`\nspecifies the contained elements.\n</code>",
 "149":
 "<code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Some value of type `α`. </code>",
 "148": "<code>Option String</code>",
 "147":
 "<code>Verso.Genre.Blog.InlineExt : Type</code><span class=\"sep\"></span><code class=\"docstring\">The additional inline elements available in pages and posts.\n</code>",
 "146": "<code>Option Lean.Name</code>",
 "145": "<code>Nat</code>",
 "144": "<code>Lean.Json : Type</code>",
 "143": "<code>Lean.Json</code>",
 "142": "<code>Output.Html</code>",
 "141": "<code>Verso.Genre.Blog.LexedText : Type</code>",
 "140": "<code>Blog.LexedText</code>",
 "14":
 "<code>Verso.Doc.Block.other {genre : Doc.Genre} (container : genre.Block) (content : Array (Doc.Block genre)) :\n  Doc.Block genre</code><span class=\"sep\"></span><code class=\"docstring\">A genre-specific block. `container` specifies what kind of block it is, while `content` specifies\nthe content within the block.\n</code>",
 "139": "<code>List Lean.Name</code>",
 "138": "<code>SubVerso.Highlighting.Highlighted.Message : Type</code>",
 "137": "<code>SubVerso.Highlighting.Highlighted.Message</code>",
 "136":
 "<code>Verso.Genre.Blog.BlockExt : Type</code><span class=\"sep\"></span><code class=\"docstring\">The additional blocks available in pages and posts.\n</code>",
 "135": "<code>SubVerso.Highlighting.Highlighted : Type</code>",
 "134": "<code>SubVerso.Highlighting.Highlighted</code>",
 "133": "<code>Verso.Genre.Blog.CodeOpts : Type</code>",
 "132": "<code>Blog.CodeOpts</code>",
 "131":
 "<code>Verso.Genre.Blog.Post : Genre</code><span class=\"sep\"></span><code class=\"docstring\">A blog post.\n</code>",
 "130":
 "<code>Verso.Genre.Blog.Page : Genre</code><span class=\"sep\"></span><code class=\"docstring\">An ordinary web page that is not a blog post.\n</code>",
 "13":
 "<code>Verso.Doc.Part.metadata {genre : Doc.Genre} : Doc.Part genre → Option genre.PartMetadata</code><span class=\"sep\"></span><code class=\"docstring\">Genre-specific metadata </code>",
 "129":
 "<code>Verso.Output.TeX.asString (doc : TeX) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a TeX document to a string to be processed by LaTeX </code>",
 "128": "<code><span class=\"literal string\">\"\\n\"</span> : String</code>",
 "127": "<code><span class=\"literal string\">\" \"</span> : String</code>",
 "126": "<code>List TeX</code>",
 "125": "<code>mkList (xs : List TeX) : TeX</code>",
 "124": "<code>TeX</code>",
 "123": "<code>Array TeX</code>",
 "122":
 "<code>Verso.Output.TeX : Type</code><span class=\"sep\"></span><code class=\"docstring\">TeX output\n</code>",
 "121":
 "<code>IO.println.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it with a trailing newline to\nthe current standard output (as determined by `IO.getStdout`).\n</code>",
 "120":
 "<code>Verso.Output.Html.asString (html : Html) (indent : Nat := 0) (breakLines : Bool := true) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts HTML into a string that's suitable for sending to browsers, but is also readable.\n</code>",
 "12":
 "<code>Verso.Doc.Inline (genre : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Inline content that is part of the text flow.\n</code>",
 "119": "<code><span class=\"literal string\">\"C\"</span> : String</code>",
 "118": "<code><span class=\"literal string\">\"B\"</span> : String</code>",
 "117": "<code><span class=\"literal string\">\"A\"</span> : String</code>",
 "116":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "115":
 "<code>List.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (l : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list, returning the resulting list of values.\n\n`O(|l|)`.\n\nExamples:\n* `[a, b, c].map f = [f a, f b, f c]`\n* `[].map Nat.succ = []`\n* `[\"one\", \"two\", \"three\"].map (·.length) = [3, 3, 5]`\n* `[\"one\", \"two\", \"three\"].map (·.reverse) = [\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "114": "<code>mkList (xs : List Html) : Html</code>",
 "113":
 "<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ =&gt; a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>",
 "112": "<code>optParam Bool true</code>",
 "111":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "110": "<code>optParam Nat 0</code>",
 "11":
 "<code>Verso.Doc.Block (genre : Doc.Genre) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Block-level content in a document.\n</code>",
 "109":
 "<code>Std.Format : Type</code><span class=\"sep\"></span><code class=\"docstring\">A representation of a set of strings, in which the placement of newlines and indentation differ.\n\nGiven a specific line width, specified in columns, the string that uses the fewest lines can be\nselected.\n\nThe pretty-printing algorithm is based on Wadler's paper\n[_A Prettier Printer_](https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf).\n</code>",
 "108":
 "<code>optParam (Array Html → m (Option Html)) fun x =&gt; pure none</code>",
 "107":
 "<code>optParam (String → Array (String × String) → Html → m (Option Html)) fun x x_1 x_2 =&gt; pure none</code>",
 "106":
 "<code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "105":
 "<code>optParam (Bool → String → m (Option Html)) fun x x_1 =&gt; pure none</code>",
 "104":
 "<code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.\n\nThe `Monad` API may be used directly. However, it is most commonly accessed through\n[`do`-notation](https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation).\n\nMost `Monad` instances provide implementations of `pure` and `bind`, and use default implementations\nfor the other methods inherited from `Applicative`. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of `LawfulMonad` expresses that a given\nmonad's operations are lawful.\n</code>",
 "103": "<code>Type → Type u_1</code>",
 "102": "<code>List Html</code>",
 "101":
 "<code>Verso.Output.Html.seq (contents : Array Html) : Html</code><span class=\"sep\"></span><code class=\"docstring\">A sequence of HTML values.\n</code>",
 "100": "<code>Array Html</code>",
 "10":
 "<code>Verso.Doc.Genre : Type 1</code><span class=\"sep\"></span><code class=\"docstring\">A genre is a kind of document that can be written with Verso\\.\n\nA genre is primarily defined by its extensions to the Verso framework, provided in this type\\.\nAdditionally, each genre should provide a `main` function that is responsible for the traversal pass\nand for generating output\\.\n</code>",
 "1":
 "<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>",
 "0":
 "<code>Lean.Syntax : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lean syntax trees.\n\nSyntax trees are used pervasively throughout Lean: they are produced by the parser, transformed by\nthe macro expander, and elaborated. They are also produced by the delaborator and presented to\nusers.\n</code>"}
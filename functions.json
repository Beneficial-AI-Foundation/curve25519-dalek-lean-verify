{"functions":
 [{"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Identity for ProjectivePoint {\n    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}",
   "lines": "L230-L238",
   "lean_name": "curve25519_dalek.IdentityCurveModelsProjectivePoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.IdentityCurveModelsProjectivePoint.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    spec identity (fun q =>\n    q.X = ZERO ∧ q.Y = ONE ∧ q.Z = ONE) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectivePoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.IdentityProjectivePoint.identity`**:\n- No panic (always returns successfully)\n- The resulting ProjectivePoint is the identity element with coordinates (X=0, Y=1, Z=1)\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::identity",
   "lines": "L231-L237",
   "lean_name": "curve25519_dalek.IdentityCurveModelsProjectivePoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl Identity for ProjectivePoint {\n    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::ProjectivePoint}",
   "lines": "L296-L303",
   "lean_name": "curve25519_dalek.IdentityMontgomeryProjectivePoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.IdentityMontgomeryProjectivePoint.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    spec identity (fun q =>\n    q.U = ONE ∧ q.W = ZERO) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/ProjectivePoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.IdentityProjectivePoint.identity`**:\n- No panic (always returns successfully)\n- The resulting ProjectivePoint is the identity element with coordinates (U=1, W=0)\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::ProjectivePoint}::identity",
   "lines": "L297-L302",
   "lean_name": "curve25519_dalek.IdentityMontgomeryProjectivePoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Neg for &AffineNielsPoint {\n    type Output = AffineNielsPoint;\n\n    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for &0 (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint)}",
   "lines": "L522-L532",
   "lean_name":
   "curve25519_dalek.Shared0AffineNielsPoint.Insts.CoreOpsArithNegAffineNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0AffineNielsPoint.Insts.CoreOpsArithNegAffineNielsPoint.neg"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem neg_spec\n    (self : backend.serial.curve_models.AffineNielsPoint)\n    (self_bound : ∀ i < 5, ↑self.xy2d[i]!.val < 2 ^ 54) :\n    neg self ⦃ result =>\n    result.y_plus_x = self.y_minus_x ∧\n    result.y_minus_x = self.y_plus_x ∧\n    (Field51_as_Nat self.xy2d + Field51_as_Nat result.xy2d) % p = 0 ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Neg.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for &0 (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint)}::neg",
   "lines": "L525-L531",
   "lean_name":
   "curve25519_dalek.Shared0AffineNielsPoint.Insts.CoreOpsArithNegAffineNielsPoint.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl<'a> Add<&'a AffineNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn add(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L456-L474",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAAffineNielsPointCompletedPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAAffineNielsPointCompletedPoint.add"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec\n  (self : edwards.EdwardsPoint)\n  (other : backend.serial.curve_models.AffineNielsPoint)\n  (h_selfX_bounds : ∀ i, i < 5 → (self.X[i]!).val < 2 ^ 53)\n  (h_selfY_bounds : ∀ i, i < 5 → (self.Y[i]!).val < 2 ^ 53)\n  (h_selfZ_bounds : ∀ i, i < 5 → (self.Z[i]!).val < 2 ^ 53)\n  (h_selfT_bounds : ∀ i, i < 5 → (self.T[i]!).val < 2 ^ 53)\n  (h_otherYpX_bounds : ∀ i, i < 5 → (other.y_plus_x[i]!).val < 2 ^ 53)\n  (h_otherYmX_bounds : ∀ i, i < 5 → (other.y_minus_x[i]!).val < 2 ^ 53)\n  (h_otherXY2d_bounds : ∀ i, i < 5 → (other.xy2d[i]!).val < 2 ^ 53) :\nShared0EdwardsPoint.Insts.CoreOpsArithAddSharedAAffineNielsPointCompletedPoint.add self other ⦃ c =>\nlet X := Field51_as_Nat self.X\nlet Y := Field51_as_Nat self.Y\nlet Z := Field51_as_Nat self.Z\nlet T := Field51_as_Nat self.T\nlet YpX := Field51_as_Nat other.y_plus_x\nlet YmX := Field51_as_Nat other.y_minus_x\nlet XY2D := Field51_as_Nat other.xy2d\nlet X' := Field51_as_Nat c.X\nlet Y' := Field51_as_Nat c.Y\nlet Z' := Field51_as_Nat c.Z\nlet T' := Field51_as_Nat c.T\n(X' + Y * YmX) % p = (((Y + X) * YpX) + X * YmX) % p ∧\n(Y' + X * YmX) % p = (((Y + X) * YpX) + Y  * YmX) % p ∧\nZ' % p = ((2 * Z) + (T * XY2D)) % p ∧\n(T' + (T * XY2D)) % p = (2 * Z) % p ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Add.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn add(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::add",
   "lines": "L459-L473",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAAffineNielsPointCompletedPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl<'a> Add<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L754-L759",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::add",
   "lines": "L756-L758",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAEdwardsPointEdwardsPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective_niels",
    "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAProjectiveNielsPointCompletedPoint.add",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl<'a> Add<&'a ProjectiveNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn add(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.Y_plus_X;\n        let MM = &Y_minus_X * &other.Y_minus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &ZZ2 + &TT2d,\n            T: &ZZ2 - &TT2d,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L412-L431",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAProjectiveNielsPointCompletedPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAProjectiveNielsPointCompletedPoint.add"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec\n    (self : curve25519_dalek.edwards.EdwardsPoint) (hself : self.IsValid)\n    (other : ProjectiveNielsPoint) (hother : other.IsValid) :\n    ∃ c, add self other = ok c ∧\n    c.IsValid ∧ c.toPoint = self.toPoint + other.toPoint := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/CompletedPoint/Add.lean",
   "spec_docstring":
   "/-- Spec for `add`.\nThe theorem states that adding a valid EdwardsPoint with a valid ProjectiveNielsPoint:\n1. Always succeeds\n2. The output CompletedPoint is valid (bounds and algebraic properties)\n3. The output represents the sum of the input points\nThe mixed addition formulas implement elliptic curve point addition on twisted Edwards curves.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn add(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.Y_plus_X;\n        let MM = &Y_minus_X * &other.Y_minus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &ZZ2 + &TT2d,\n            T: &ZZ2 - &TT2d,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::add",
   "lines": "L415-L430",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAProjectiveNielsPointCompletedPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl<'a> Mul<&'a Scalar> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L849-L858",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (e : edwards.EdwardsPoint) (s : scalar.Scalar)\n    (h_s_canonical : U8x32_as_Nat s.bytes < L)\n    (h_e_valid : e.IsValid) :\n    mul e s ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = (U8x32_as_Nat s.bytes) • e.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul`**:\n• The function always succeeds (no panic) for valid input EdwardsPoints e and canonical Scalars s\n• The result is a valid EdwardsPoint\n• The result is mathematically correct, i.e., result.toPoint = e.toPoint + .. + e.toPoint (s-times)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::mul",
   "lines": "L855-L857",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.backend.variable_base_mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl Neg for &EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Neg<curve25519_dalek::edwards::EdwardsPoint> for &0 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L812-L823",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Neg<curve25519_dalek::edwards::EdwardsPoint> for &0 (curve25519_dalek::edwards::EdwardsPoint)}::neg",
   "lines": "L815-L822",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl<'a> Sub<&'a AffineNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn sub(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L477-L495",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAAffineNielsPointCompletedPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAAffineNielsPointCompletedPoint.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec\n  (self : edwards.EdwardsPoint)\n  (other : backend.serial.curve_models.AffineNielsPoint)\n  (h_selfX_bounds : ∀ i, i < 5 → (self.X[i]!).val < 2 ^ 53)\n  (h_selfY_bounds : ∀ i, i < 5 → (self.Y[i]!).val < 2 ^ 53)\n  (h_selfZ_bounds : ∀ i, i < 5 → (self.Z[i]!).val < 2 ^ 53)\n  (h_selfT_bounds : ∀ i, i < 5 → (self.T[i]!).val < 2 ^ 53)\n  (h_otherYpX_bounds : ∀ i, i < 5 → (other.y_plus_x[i]!).val < 2 ^ 53)\n  (h_otherYmX_bounds : ∀ i, i < 5 → (other.y_minus_x[i]!).val < 2 ^ 53)\n  (h_otherXY2d_bounds : ∀ i, i < 5 → (other.xy2d[i]!).val < 2 ^ 53) :\nShared0EdwardsPoint.Insts.CoreOpsArithSubSharedAAffineNielsPointCompletedPoint.sub self other ⦃ c =>\nlet X := Field51_as_Nat self.X\nlet Y := Field51_as_Nat self.Y\nlet Z := Field51_as_Nat self.Z\nlet T := Field51_as_Nat self.T\nlet YpX := Field51_as_Nat other.y_plus_x\nlet YmX := Field51_as_Nat other.y_minus_x\nlet XY2D := Field51_as_Nat other.xy2d\nlet X' := Field51_as_Nat c.X\nlet Y' := Field51_as_Nat c.Y\nlet Z' := Field51_as_Nat c.Z\nlet T' := Field51_as_Nat c.T\n(X' + Y * YpX) % p = (((Y + X) * YmX) + X * YpX) % p ∧\n(Y' + X * YpX) % p = (((Y + X) * YmX) + Y  * YpX) % p ∧\n(Z' + (T * XY2D)) % p = (2 * Z) % p ∧\nT' % p = ((2 * Z) + (T * XY2D)) % p ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Sub.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn sub(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::sub",
   "lines": "L480-L494",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAAffineNielsPointCompletedPoint.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl<'a> Sub<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L775-L780",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::sub",
   "lines": "L777-L779",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAEdwardsPointEdwardsPoint.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective_niels",
    "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAProjectiveNielsPointCompletedPoint.sub",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl<'a> Sub<&'a ProjectiveNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn sub(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.Y_minus_X;\n        let MP = &Y_minus_X * &other.Y_plus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &ZZ2 - &TT2d,\n            T: &ZZ2 + &TT2d,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L434-L453",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAProjectiveNielsPointCompletedPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAProjectiveNielsPointCompletedPoint.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec\n  (self : edwards.EdwardsPoint)\n  (other : backend.serial.curve_models.ProjectiveNielsPoint)\n  (h_selfX_bounds : ∀ i, i < 5 → (self.X[i]!).val < 2 ^ 53)\n  (h_selfY_bounds : ∀ i, i < 5 → (self.Y[i]!).val < 2 ^ 53)\n  (h_selfZ_bounds : ∀ i, i < 5 → (self.Z[i]!).val < 2 ^ 53)\n  (h_selfT_bounds : ∀ i, i < 5 → (self.T[i]!).val < 2 ^ 53)\n  (h_otherYpX_bounds : ∀ i, i < 5 → (other.Y_plus_X[i]!).val < 2 ^ 53)\n  (h_otherYmX_bounds : ∀ i, i < 5 → (other.Y_minus_X[i]!).val < 2 ^ 53)\n  (h_otherZ_bounds : ∀ i, i < 5 → (other.Z[i]!).val < 2 ^ 53)\n  (h_otherT2d_bounds : ∀ i, i < 5 → (other.T2d[i]!).val < 2 ^ 53) :\nShared0EdwardsPoint.Insts.CoreOpsArithSubSharedAProjectiveNielsPointCompletedPoint.sub self other ⦃ c =>\nlet X := Field51_as_Nat self.X\nlet Y := Field51_as_Nat self.Y\nlet Z := Field51_as_Nat self.Z\nlet T := Field51_as_Nat self.T\nlet YpX := Field51_as_Nat other.Y_plus_X\nlet YmX := Field51_as_Nat other.Y_minus_X\nlet Z₀ := Field51_as_Nat other.Z\nlet T2d := Field51_as_Nat other.T2d\nlet X' := Field51_as_Nat c.X\nlet Y' := Field51_as_Nat c.Y\nlet Z' := Field51_as_Nat c.Z\nlet T' := Field51_as_Nat c.T\n(X' + Y * YpX) % p = (((Y + X) * YmX) + X * YpX) % p ∧\n(Y' + X * YpX) % p = (((Y + X) * YmX) + Y  * YpX) % p ∧\n(Z' + (T * T2d) )% p = (2 * Z * Z₀)  % p ∧\nT' % p = ((2 * Z * Z₀) + (T * T2d)) % p ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/Sub.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn sub(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.Y_minus_X;\n        let MP = &Y_minus_X * &other.Y_plus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &ZZ2 - &TT2d,\n            T: &ZZ2 + &TT2d,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::sub",
   "lines": "L437-L452",
   "lean_name":
   "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAProjectiveNielsPointCompletedPoint.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}",
   "lines": "L68-L75",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 53) (hb : ∀ i < 5, b[i]!.val < 2 ^ 53) :\n    add a b ⦃ result =>\n    (∀ i < 5, result[i]!.val = a[i]!.val + b[i]!.val) ∧\n    (∀ i < 5, result[i]!.val < 2^54) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Add.lean",
   "spec_docstring":
   "/-- **Spec for `Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add`**:\n- Does not overflow when limb sums don't exceed U64.max\n- Returns a field element where each limb is the sum of corresponding input limbs\n- This is element-wise addition, not modular field addition (use reduce for that)\n- Input bounds: both inputs have limbs < 2^53\n- Output bounds: output has limbs < 2^54\n- Simply wraps add_assign -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::add",
   "lines": "L70-L74",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip] // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Mul<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}",
   "lines": "L113-L216",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (lhs rhs : Array U64 5#usize)\n    (hlhs : ∀ i < 5, lhs[i]!.val < 2 ^ 54) (hrhs : ∀ i < 5, rhs[i]!.val < 2 ^ 54) :\n    mul lhs rhs ⦃ r =>\n    Field51_as_Nat r ≡ (Field51_as_Nat lhs) * (Field51_as_Nat rhs) [MOD p] ∧\n    (∀ i < 5, r[i]!.val < 2 ^ 52) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Mul.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Mul<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::mul",
   "lines": "L117-L215",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.m",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.LOW_51_BIT_MASK"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Neg<curve25519_dalek::backend::serial::u64::field::FieldElement51> for &0 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}",
   "lines": "L218-L225",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem neg_spec (r : backend.serial.u64.field.FieldElement51)\n    (h : ∀ i < 5, r[i]!.val < 2 ^ 54) :\n    neg r ⦃ r_inv =>\n    (Field51_as_Nat r + Field51_as_Nat r_inv) % p = 0 ∧\n    (∀ i < 5, r_inv[i]!.val ≤ 2^51 + (2^13 - 1) * 19) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Neg.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.FieldElement51.neg`**:\n- No panic (always returns successfully under standard bounds)\n- Delegates to `negate`, hence returns the additive inverse modulo p\n- Input bound assumption: all limbs of the input are < 2^54 (as in `negate_spec`)\n- Output bound matches `negate_spec` -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Neg<curve25519_dalek::backend::serial::u64::field::FieldElement51> for &0 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::neg",
   "lines": "L220-L224",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.negate"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}",
   "lines": "L84-L104",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec (a b : Array U64 5#usize)\n    (h_bounds_a : ∀ i < 5, a[i]!.val < 2 ^ 63)\n    (h_bounds_b : ∀ i < 5, b[i]!.val < 2 ^ 54) :\n    sub a b ⦃ d =>\n    (∀ i < 5, d[i]!.val < 2 ^ 52) ∧\n    (Field51_as_Nat d + Field51_as_Nat b) % p = Field51_as_Nat a % p ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Sub.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.sub`**:\n- No panic (always returns successfully when bounds are satisfied)\n- The result d satisfies the field subtraction property:\n\n  Field51_as_Nat(d) ≡ Field51_as_Nat(a) - Field51_as_Nat(b) (mod p), or equivalently\n  Field51_as_Nat(d) + Field51_as_Nat(b) ≡ Field51_as_Nat(a) (mod p)\n\n- Requires that input limbs are bounded:\n  - For a: limbs must allow addition with 16*p without U64 overflow\n    - a[0] must be ≤ 18410715276690587951 (= 2^64 - 1 - 36028797018963664)\n    - a[1..4] must be ≤ 18410715276690587663 (= 2^64 - 1 - 36028797018963952)\n  - For b: limbs must be ≤ the constants (representing 16*p) to avoid underflow\n    - b[0] must be ≤ 36028797018963664\n    - b[1..4] must be ≤ 36028797018963952\n  To make the theorem more easily readable and provable, we\n  replace these precise bounds with the slightly looser bounds\n  a[i] < 2^63  and b[i] < 2^54\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::sub",
   "lines": "L86-L103",
   "lean_name":
   "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Neg for &ProjectiveNielsPoint {\n    type Output = ProjectiveNielsPoint;\n\n    fn neg(self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.Y_minus_X,\n            Y_minus_X: self.Y_plus_X,\n            Z: self.Z,\n            T2d: -(&self.T2d),\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint> for &0 (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint)}",
   "lines": "L501-L512",
   "lean_name":
   "curve25519_dalek.Shared0ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint.neg"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem neg_spec\n    (self : backend.serial.curve_models.ProjectiveNielsPoint)\n    (self_bound : ∀ i, i < 5 → (self.T2d[i]!).val < 2 ^ 54) :\n    neg self ⦃ result =>\n    result.Y_plus_X = self.Y_minus_X ∧\n    result.Y_minus_X = self.Y_plus_X ∧\n    result.Z = self.Z ∧\n    (Field51_as_Nat self.T2d + Field51_as_Nat result.T2d) % p = 0 ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/Neg.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ProjectiveNielsPoint.neg`**:\n- No panic (always returns successfully)\n- Given input:\n  • a ProjectiveNielsPoint `self` with coordinates (Y_plus_X, Y_minus_X, Z, T2d),\nthe output ProjectiveNielsPoint computed by `neg self` has coordinates\n(Y_plus_X', Y_minus_X', Z', T2d') where:\n- Y_plus_X' = Y_minus_X (the coordinates are swapped)\n- Y_minus_X' = Y_plus_X (the coordinates are swapped)\n- Z' = Z (the Z coordinate is unchanged)\n- T2d' ≡ -T2d (mod p) (the T2d coordinate is negated modulo p)\n\nwhere p = 2^255 - 19.\n\nThis implements the negation of a point in projective Niels coordinates.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn neg(self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.Y_minus_X,\n            Y_minus_X: self.Y_plus_X,\n            Z: self.Z,\n            T2d: -(&self.T2d),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint> for &0 (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint)}::neg",
   "lines": "L504-L511",
   "lean_name":
   "curve25519_dalek.Shared0ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl<'a> Add<&'a RistrettoPoint> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::ristretto::RistrettoPoint)}",
   "lines": "L887-L893",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithAddSharedARistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithAddSharedARistrettoPointRistrettoPoint.add"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec (self other : RistrettoPoint) (h_self_valid : self.IsValid) (h_other_valid : other.IsValid) :\n    add self other ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = self.toPoint + other.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Add.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.AddShared0RistrettoPointSharedARistrettoPointRistrettoPoint.add`**:\n• The function always succeeds (no panic) for valid inputs\n• The result is a valid Ristretto point\n• The result represents the sum of the inputs (in the context of elliptic curve addition)\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::ristretto::RistrettoPoint)}::add",
   "lines": "L890-L892",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithAddSharedARistrettoPointRistrettoPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl<'a> Mul<&'a Scalar> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n    /// Scalar multiplication: compute `scalar * self`.\n    fn mul(self, scalar: &'a Scalar) -> RistrettoPoint {\n        RistrettoPoint(self.0 * scalar)\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::ristretto::RistrettoPoint)}",
   "lines": "L966-L972",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (r : RistrettoPoint) (s : scalar.Scalar)\n    (h_s_canonical : U8x32_as_Nat s.bytes < L)\n    (h_rist_valid : r.IsValid) :\n    mul r s ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = (U8x32_as_Nat s.bytes) • r.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint.mul`**:\n• The function always succeeds (no panic) for valid input RistrettoPoints r and canonical Scalars s\n• The result is a valid RistrettoPoint\n• The result = r + ... + r represents the input RistrettoPoint r added to itself s-times\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn mul(self, scalar: &'a Scalar) -> RistrettoPoint {\n        RistrettoPoint(self.0 * scalar)\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::ristretto::RistrettoPoint)}::mul",
   "lines": "L969-L971",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulSharedBScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl Neg for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Neg<curve25519_dalek::ristretto::RistrettoPoint> for &0 (curve25519_dalek::ristretto::RistrettoPoint)}",
   "lines": "L943-L949",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithNegRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithNegRistrettoPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Neg<curve25519_dalek::ristretto::RistrettoPoint> for &0 (curve25519_dalek::ristretto::RistrettoPoint)}::neg",
   "lines": "L946-L948",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithNegRistrettoPoint.neg",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl<'a> Sub<&'a RistrettoPoint> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::ristretto::RistrettoPoint)}",
   "lines": "L909-L915",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithSubSharedARistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithSubSharedARistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::ristretto::RistrettoPoint)}::sub",
   "lines": "L912-L914",
   "lean_name":
   "curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithSubSharedARistrettoPointRistrettoPoint.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}",
   "lines": "L340-L348",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithAddSharedAScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithAddSharedAScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}::add",
   "lines": "L343-L347",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithAddSharedAScalarScalar.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl<'a> Mul<&'a EdwardsPoint> for &Scalar {\n    type Output = EdwardsPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, point: &'a EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::scalar::Scalar)}",
   "lines": "L860-L870",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAEdwardsPointEdwardsPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (s : scalar.Scalar) (e : edwards.EdwardsPoint)\n    (h_s_canonical : U8x32_as_Nat s.bytes < L)\n    (h_e_valid : e.IsValid) :\n    mul s e ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = (U8x32_as_Nat s.bytes) • e.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `Shared0Scalar.Insts.CoreOpsArithMulSharedAEdwardsPointEdwardsPoint.mul`**:\n• The function always succeeds (no panic) for canonical input Scalars s and valid input EdwardsPoints e\n• The result is a valid EdwardsPoint\n• The result is mathematically correct, i.e., result.toPoint = e.toPoint + .. + e.toPoint (s-times)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn mul(self, point: &'a EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L867-L869",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAEdwardsPointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl<'a> Mul<&'a RistrettoPoint> for &Scalar {\n    type Output = RistrettoPoint;\n\n    /// Scalar multiplication: compute `self * scalar`.\n    fn mul(self, point: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self * point.0)\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::scalar::Scalar)}",
   "lines": "L974-L981",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedARistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedARistrettoPointRistrettoPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (s : scalar.Scalar) (r : RistrettoPoint)\n    (h_s_canonical : U8x32_as_Nat s.bytes < L)\n    (h_rist_valid : r.IsValid) :\n    mul s r ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = (U8x32_as_Nat s.bytes) • r.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `Shared0Scalar.Insts.CoreOpsArithMulSharedARistrettoPointRistrettoPoint.mul`**:\n• The function always succeeds (no panic) for canonical input Scalars s and valid input RistrettoPoints r\n• The result is a valid RistrettoPoint\n• The result = r + ... + r represents the input RistrettoPoint r added to itself s-times\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn mul(self, point: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self * point.0)\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L978-L980",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedARistrettoPointRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl<'a> Mul<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}",
   "lines": "L323-L328",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L325-L327",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl Neg for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Neg<curve25519_dalek::scalar::Scalar> for &0 (curve25519_dalek::scalar::Scalar)}",
   "lines": "L372-L380",
   "lean_name": "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithNegScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithNegScalar.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Neg<curve25519_dalek::scalar::Scalar> for &0 (curve25519_dalek::scalar::Scalar)}::neg",
   "lines": "L375-L379",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithNegScalar.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.constants.R",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl<'a> Sub<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}",
   "lines": "L360-L368",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithSubSharedAScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithSubSharedAScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}::sub",
   "lines": "L363-L367",
   "lean_name":
   "curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithSubSharedAScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl Mul<&Scalar> for &MontgomeryPoint {\n    type Output = MontgomeryPoint;\n\n    /// Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)\n    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017 (inlined from mul_bits_be)\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2.\n        // We multiply by the integer representation of the given Scalar. By scalar invariant #1,\n        // the MSB (bit 255) is 0, so we can skip it and start from bit 254.\n        let scalar_bytes = scalar.as_bytes();\n        let mut prev_bit = false;\n        let mut i: isize = 254;\n        while i >= 0 {\n            let byte_idx = (i >> 3) as usize; // i / 8\n            let bit_idx = (i & 7) as usize; // i % 8\n            let cur_bit = ((scalar_bytes[byte_idx] >> bit_idx) & 1u8) == 1u8;\n\n            let choice: u8 = (prev_bit != cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n            i -= 1;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        #[cfg(feature = \"zeroize\")]\n        prev_bit.zeroize();\n\n        x0.as_affine()\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::montgomery::MontgomeryPoint)}",
   "lines": "L410-L452",
   "lean_name":
   "curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (P : montgomery.MontgomeryPoint) (scalar : scalar.Scalar) :\n    mul P scalar ⦃ res =>\n    let m:= (U8x32_as_Nat scalar.bytes) % 2^255\n    MontgomeryPoint.mkPoint res = m • (MontgomeryPoint.mkPoint P) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017 (inlined from mul_bits_be)\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2.\n        // We multiply by the integer representation of the given Scalar. By scalar invariant #1,\n        // the MSB (bit 255) is 0, so we can skip it and start from bit 254.\n        let scalar_bytes = scalar.as_bytes();\n        let mut prev_bit = false;\n        let mut i: isize = 254;\n        while i >= 0 {\n            let byte_idx = (i >> 3) as usize; // i / 8\n            let bit_idx = (i & 7) as usize; // i % 8\n            let cur_bit = ((scalar_bytes[byte_idx] >> bit_idx) & 1u8) == 1u8;\n\n            let choice: u8 = (prev_bit != cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n            i -= 1;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        #[cfg(feature = \"zeroize\")]\n        prev_bit.zeroize();\n\n        x0.as_affine()\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::montgomery::MontgomeryPoint)}::mul",
   "lines": "L414-L451",
   "lean_name":
   "curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.IdentityMontgomeryProjectivePoint.identity",
    "curve25519_dalek.scalar.Scalar.as_bytes",
    "curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul_loop",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.montgomery.ProjectivePoint.as_affine"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_loop_spec\n    (affine_u : backend.serial.u64.field.FieldElement51)\n    (x0 x1 : montgomery.ProjectivePoint)\n    (scalar_bytes : Array U8 32#usize)\n    (prev_bit : Bool)\n    (i : Isize)\n    (idx0W : x0.W = backend.serial.u64.field.FieldElement51.ZERO)\n    (idx1W : x1.W = backend.serial.u64.field.FieldElement51.ONE)\n    (idx0U : x0.U = backend.serial.u64.field.FieldElement51.ONE)\n    :\n    mul_loop affine_u x0 x1 scalar_bytes prev_bit i ⦃ res =>\n    (res.2.2 =true →\n      let q := (i.val / 8).toNat\n      let r := (i.val % 8).toNat\n      let m := ∑ i ∈ Finset.range q, 2^(8 * i) * (scalar_bytes[i]!).val\n        +  2^(8 * q) * ((scalar_bytes[q]!).val % 2^(r+1))\n        + 2^(8 * q+r) * prev_bit.toNat\n      let u := x1.U.toField\n      let u_out := res.2.1.U.toField\n      let w_out := res.2.1.W.toField\n      let u_ord := u_out/w_out\n      w_out ≠ 0 ∧\n      MontgomeryPoint.u_affine_toPoint u_ord = m • (MontgomeryPoint.u_affine_toPoint u)) ∧\n    (res.2.2 = false →\n      let q := (i.val / 8).toNat\n      let r := (i.val % 8).toNat\n      let m := ∑ i ∈ Finset.range q, 2^(8 * i) * (scalar_bytes[i]!).val\n      + 2^(8 * q) * ((scalar_bytes[q]!).val % 2^(r+1))\n      + 2^(8 * q+r) * prev_bit.toNat\n      let u := x1.U.toField\n      let u_out := res.1.U.toField\n      let w_out := res.1.W.toField\n      let u_ord := u_out/w_out\n      w_out ≠ 0 ∧\n      MontgomeryPoint.u_affine_toPoint u_ord = m • (MontgomeryPoint.u_affine_toPoint u)) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "        while i >= 0 {\n            let byte_idx = (i >> 3) as usize; // i / 8\n            let bit_idx = (i & 7) as usize; // i % 8\n            let cur_bit = ((scalar_bytes[byte_idx] >> bit_idx) & 1u8) == 1u8;\n\n            let choice: u8 = (prev_bit != cur_bit) as u8;",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::montgomery::MontgomeryPoint)}::mul",
   "lines": "L429-L434",
   "lean_name":
   "curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul_loop.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "        while i >= 0 {\n            let byte_idx = (i >> 3) as usize; // i / 8\n            let bit_idx = (i & 7) as usize; // i % 8\n            let cur_bit = ((scalar_bytes[byte_idx] >> bit_idx) & 1u8) == 1u8;\n\n            let choice: u8 = (prev_bit != cur_bit) as u8;",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::montgomery::MontgomeryPoint)}::mul",
   "lines": "L429-L434",
   "lean_name":
   "curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul_loop.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.montgomery.differential_add_and_double"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl Mul<&MontgomeryPoint> for &Scalar {\n    type Output = MontgomeryPoint;\n\n    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::montgomery::MontgomeryPoint), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::scalar::Scalar)}",
   "lines": "L460-L466",
   "lean_name":
   "curve25519_dalek.Shared1Scalar.Insts.CoreOpsArithMulShared0MontgomeryPointMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1Scalar.Insts.CoreOpsArithMulShared0MontgomeryPointMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (scalar : scalar.Scalar) (P : montgomery.MontgomeryPoint) :\n    mul scalar P ⦃ res =>\n    let m:= (U8x32_as_Nat scalar.bytes) % 2^255\n    MontgomeryPoint.mkPoint res = m • (MontgomeryPoint.mkPoint P) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul`**:\n- No panic (always returns successfully given valid inputs)\n- Implements scalar multiplication via delegation to the reverse operation\n- The result is mathematically equivalent to [scalar]point\n- Mathematical properties of the result:\n  * The result encodes the u-coordinate of the scalar multiplication [scalar]point\n  * Mathematically equivalent to MontgomeryPoint::mul with swapped arguments\n  * If point has u-coordinate u₀ and scalar is n (as an integer ≤ 2^255), then the result\n    encodes u₀([n]point), the u-coordinate of the n-fold sum of point on the Montgomery curve\n  * The computation maintains constant-time guarantees inherited from the underlying\n    Montgomery ladder implementation\n  * The returned MontgomeryPoint is a valid 32-byte encoding with value reduced modulo 2^255\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::montgomery::MontgomeryPoint), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L463-L465",
   "lean_name":
   "curve25519_dalek.Shared1Scalar.Insts.CoreOpsArithMulShared0MontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Add<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L24-L29",
   "lean_name":
   "curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::edwards::EdwardsPoint)}::add",
   "lines": "L26-L28",
   "lean_name":
   "curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L98-L103",
   "lean_name":
   "curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::edwards::EdwardsPoint)}::mul",
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Sub<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::edwards::EdwardsPoint)}",
   "lines": "L61-L66",
   "lean_name":
   "curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithSubEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithSubEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::edwards::EdwardsPoint)}::sub",
   "lines": "L63-L65",
   "lean_name":
   "curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithSubEdwardsPointEdwardsPoint.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::montgomery::MontgomeryPoint> for &'a (curve25519_dalek::montgomery::MontgomeryPoint)}",
   "lines": "L98-L103",
   "lean_name":
   "curve25519_dalek.SharedAMontgomeryPoint.Insts.CoreOpsArithMulScalarMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAMontgomeryPoint.Insts.CoreOpsArithMulScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::montgomery::MontgomeryPoint> for &'a (curve25519_dalek::montgomery::MontgomeryPoint)}::mul",
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.SharedAMontgomeryPoint.Insts.CoreOpsArithMulScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Add<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::ristretto::RistrettoPoint)}",
   "lines": "L24-L29",
   "lean_name":
   "curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithAddRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithAddRistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::ristretto::RistrettoPoint)}::add",
   "lines": "L26-L28",
   "lean_name":
   "curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithAddRistrettoPointRistrettoPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithAddSharedARistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::ristretto::RistrettoPoint)}",
   "lines": "L98-L103",
   "lean_name":
   "curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithMulScalarRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithMulScalarRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::ristretto::RistrettoPoint)}::mul",
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithMulScalarRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Sub<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::ristretto::RistrettoPoint)}",
   "lines": "L61-L66",
   "lean_name":
   "curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithSubRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithSubRistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::ristretto::RistrettoPoint)}::sub",
   "lines": "L63-L65",
   "lean_name":
   "curve25519_dalek.SharedARistrettoPoint.Insts.CoreOpsArithSubRistrettoPointRistrettoPoint.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithSubSharedARistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Add<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}",
   "lines": "L24-L29",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithAddScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithAddScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}::add",
   "lines": "L26-L28",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithAddScalarScalar.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithAddSharedAScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::scalar::Scalar)}",
   "lines": "L98-L103",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::montgomery::MontgomeryPoint, curve25519_dalek::montgomery::MontgomeryPoint> for &'a (curve25519_dalek::scalar::Scalar)}",
   "lines": "L98-L103",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulMontgomeryPointMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulMontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::montgomery::MontgomeryPoint, curve25519_dalek::montgomery::MontgomeryPoint> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulMontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1Scalar.Insts.CoreOpsArithMulShared0MontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::scalar::Scalar)}",
   "lines": "L98-L103",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulRistrettoPointRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulRistrettoPointRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedARistrettoPointRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}",
   "lines": "L98-L103",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'a> Sub<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}",
   "lines": "L61-L66",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithSubScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithSubScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}::sub",
   "lines": "L63-L65",
   "lean_name":
   "curve25519_dalek.SharedAScalar.Insts.CoreOpsArithSubScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithSubSharedAScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/mod.rs",
   "rust_source":
   "fn get_selected_backend() -> BackendKind {\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    {\n        cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n        let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n        if token_avx512.get() {\n            return BackendKind::Avx512;\n        }\n    }\n\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    {\n        cpufeatures::new!(cpuid_avx2, \"avx2\");\n        let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n        if token_avx2.get() {\n            return BackendKind::Avx2;\n        }\n    }\n\n    BackendKind::Serial\n}",
   "rust_name": "curve25519_dalek::backend::get_selected_backend",
   "lines": "L55-L75",
   "lean_name": "curve25519_dalek.backend.get_selected_backend",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::clone",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::cmp::Eq for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCmpPartialEqAffineNielsPoint",
    "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCmpEq.assert_receiver_is_total_eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem assert_receiver_is_total_eq_spec\n    (self : backend.serial.curve_models.AffineNielsPoint) :\n    assert_receiver_is_total_eq self ⦃ result => result = () ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/AssertReceiverIsTotalEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `AffineNielsPoint.Insts.CoreCmpEq.assert_receiver_is_total_eq`**:\n- No panic (always returns successfully)\n- The result is `()`\n- This is the `Eq`-trait totality assertion for `AffineNielsPoint`\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::cmp::Eq for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::assert_receiver_is_total_eq",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCmpEq.assert_receiver_is_total_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::cmp::PartialEq<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCmpPartialEqAffineNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCmpPartialEqAffineNielsPoint.eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem eq_spec\n    (self other : backend.serial.curve_models.AffineNielsPoint) :\n    eq self other ⦃ b =>\n    (b = true ↔\n      self.y_plus_x.to_bytes = other.y_plus_x.to_bytes ∧\n      self.y_minus_x.to_bytes = other.y_minus_x.to_bytes ∧\n      self.xy2d.to_bytes = other.xy2d.to_bytes) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Eq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `AffineNielsPoint.Insts.CoreCmpPartialEqAffineNielsPoint.eq`**:\n- No panic (always returns successfully)\n- Returns true iff all three coordinate comparisons return true\n- Short-circuits to false as soon as a comparison fails\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::cmp::PartialEq<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::eq",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCmpPartialEqAffineNielsPoint.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Default for AffineNielsPoint {\n    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::default::Default for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L267-L271",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::default::Default for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::default",
   "lines": "L268-L270",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::marker::Copy for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::marker::StructuralPartialEq for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreMarkerStructuralPartialEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Neg for AffineNielsPoint {\n    type Output = AffineNielsPoint;\n\n    fn neg(self) -> AffineNielsPoint {\n        -&self\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L534-L540",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreOpsArithNegAffineNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreOpsArithNegAffineNielsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn neg(self) -> AffineNielsPoint {\n        -&self\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::neg",
   "lines": "L537-L539",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreOpsArithNegAffineNielsPoint.neg",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0AffineNielsPoint.Insts.CoreOpsArithNegAffineNielsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Identity for AffineNielsPoint {\n    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L257-L265",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    spec identity (fun q =>\n    q.y_plus_x = ONE ∧ q.y_minus_x = ONE ∧ q.xy2d = ZERO) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.IdentityAffineNielsPoint.identity`**:\n- No panic (always returns successfully)\n- The resulting AffineNielsPoint is the identity element with coordinates\n  (y_plus_x=1, y_minus_x=1, xy2d=0)\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::identity",
   "lines": "L258-L264",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl ConditionallySelectable for AffineNielsPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L314-L328",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.SubtleConditionallySelectable.conditional_select",
    "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.SubtleConditionallySelectable.conditional_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem conditional_assign_spec\n    (self other : backend.serial.curve_models.AffineNielsPoint)\n    (choice : subtle.Choice) :\n    conditional_assign self other choice ⦃ result =>\n    (∀ i < 5, result.y_plus_x[i]!.val =\n      if choice.val = 1#u8 then other.y_plus_x[i]!.val else self.y_plus_x[i]!.val) ∧\n    (∀ i < 5, result.y_minus_x[i]!.val =\n      if choice.val = 1#u8 then other.y_minus_x[i]!.val else self.y_minus_x[i]!.val) ∧\n    (∀ i < 5, result.xy2d[i]!.val =\n      if choice.val = 1#u8 then other.xy2d[i]!.val else self.xy2d[i]!.val) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/ConditionalAssign.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ConditionallySelectableAffineNielsPoint.conditional_assign`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • an AffineNielsPoint `self` with coordinates (y_plus_x, y_minus_x, xy2d),\n  • an AffineNielsPoint `other` with coordinates (y_plus_x', y_minus_x', xy2d'),\n  • a Choice `choice`,\nthe output AffineNielsPoint computed by `conditional_assign self other choice` satisfies:\n- Each coordinate is conditionally selected: if choice is 1, output = other; if choice is 0, output = self\n- The operation is performed in constant time for all field elements\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::conditional_assign",
   "lines": "L323-L327",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.SubtleConditionallySelectable.conditional_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : backend.serial.curve_models.AffineNielsPoint)\n    (choice : subtle.Choice) :\n    conditional_select a b choice ⦃ result =>\n    (∀ i < 5, result.y_plus_x[i]!.val =\n      if choice.val = 1#u8 then b.y_plus_x[i]!.val else a.y_plus_x[i]!.val) ∧\n    (∀ i < 5, result.y_minus_x[i]!.val =\n      if choice.val = 1#u8 then b.y_minus_x[i]!.val else a.y_minus_x[i]!.val) ∧\n    (∀ i < 5, result.xy2d[i]!.val =\n      if choice.val = 1#u8 then b.xy2d[i]!.val else a.xy2d[i]!.val) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec and proof concerning `backend.serial.curve_models.AffineNielsPoint.conditional_select`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • AffineNielsPoint `a` with coordinates (y_plus_x, y_minus_x, xy2d),\n  • AffineNielsPoint `b` with coordinates (y_plus_x', y_minus_x', xy2d'),\n  • a Choice `choice`,\n  the output AffineNielsPoint has coordinates selected component-wise:\n  - If choice = 1, each coordinate equals the corresponding one of `b`\n  - If choice = 0, each coordinate equals the corresponding one of `a`\n  - The operation is constant-time (does not branch on choice)\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::conditional_select",
   "lines": "L315-L321",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Zeroize for AffineNielsPoint {\n    fn zeroize(&mut self) {\n        self.y_plus_x.zeroize();\n        self.y_minus_x.zeroize();\n        self.xy2d.zeroize();\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "lines": "L191-L197",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.ZeroizeZeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn zeroize(&mut self) {\n        self.y_plus_x.zeroize();\n        self.y_minus_x.zeroize();\n        self.xy2d.zeroize();\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::zeroize",
   "lines": "L192-L196",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AffineNielsPoint.Insts.ZeroizeZeroize.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::CompletedPoint}",
   "lines": "L167-L167",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CompletedPoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.CompletedPoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::CompletedPoint}::clone",
   "lines": "L167-L167",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CompletedPoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::marker::Copy for curve25519_dalek::backend::serial::curve_models::CompletedPoint}",
   "lines": "L167-L167",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CompletedPoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.CompletedPoint.Insts.CoreCloneClone"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_extended_spec (q : CompletedPoint)\n  (h_qX_bounds : ∀ i, i < 5 → (q.X[i]!).val < 2 ^ 54)\n  (h_qY_bounds : ∀ i, i < 5 → (q.Y[i]!).val < 2 ^ 54)\n  (h_qZ_bounds : ∀ i, i < 5 → (q.Z[i]!).val < 2 ^ 54)\n  (h_qT_bounds : ∀ i, i < 5 → (q.T[i]!).val < 2 ^ 54) :\nas_extended q ⦃ e =>\nlet X := Field51_as_Nat q.X\nlet Y := Field51_as_Nat q.Y\nlet Z := Field51_as_Nat q.Z\nlet T := Field51_as_Nat q.T\nlet X' := Field51_as_Nat e.X\nlet Y' := Field51_as_Nat e.Y\nlet Z' := Field51_as_Nat e.Z\nlet T' := Field51_as_Nat e.T\nX' % p = (X * T) % p ∧\nY' % p = (Y * Z) % p ∧\nZ' % p = (Z * T) % p ∧\nT' % p = (X * Y) % p ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/CompletedPoint/AsExtended.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.CompletedPoint.as_extended`**:\n- No panic (always returns successfully)\n- Given input CompletedPoint with coordinates (X, Y, Z, T), the output EdwardsPoint (X', Y', Z', T')\nsatisfies the conversion formulas modulo p:\n- X' ≡ X·T (mod p)\n- Y' ≡ Y·Z (mod p)\n- Z' ≡ Z·T (mod p)\n- T' ≡ X·Y (mod p)\nwhere p = 2^255 - 19\nThese formulas implement the conversion from completed ℙ¹ × ℙ¹ coordinates to extended\ntwisted Edwards ℙ³ coordinates.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n            T: &self.X * &self.Y,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::CompletedPoint}::as_extended",
   "lines": "L366-L373",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_projective_spec\n    (q : CompletedPoint) (hq_valid : q.IsValid) :\n    ∃ proj, as_projective q = ok proj ∧\n    proj.IsValid ∧ proj.toPoint = q.toPoint := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/CompletedPoint/AsProjective.lean",
   "spec_docstring":
   "/--\nVerification of the `as_projective` function.\nThe theorem states that converting a valid CompletedPoint to ProjectivePoint:\n1. Always succeeds\n2. Produces a valid ProjectivePoint\n3. Preserves the represented affine point\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    pub fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::CompletedPoint}::as_projective",
   "lines": "L354-L360",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_projective",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "lines": "L204-L204",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::clone",
   "lines": "L204-L204",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Default for ProjectiveNielsPoint {\n    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::default::Default for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "lines": "L251-L255",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::default::Default for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::default",
   "lines": "L252-L254",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::marker::Copy for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "lines": "L204-L204",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Neg for ProjectiveNielsPoint {\n    type Output = ProjectiveNielsPoint;\n\n    fn neg(self) -> ProjectiveNielsPoint {\n        -&self\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint> for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "lines": "L514-L520",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn neg(self) -> ProjectiveNielsPoint {\n        -&self\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint> for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::neg",
   "lines": "L517-L519",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Identity for ProjectiveNielsPoint {\n    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "lines": "L240-L249",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    spec identity (fun q =>\n    q.Y_plus_X = ONE ∧ q.Y_minus_X = ONE ∧ q.Z = ONE ∧ q.T2d = ZERO) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.IdentityProjectiveNielsPoint.identity`**:\n- No panic (always returns successfully)\n- The resulting ProjectiveNielsPoint is the identity element with coordinates\n  (Y_plus_X=1, Y_minus_X=1, Z=1, T2d=0)\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::identity",
   "lines": "L241-L248",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl ConditionallySelectable for ProjectiveNielsPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "lines": "L296-L312",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.SubtleConditionallySelectable.conditional_select",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.SubtleConditionallySelectable.conditional_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem conditional_assign_spec\n    (self other : backend.serial.curve_models.ProjectiveNielsPoint)\n    (choice : subtle.Choice) :\n    conditional_assign self other choice ⦃ result =>\n    (∀ i < 5, result.Y_plus_X[i]!.val =\n      if choice.val = 1#u8 then other.Y_plus_X[i]!.val else self.Y_plus_X[i]!.val) ∧\n    (∀ i < 5, result.Y_minus_X[i]!.val =\n      if choice.val = 1#u8 then other.Y_minus_X[i]!.val else self.Y_minus_X[i]!.val) ∧\n    (∀ i < 5, result.Z[i]!.val =\n      if choice.val = 1#u8 then other.Z[i]!.val else self.Z[i]!.val) ∧\n    (∀ i < 5, result.T2d[i]!.val =\n      if choice.val = 1#u8 then other.T2d[i]!.val else self.T2d[i]!.val) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/ConditionalAssign.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ConditionallySelectableProjectiveNielsPoint.conditional_assign`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • a ProjectiveNielsPoint `self` with coordinates (Y_plus_X, Y_minus_X, Z, T2d),\n  • a ProjectiveNielsPoint `other` with coordinates (Y_plus_X', Y_minus_X', Z', T2d'),\n  • a Choice `choice`,\nthe output ProjectiveNielsPoint computed by `conditional_assign self other choice` satisfies:\n- Each coordinate is conditionally selected: if choice is 1, output = other; if choice is 0, output = self\n- The operation is performed in constant time for all field elements\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::conditional_assign",
   "lines": "L306-L311",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.SubtleConditionallySelectable.conditional_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : backend.serial.curve_models.ProjectiveNielsPoint)\n    (choice : subtle.Choice) :\n    conditional_select a b choice ⦃ result =>\n    (∀ i < 5, result.Y_plus_X[i]!.val =\n      if choice.val = 1#u8 then b.Y_plus_X[i]!.val else a.Y_plus_X[i]!.val) ∧\n    (∀ i < 5, result.Y_minus_X[i]!.val =\n      if choice.val = 1#u8 then b.Y_minus_X[i]!.val else a.Y_minus_X[i]!.val) ∧\n    (∀ i < 5, result.Z[i]!.val =\n      if choice.val = 1#u8 then b.Z[i]!.val else a.Z[i]!.val) ∧\n    (∀ i < 5, result.T2d[i]!.val =\n      if choice.val = 1#u8 then b.T2d[i]!.val else a.T2d[i]!.val) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec and proof concerning `backend.serial.curve_models.ProjectiveNielsPoint.conditional_select`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • ProjectiveNielsPoint `a` with coordinates (Y_plus_X, Y_minus_X, Z, T2d),\n  • ProjectiveNielsPoint `b` with coordinates (Y_plus_X', Y_minus_X', Z', T2d'),\n  • a Choice `choice`,\n  the output ProjectiveNielsPoint has coordinates selected component-wise:\n  - If choice = 1, each coordinate equals the corresponding one of `b`\n  - If choice = 0, each coordinate equals the corresponding one of `a`\n  - The operation is constant-time (does not branch on choice)\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::conditional_select",
   "lines": "L297-L304",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl Zeroize for ProjectiveNielsPoint {\n    fn zeroize(&mut self) {\n        self.Y_plus_X.zeroize();\n        self.Y_minus_X.zeroize();\n        self.Z.zeroize();\n        self.T2d.zeroize();\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "lines": "L214-L221",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.ZeroizeZeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn zeroize(&mut self) {\n        self.Y_plus_X.zeroize();\n        self.Y_minus_X.zeroize();\n        self.Z.zeroize();\n        self.T2d.zeroize();\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::zeroize",
   "lines": "L215-L220",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.ZeroizeZeroize.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "impl ValidityCheck for ProjectivePoint {\n    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::ValidityCheck for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}",
   "lines": "L277-L290",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.Insts.Curve25519_dalekTraitsValidityCheck",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectivePoint.Insts.Curve25519_dalekTraitsValidityCheck.is_valid"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::ValidityCheck for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::is_valid",
   "lines": "L278-L289",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.Insts.Curve25519_dalekTraitsValidityCheck.is_valid",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51.eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_extended_spec (q : ProjectivePoint)\n  (h_qX_bounds : ∀ i, i < 5 → (q.X[i]!).val < 2 ^ 54)\n  (h_qY_bounds : ∀ i, i < 5 → (q.Y[i]!).val < 2 ^ 54)\n  (h_qZ_bounds : ∀ i, i < 5 → (q.Z[i]!).val < 2 ^ 54) :\nas_extended q ⦃ e =>\nlet X := Field51_as_Nat q.X\nlet Y := Field51_as_Nat q.Y\nlet Z := Field51_as_Nat q.Z\nlet X' := Field51_as_Nat e.X\nlet Y' := Field51_as_Nat e.Y\nlet Z' := Field51_as_Nat e.Z\nlet T' := Field51_as_Nat e.T\nX' % p = (X * Z) % p ∧\nY' % p = (Y * Z) % p ∧\nZ' % p = (Z^2) % p ∧\nT' % p = (X * Y) % p ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectivePoint/AsExtended.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ProjectivePoint.as_extended`**:\n- No panic (always returns successfully)\n- Given input ProjectivePoint with coordinates (X, Y, Z), the output EdwardsPoint (X', Y', Z', T')\nsatisfies the conversion formulas modulo p:\n- X' ≡ X·Z (mod p)\n- Y' ≡ Y·Z (mod p)\n- Z' ≡ Z² (mod p)\n- T' ≡ X·Y (mod p)\nwhere p = 2^255 - 19\nThese formulas implement the (division-free) conversion from projective ℙ² coordinates to extended\ntwisted Edwards ℙ³ coordinates.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.Z,\n            Y: &self.Y * &self.Z,\n            Z: self.Z.square(),\n            T: &self.X * &self.Y,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::as_extended",
   "lines": "L339-L346",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.as_extended",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem double_spec\n    (q : ProjectivePoint) (hq_valid : q.IsValid) :\n    ∃ c, ProjectivePoint.double q = ok c ∧\n    c.IsValid ∧ c.toPoint = q.toPoint + q.toPoint := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectivePoint/Double.lean",
   "spec_docstring":
   "/--\nVerification of the `double` function.\nThe theorem states that the Rust implementation of point doubling corresponds\nexactly to the mathematical addition of the point to itself (`q + q`) on the Edwards curve.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_source":
   "    pub fn double(&self) -> CompletedPoint {\n        // Double()\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ2 = self.Z.square2();\n        let X_plus_Y = &self.X + &self.Y;\n        let X_plus_Y_sq = X_plus_Y.square();\n        let YY_plus_XX = &YY + &XX;\n        let YY_minus_XX = &YY - &XX;\n\n        CompletedPoint {\n            X: &X_plus_Y_sq - &YY_plus_XX,\n            Y: YY_plus_XX,\n            Z: YY_minus_XX,\n            T: &ZZ2 - &YY_minus_XX,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::double",
   "lines": "L382-L398",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
   "rust_source":
   "pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n    // Now tmp1 = s_63*P in P1xP1 coords\n    // Loop from 62 down to 0 (equivalent to: for i in (0..63).rev())\n    let mut i = 63usize;\n    while i > 0 {\n        i -= 1;\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    tmp1.as_extended()\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::scalar_mul::variable_base::mul",
   "lines": "L11-L51",
   "lean_name": "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.window.LookupTableProjectiveNielsPoint.Insts.CoreConvertFromSharedAEdwardsPoint.from",
    "curve25519_dalek.scalar.Scalar.as_radix_16",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity.identity",
    "curve25519_dalek.window.LookupTable.select",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.Curve25519_dalekTraitsIdentity",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.SubtleConditionallySelectable",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint",
    "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAProjectiveNielsPointCompletedPoint.add",
    "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul_loop",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
   "rust_source":
   "    while i > 0 {\n        i -= 1;\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::scalar_mul::variable_base::mul",
   "lines": "L36-L49",
   "lean_name":
   "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_projective",
    "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended",
    "curve25519_dalek.window.LookupTable.select",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.Curve25519_dalekTraitsIdentity",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.SubtleConditionallySelectable",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.backend.serial.curve_models.ProjectiveNielsPoint.Insts.CoreOpsArithNegProjectiveNielsPoint",
    "curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAProjectiveNielsPointCompletedPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const APLUS2_OVER_FOUR: FieldElement51 =\n    FieldElement51::from_limbs([121666, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::APLUS2_OVER_FOUR",
   "lines": "L108-L109",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const APLUS2_OVER_FOUR: FieldElement51 =\n    FieldElement51::from_limbs([121666, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::APLUS2_OVER_FOUR",
   "lines": "L108-L109",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem ED25519_BASEPOINT_POINT_spec :\n    ED25519_BASEPOINT_POINT.IsValid ∧\n    _root_.L • ED25519_BASEPOINT_POINT.toPoint = 0 ∧ ED25519_BASEPOINT_POINT.toPoint ≠ 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/ED25519_BASEPOINT_POINT.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.ED25519_BASEPOINT_POINT`**:\n    • ED25519_BASEPOINT_POINT is a valid Edwards point (which amongst other things implies that it fulfills the curve equation)\n    • ED25519_BASEPOINT_POINT is of prime order L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub const ED25519_BASEPOINT_POINT: EdwardsPoint = EdwardsPoint {\n    X: FieldElement51::from_limbs([\n        1738742601995546,\n        1146398526822698,\n        2070867633025821,\n        562264141797630,\n        587772402128613,\n    ]),\n    Y: FieldElement51::from_limbs([\n        1801439850948184,\n        1351079888211148,\n        450359962737049,\n        900719925474099,\n        1801439850948198,\n    ]),\n    Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n    T: FieldElement51::from_limbs([\n        1841354044333475,\n        16398895984059,\n        755974180946558,\n        900171276175154,\n        1821297809914039,\n    ]),\n};",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ED25519_BASEPOINT_POINT",
   "lines": "L161-L184",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub const ED25519_BASEPOINT_POINT: EdwardsPoint = EdwardsPoint {\n    X: FieldElement51::from_limbs([\n        1738742601995546,\n        1146398526822698,\n        2070867633025821,\n        562264141797630,\n        587772402128613,\n    ]),\n    Y: FieldElement51::from_limbs([\n        1801439850948184,\n        1351079888211148,\n        450359962737049,\n        900719925474099,\n        1801439850948198,\n    ]),\n    Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n    T: FieldElement51::from_limbs([\n        1841354044333475,\n        16398895984059,\n        755974180946558,\n        900171276175154,\n        1821297809914039,\n    ]),\n};",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ED25519_BASEPOINT_POINT",
   "lines": "L161-L184",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem EDWARDS_D_spec : Field51_as_Nat EDWARDS_D = d := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/EDWARDS_D.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.EDWARDS_D`**:\n- The value of constants.EDWARDS_D when converted to a natural number equals d\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const EDWARDS_D: FieldElement51 = FieldElement51::from_limbs([\n    929955233495203,\n    466365720129213,\n    1662059464998953,\n    2033849074728123,\n    1442794654840575,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D",
   "lines": "L45-L51",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_body"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem EDWARDS_D2_spec : Field51_as_Nat EDWARDS_D2 =  (2 * d) % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/EDWARDS_D2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.EDWARDS_D2`**:\n- The value of constants.EDWARDS_D2 when converted to a natural number equals\n  the canonical (reduced) representation of 2*d (mod p) in [0, p-1].\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const EDWARDS_D2: FieldElement51 = FieldElement51::from_limbs([\n    1859910466990425,\n    932731440258426,\n    1072319116312658,\n    1815898335770999,\n    633789495995903,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D2",
   "lines": "L54-L60",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const EDWARDS_D2: FieldElement51 = FieldElement51::from_limbs([\n    1859910466990425,\n    932731440258426,\n    1072319116312658,\n    1815898335770999,\n    633789495995903,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D2",
   "lines": "L54-L60",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem EDWARDS_D_MINUS_ONE_SQUARED_spec : Field51_as_Nat EDWARDS_D_MINUS_ONE_SQUARED = (d - 1)^2 % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/EDWARDS_D_MINUS_ONE_SQUARED.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED`**:\n- The value of constants.EDWARDS_D_MINUS_ONE_SQUARED when converted to a natural number equals\n  the canonical (reduced) representation of (d - 1)² (mod p) in [0, p-1].\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const EDWARDS_D_MINUS_ONE_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1507062230895904,\n    1572317787530805,\n    683053064812840,\n    317374165784489,\n    1572899562415810,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D_MINUS_ONE_SQUARED",
   "lines": "L72-L78",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const EDWARDS_D_MINUS_ONE_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1507062230895904,\n    1572317787530805,\n    683053064812840,\n    317374165784489,\n    1572899562415810,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D_MINUS_ONE_SQUARED",
   "lines": "L72-L78",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const EDWARDS_D: FieldElement51 = FieldElement51::from_limbs([\n    929955233495203,\n    466365720129213,\n    1662059464998953,\n    2033849074728123,\n    1442794654840575,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D",
   "lines": "L45-L51",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem EIGHT_TORSION_spec :\n    let P := EIGHT_TORSION.val[1]\n    P.IsValid ∧\n    (4 • P.toPoint ≠ 0 ∧ 8 • P.toPoint = 0) ∧\n    ∀ (i : Fin 8), EIGHT_TORSION.val[i].IsValid ∧\n    EIGHT_TORSION.val[i].toPoint = (i : ℕ) • P.toPoint := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/EIGHT_TORSION.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.EIGHT_TORSION`**:\n• P := EIGHT_TORSION[1] is a valid EdwardsPoint\n• P has order eight (this is equivalent to [4]P ≠ 0 and [8]P = 0, because [8]P = 0 implies that the order of P divides 8)\n• For all i ∈ {0,...,7}: EIGHT_TORSION[i] is a valid EdwardsPoint and EIGHT_TORSION[i] = [i]P\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub const EIGHT_TORSION: [EdwardsPoint; 8] = EIGHT_TORSION_INNER_DOC_HIDDEN;",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EIGHT_TORSION",
   "lines": "L194-L194",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub const EIGHT_TORSION_INNER_DOC_HIDDEN: [EdwardsPoint; 8] = [\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            533094393274173,\n            2016890930128738,\n            18285341111199,\n            134597186663265,\n            1486323764102114,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([\n            2251799813685228,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1718705420411056,\n            234908883556509,\n            2233514472574048,\n            2117202627021982,\n            765476049583133,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n];",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EIGHT_TORSION_INNER_DOC_HIDDEN",
   "lines": "L198-L337",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub const EIGHT_TORSION_INNER_DOC_HIDDEN: [EdwardsPoint; 8] = [\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            533094393274173,\n            2016890930128738,\n            18285341111199,\n            134597186663265,\n            1486323764102114,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([\n            2251799813685228,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1718705420411056,\n            234908883556509,\n            2233514472574048,\n            2117202627021982,\n            765476049583133,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n];",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EIGHT_TORSION_INNER_DOC_HIDDEN",
   "lines": "L198-L337",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem INVSQRT_A_MINUS_D_spec :\n    (Field51_as_Nat INVSQRT_A_MINUS_D)^2 * (a - d) % p = 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/INVSQRT_A_MINUS_D.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.INVSQRT_A_MINUS_D`**:\n- Field51_as_Nat(constants.INVSQRT_A_MINUS_D)^2 * (a - d) ≡ 1 (mod p), which is equivalent\n  to Field51_as_Nat(constants.INVSQRT_A_MINUS_D) ≡ 1/sqrt(a-d) (mod p).\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const INVSQRT_A_MINUS_D: FieldElement51 = FieldElement51::from_limbs([\n    278908739862762,\n    821645201101625,\n    8113234426968,\n    1777959178193151,\n    2118520810568447,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::INVSQRT_A_MINUS_D",
   "lines": "L90-L96",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const INVSQRT_A_MINUS_D: FieldElement51 = FieldElement51::from_limbs([\n    278908739862762,\n    821645201101625,\n    8113234426968,\n    1777959178193151,\n    2118520810568447,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::INVSQRT_A_MINUS_D",
   "lines": "L90-L96",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem L_spec : Scalar52_as_Nat L = _root_.L := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/L.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.L`**:\n- The value of constants.L when converted to a natural number equals L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const L: Scalar52 = Scalar52([\n    0x0002631a5cf5d3ed,\n    0x000dea2f79cd6581,\n    0x000000000014def9,\n    0x0000000000000000,\n    0x0000100000000000,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::L",
   "lines": "L127-L133",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.L",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem LFACTOR_spec :\n    (_root_.L * LFACTOR + 1) % (2^52) = 0 ∧\n    0 ≤ LFACTOR.val ∧\n    LFACTOR.val < 2^52 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/LFACTOR.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.LFACTOR`**:\n- The value of LFACTOR satisfies: L * LFACTOR ≡ -1 (mod 2^52)\n- LFACTOR is in the range [0, 2^52 - 1]\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source": "pub(crate) const LFACTOR: u64 = 0x51da312547e1b;",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::LFACTOR",
   "lines": "L136-L136",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.LFACTOR",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MINUS_ONE_spec : Field51_as_Nat MINUS_ONE = p - 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/MINUS_ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.MINUS_ONE`**:\n- The value of constants.MINUS_ONE, when converted to a natural number, equals p − 1\n  (the canonical representative of −1 modulo p in [0, p-1]).\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2251799813685228,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::MINUS_ONE",
   "lines": "L26-L32",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.MINUS_ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.MINUS_ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2251799813685228,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::MINUS_ONE",
   "lines": "L26-L32",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.MINUS_ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MONTGOMERY_A_spec : Field51_as_Nat MONTGOMERY_A = 486662 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/MONTGOMERY_A.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.MONTGOMERY_A`**:\n- The value of constants.MONTGOMERY_A when converted to a natural number equals 486662\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const MONTGOMERY_A: FieldElement51 = FieldElement51::from_limbs([486662, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A",
   "lines": "L114-L114",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_body"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MONTGOMERY_A_NEG_spec :\n    Field51_as_Nat MONTGOMERY_A_NEG + Field51_as_Nat MONTGOMERY_A= p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/MONTGOMERY_A_NEG.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.MONTGOMERY_A_NEG`**:\n- The value of constants.MONTGOMERY_A_NEG when converted to a natural number equals\n  p - 486662 = 57896044618658097711785492504343953926634992332820282019728792003956564333287\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const MONTGOMERY_A_NEG: FieldElement51 = FieldElement51::from_limbs([\n    2251799813198567,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A_NEG",
   "lines": "L118-L124",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const MONTGOMERY_A_NEG: FieldElement51 = FieldElement51::from_limbs([\n    2251799813198567,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A_NEG",
   "lines": "L118-L124",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const MONTGOMERY_A: FieldElement51 = FieldElement51::from_limbs([486662, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A",
   "lines": "L114-L114",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ONE_MINUS_EDWARDS_D_SQUARED_spec : Field51_as_Nat ONE_MINUS_EDWARDS_D_SQUARED = (1 + p - (d^2 % p)) % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/ONE_MINUS_EDWARDS_D_SQUARED.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED`**:\n- The value of constants.ONE_MINUS_EDWARDS_D_SQUARED when converted to a natural number equals\n  the canonical (reduced) representation of (1 - d²) (mod p) in [0, p-1].\n  Note: the extra \" + p\" in the spec theorem is to avoided hitting 0 in the truncated subtraction\n  implemented by Lean.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const ONE_MINUS_EDWARDS_D_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1136626929484150,\n    1998550399581263,\n    496427632559748,\n    118527312129759,\n    45110755273534,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ONE_MINUS_EDWARDS_D_SQUARED",
   "lines": "L63-L69",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const ONE_MINUS_EDWARDS_D_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1136626929484150,\n    1998550399581263,\n    496427632559748,\n    118527312129759,\n    45110755273534,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ONE_MINUS_EDWARDS_D_SQUARED",
   "lines": "L63-L69",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem R_spec : Scalar52_as_Nat R % _root_.L = _root_.R % _root_.L := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/R.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.R`**:\n- The value of constants.R when converted to a natural number is congruent to R modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const R: Scalar52 = Scalar52([\n    0x000f48bd6721e6ed,\n    0x0003bab5ac67e45a,\n    0x000fffffeb35e51b,\n    0x000fffffffffffff,\n    0x00000fffffffffff,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::R",
   "lines": "L139-L145",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.R",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem RR_spec : Scalar52_as_Nat RR % _root_.L = _root_.R ^ 2 % _root_.L := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/RR.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.RR`**:\n- The value of constants.RR when converted to a natural number is congruent to R² modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const RR: Scalar52 = Scalar52([\n    0x0009d265e952d13b,\n    0x000d63c715bea69f,\n    0x0005be65cb687604,\n    0x0003dceec73d217f,\n    0x000009411b7c309a,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::RR",
   "lines": "L148-L154",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.RR",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem SQRT_AD_MINUS_ONE_spec :\n    (Field51_as_Nat SQRT_AD_MINUS_ONE)^2 % p = (a * d - 1) % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/SQRT_AD_MINUS_ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.SQRT_AD_MINUS_ONE`**:\n- Field51_as_Nat(constants.SQRT_AD_MINUS_ONE) is a square root of (a*d - 1) modulo p, i.e.\n  `(Field51_as_Nat constants.SQRT_AD_MINUS_ONE)^2 ≡ (a*d - 1) (mod p)`.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const SQRT_AD_MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2241493124984347,\n    425987919032274,\n    2207028919301688,\n    1220490630685848,\n    974799131293748,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::SQRT_AD_MINUS_ONE",
   "lines": "L81-L87",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const SQRT_AD_MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2241493124984347,\n    425987919032274,\n    2207028919301688,\n    1220490630685848,\n    974799131293748,\n]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::SQRT_AD_MINUS_ONE",
   "lines": "L81-L87",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem SQRT_M1_spec :\n    (Field51_as_Nat SQRT_M1)^2 % p = p - 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/SQRT_M1.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.SQRT_M1`**:\n- Field51_as_Nat(constants.SQRT_M1) ≡ sqrt(-1) (mod p), which is equivalent to\n  Field51_as_Nat(constants.SQRT_M1)^2 ≡ p - 1 (mod p).\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const SQRT_M1: FieldElement51 = FieldElement51::from_limbs([\n    1718705420411056,\n    234908883556509,\n    2233514472574048,\n    2117202627021982,\n    765476049583133,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::SQRT_M1",
   "lines": "L99-L105",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.SQRT_M1_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_source":
   "pub(crate) const SQRT_M1: FieldElement51 = FieldElement51::from_limbs([\n    1718705420411056,\n    234908883556509,\n    2233514472574048,\n    2117202627021982,\n    765476049583133,\n]);",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::SQRT_M1",
   "lines": "L99-L105",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.SQRT_M1_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::clone::Clone for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L42-L42",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::clone::Clone for curve25519_dalek::backend::serial::u64::field::FieldElement51}::clone",
   "lines": "L42-L42",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source": "impl Eq for FieldElement {}",
   "rust_name":
   "curve25519_dalek::field::{core::cmp::Eq for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L83-L83",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "impl PartialEq for FieldElement {\n    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }\n}",
   "rust_name":
   "curve25519_dalek::field::{core::cmp::PartialEq<curve25519_dalek::backend::serial::u64::field::FieldElement51> for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L85-L89",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }",
   "rust_name":
   "curve25519_dalek::field::{core::cmp::PartialEq<curve25519_dalek::backend::serial::u64::field::FieldElement51> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::eq",
   "lines": "L86-L88",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::marker::Copy for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L42-L42",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        let mut i = 0;\n        while i < 5 {\n            self.0[i] += _rhs.0[i];\n            i += 1;\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::AddAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L58-L66",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51.add_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_assign_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 53)\n    (hb : ∀ i < 5, b[i]!.val < 2 ^ 53) :\n    add_assign a b ⦃ result =>\n    (∀ i < 5, (result[i]!).val = (a[i]!).val + (b[i]!).val) ∧\n    (∀ i < 5, result[i]!.val < 2 ^ 54) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/AddAssign.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign`**:\n- Does not overflow when limb sums don't exceed `U64.max`\n- Returns a field element where each limb is the sum of corresponding input limbs\n- Input bounds: both inputs have limbs < 2^53\n- Output bounds: output has limbs < 2^54 -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        let mut i = 0;\n        while i < 5 {\n            self.0[i] += _rhs.0[i];\n            i += 1;\n        }\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::AddAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::add_assign",
   "lines": "L59-L65",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51.add_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51.add_assign_loop"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_assign_loop_spec (a b : Array U64 5#usize) (i : Usize) (hi : i.val ≤ 5)\n    (hab : ∀ j < 5, i.val ≤ j → a[j]!.val + b[j]!.val ≤ U64.max) :\n    add_assign_loop a b i ⦃ a' =>\n    (∀ j < 5, i.val ≤ j → a'[j]!.val = a[j]!.val + b[j]!.val) ∧\n    (∀ j < 5, j < i.val → a'[j]! = a[j]!) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/AddAssign.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign_loop`**:\n- Iterates through limbs adding `b[i]` to `a[i]`\n- Does not overflow if limb sums don't exceed `U64.max`. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "        while i < 5 {\n            self.0[i] += _rhs.0[i];\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::AddAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::add_assign",
   "lines": "L61-L64",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51.add_assign_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51.add_assign_loop.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "        while i < 5 {\n            self.0[i] += _rhs.0[i];\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::AddAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::add_assign",
   "lines": "L61-L64",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithAddAssignSharedAFieldElement51.add_assign_loop.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::MulAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L106-L111",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithMulAssignSharedAFieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithMulAssignSharedAFieldElement51.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::MulAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::mul_assign",
   "lines": "L107-L110",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithMulAssignSharedAFieldElement51.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::SubAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L77-L82",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithSubAssignSharedAFieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithSubAssignSharedAFieldElement51.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::SubAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::sub_assign",
   "lines": "L78-L81",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreOpsArithSubAssignSharedAFieldElement51.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L227-L257",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreMarkerCopy",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_swap"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_assign_spec\n    (self other : backend.serial.u64.field.FieldElement51)\n    (choice : subtle.Choice) :\n    conditional_assign self other choice ⦃ res =>\n      (∀ i < 5,\n        res[i]! = (if choice.val = 1#u8 then other[i]! else self[i]!)) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ConditionalAssign.lean",
   "spec_docstring":
   "/--\n**Spec for `backend.serial.u64.field.FieldElement51.conditional_assign`**:\n- No panic (always returns successfully)\n- For each limb i, the result limb equals `other[i]` when `choice = 1`,\n  and equals `self[i]` when `choice = 0` (constant-time conditional select)\n- Consequently, when `choice = Choice.one`, the whole result equals `other`;\n  when `choice = Choice.zero`, the result equals `self`.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::u64::field::FieldElement51}::conditional_assign",
   "lines": "L250-L256",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : backend.serial.u64.field.FieldElement51)\n    (choice : subtle.Choice) :\n    conditional_select a b choice ⦃ res =>\n      ∀ i < 5,\n        res[i]! = (if choice.val = 1#u8 then b[i]! else a[i]!) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec for `backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select`**:\n- No panic (always returns successfully)\n- For each limb i, the result limb equals `b[i]` when `choice = 1`,\n  and equals `a[i]` when `choice = 0` (constant-time conditional select)\n- Consequently, when `choice = Choice.one`, the whole result equals `b`;\n  when `choice = Choice.zero`, the result equals `a`.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::u64::field::FieldElement51}::conditional_select",
   "lines": "L228-L240",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::u64::field::FieldElement51}::conditional_swap",
   "lines": "L242-L248",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_swap",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "impl ConstantTimeEq for FieldElement {\n    /// Test equality between two `FieldElement`s.  Since the\n    /// internal representation is not canonical, the field elements\n    /// are normalized to wire format before comparison.\n    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }\n}",
   "rust_name":
   "curve25519_dalek::field::{subtle::ConstantTimeEq for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L91-L98",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ct_eq_spec (a b : backend.serial.u64.field.FieldElement51) :\n    ct_eq a b ⦃ c =>\n    (c = Choice.one ↔ a.to_bytes = b.to_bytes ) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/CtEq.lean",
   "spec_docstring":
   "/-- **Spec for `field.ConstantTimeEqFieldElement51.ct_eq`**:\n- No panic (always returns successfully)\n- Returns `Choice.one` iff the canonical encodings (32-byte LE) are equal\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }",
   "rust_name":
   "curve25519_dalek::field::{subtle::ConstantTimeEq for curve25519_dalek::backend::serial::u64::field::FieldElement51}::ct_eq",
   "lines": "L95-L97",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "impl Zeroize for FieldElement51 {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "lines": "L52-L56",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.ZeroizeZeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::field::FieldElement51}::zeroize",
   "lines": "L53-L55",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.ZeroizeZeroize.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MINUS_ONE_spec : Field51_as_Nat MINUS_ONE = p - 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/MINUS_ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.MINUS_ONE`**:\n- The constant, when converted to a natural number, equals 2^255 - 20 (i.e., p - 1)\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n        2251799813685228,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n    ]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::MINUS_ONE",
   "lines": "L269-L275",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n        2251799813685228,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n    ]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::MINUS_ONE",
   "lines": "L269-L275",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ONE_spec : Field51_as_Nat ONE = 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.ONE`**:\n- The constant, when converted to a natural number, equals 1\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub const ONE: FieldElement51 = FieldElement51::from_limbs([1, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ONE",
   "lines": "L267-L267",
   "lean_name": "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub const ONE: FieldElement51 = FieldElement51::from_limbs([1, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ONE",
   "lines": "L267-L267",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ZERO_spec : Field51_as_Nat ZERO = 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ZERO.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.ZERO`**:\n- The constant, when converted to a natural number, equals 0\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub const ZERO: FieldElement51 = FieldElement51::from_limbs([0, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ZERO",
   "lines": "L265-L265",
   "lean_name": "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub const ZERO: FieldElement51 = FieldElement51::from_limbs([0, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ZERO",
   "lines": "L265-L265",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec (self : backend.serial.u64.field.FieldElement51) :\n    as_bytes self ⦃ result =>\n    U8x32_as_Nat result ≡ Field51_as_Nat self [MOD p] ∧\n    U8x32_as_Nat result < p ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.FieldElement51.as_bytes`**:\n\nFunction was deprecated since 4.1.4 and renamed to `to_bytes`. Simply calls the other function. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub fn as_bytes(&self) -> [u8; 32] {\n        self.to_bytes()\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::as_bytes",
   "lines": "L369-L371",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_spec (bytes : Array U8 32#usize) :\n    from_bytes bytes ⦃ result =>\n    Field51_as_Nat result ≡ (U8x32_as_Nat bytes % 2^255) [MOD p] ∧\n    (∀ i < 5, result[i]!.val < 2^51) ∧\n    result.IsValid ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/FromBytes.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub const fn from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        FieldElement51(\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ])\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::from_bytes",
   "lines": "L340-L365",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes.load8_at"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::from_bytes::load8_at",
   "lines": "L341-L350",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes.load8_at",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_limbs_spec (a : Array U64 5#usize) :\n    from_limbs a ⦃ r =>\n    r = a ∧ Field51_as_Nat r = Field51_as_Nat a ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/FromLimbs.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.from_limbs`**:\n- No panic (always returns successfully)\n- The result is identical to the input limbs array\n- The natural number representation of the result equals that of the input\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(limbs)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::from_limbs",
   "lines": "L260-L262",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem negate_spec (r : FieldElement51) (h : ∀ i < 5, r[i]!.val < 2 ^ 54) :\n    negate r ⦃ r_inv =>\n    (Field51_as_Nat r + Field51_as_Nat r_inv) % p = 0 ∧\n    (∀ i < 5, r_inv[i]!.val ≤ 2^51 + (2^13 - 1) * 19) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Negate.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.negate`**:\n- No panic (always returns successfully)\n- The result r_inv represents the additive inverse of the input r in 𝔽_p, i.e.,\n  Field51_as_Nat(r) + Field51_as_Nat(r_inv) ≡ 0 (mod p)\n- All the limbs of the result are small, ≤ 2^(51 + ε)\n- Requires that input limbs of r are bounded to avoid underflow:\n  - Limb 0 must be ≤ 36028797018963664\n  - Limbs 1-4 must be ≤ 36028797018963952\n  To make the theorem more readable we use a single bound for all limbs. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub fn negate(&mut self) {\n        // See commentary in the Sub impl\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.0[0],\n            36028797018963952u64 - self.0[1],\n            36028797018963952u64 - self.0[2],\n            36028797018963952u64 - self.0[3],\n            36028797018963952u64 - self.0[4],\n        ]);\n        self.0 = neg.0;\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::negate",
   "lines": "L278-L288",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.negate",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "\n\ntheorem pow2k_spec (a : Array U64 5#usize) (k : U32) (hk : 0 < k.val)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 54) :\n    pow2k a k ⦃ r =>\n    Field51_as_Nat r ≡ (Field51_as_Nat a)^(2^k.val) [MOD p] ∧\n    (∀ i < 5, r[i]!.val < 2 ^ 52) ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Pow2K.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.pow2k`**:\n- No panic (always returns successfully) when k > 0\n- The result, when converted to a natural number, is congruent to the input raised to the (2^k)-th power modulo p\n- Input bounds: each limb < 2^54\n- Output bounds: each limb < 2^52\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub fn pow2k(&self, mut k: u32) -> FieldElement51 {\n\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n\n        let mut a: [u64; 5] = self.0;\n\n        loop {\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n\n            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n\n            k -= 1;\n            if k == 0 {\n                break;\n            }\n        }\n\n        FieldElement51(a)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow2k",
   "lines": "L462-L567",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow2k::LOW_51_BIT_MASK",
   "lines": "L519-L519",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.LOW_51_BIT_MASK",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.LOW_51_BIT_MASK_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow2k::LOW_51_BIT_MASK",
   "lines": "L519-L519",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.LOW_51_BIT_MASK_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow2k::m",
   "lines": "L468-L470",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.m",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow2k",
   "lines": "L488-L500",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.m",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.LOW_51_BIT_MASK"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem reduce_spec (limbs : Array U64 5#usize) :\n    reduce limbs ⦃ result =>\n    (∀ i < 5, result[i]!.val ≤ 2^51 + (2^13 - 1) * 19) ∧\n    Field51_as_Nat limbs ≡ Field51_as_Nat result [MOD p] ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Reduce.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.reduce`**:\n- Does not overflow and hence returns a result\n- All the limbs of the result are small, ≤ 2^(51 + ε)\n- The result is equal to the input mod p. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::reduce",
   "lines": "L292-L325",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::reduce::LOW_51_BIT_MASK",
   "lines": "L293-L293",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::reduce::LOW_51_BIT_MASK",
   "lines": "L293-L293",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square_spec (a : Array U64 5#usize) (ha : ∀ i < 5, a[i]!.val < 2 ^ 54) :\n    square a ⦃ r =>\n    Field51_as_Nat r ≡ (Field51_as_Nat a)^2 [MOD p] ∧ (∀ i < 5, r[i]!.val < 2 ^ 52) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Square.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.square`**:\n- No panic (always returns successfully)\n- The result, when converted to a natural number, is congruent to the square of the input modulo p\n- Input bounds: each limb < 2^54\n- Output bounds: each limb < 2^52\n- Note: this implements the `pow2k` function with k=1\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub fn square(&self) -> FieldElement51 {\n        self.pow2k(1)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::square",
   "lines": "L570-L572",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square2_spec (a : Array U64 5#usize) (h_bounds : ∀ i < 5, a[i]!.val < 2 ^ 54) :\n    square2 a ⦃ r =>\n    Field51_as_Nat r % p = (2 * (Field51_as_Nat a)^2) % p ∧ (∀ i < 5, r[i]!.val < 2 ^ 53) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Square2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.square2`**:\n- No panic (always returns successfully)\n- The result, when converted to a natural number, is congruent to twice the square of the input modulo p\n- Input bounds: each limb < 2^54\n- Output bounds: each limb < 2^53\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub fn square2(&self) -> FieldElement51 {\n        let mut square = self.pow2k(1);\n        let mut i = 0;\n        while i < 5 {\n            square.0[i] *= 2;\n            i += 1;\n        }\n\n        square\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::square2",
   "lines": "L575-L584",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2_loop"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square2_loop_spec (square : Array U64 5#usize) (i : Usize) (hi : i.val ≤ 5)\n    (h_no_overflow : ∀ j < 5, i.val ≤ j → square[j]!.val * 2 ≤ U64.max) :\n    square2_loop square i ⦃ r =>\n    (∀ j < 5, i.val ≤ j → r[j]!.val = square[j]!.val * 2) ∧\n    (∀ j < 5, j < i.val → r[j]! = square[j]!) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Square2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning the loop in `backend.serial.u64.field.FieldElement51.square2`**:\n- No panic when i ≤ 5\n- Doubles each limb from index i onwards\n- Leaves limbs before index i unchanged\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "        while i < 5 {\n            square.0[i] *= 2;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::square2",
   "lines": "L578-L581",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (self : backend.serial.u64.field.FieldElement51) :\n    to_bytes self ⦃ result =>\n    U8x32_as_Nat result ≡ Field51_as_Nat self [MOD p] ∧\n    U8x32_as_Nat result < p ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.FieldElement51.to_bytes`**:\n\nThis function converts a field element to its canonical 32-byte little-endian representation.\nThe implementation performs reduction modulo p = 2^255-19 to ensure the result is in\ncanonical form.\n\nThe algorithm:\n1. Reduces the field element using `reduce` to ensure all limbs are within bounds\n2. Performs a final conditional reduction to ensure the result is < p\n3. Packs the 5 limbs (each 51 bits) into 32 bytes in little-endian format\n\nSpecification:\n- The function succeeds (no panic)\n- The natural number interpretation of the byte array is congruent to the field element value modulo p\n- The byte array represents the unique canonical form (0 ≤ value < p)\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "    pub fn to_bytes(self) -> [u8; 32] {\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.0).0;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::to_bytes",
   "lines": "L376-L458",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Mul<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::mul::LOW_51_BIT_MASK",
   "lines": "L174-L174",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.LOW_51_BIT_MASK",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.LOW_51_BIT_MASK_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source": "        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Mul<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::mul::LOW_51_BIT_MASK",
   "lines": "L174-L174",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.LOW_51_BIT_MASK_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_source":
   "        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Mul<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::mul::m",
   "lines": "L121-L121",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.m",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::clone::Clone for curve25519_dalek::backend::serial::u64::scalar::Scalar52}",
   "lines": "L25-L25",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::clone::Clone for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::clone",
   "lines": "L25-L25",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::marker::Copy for curve25519_dalek::backend::serial::u64::scalar::Scalar52}",
   "lines": "L25-L25",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "impl IndexMut<usize> for Scalar52 {\n    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.0[_index])\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::IndexMut<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}",
   "lines": "L48-L52",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64.index_mut"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.0[_index])\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::IndexMut<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::index_mut",
   "lines": "L49-L51",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64.index_mut",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "impl Index<usize> for Scalar52 {\n    type Output = u64;\n    fn index(&self, _index: usize) -> &u64 {\n        &(self.0[_index])\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::Index<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}",
   "lines": "L41-L46",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    fn index(&self, _index: usize) -> &u64 {\n        &(self.0[_index])\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::Index<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::index",
   "lines": "L43-L45",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "impl Zeroize for Scalar52 {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::scalar::Scalar52}",
   "lines": "L35-L39",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.ZeroizeZeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::zeroize",
   "lines": "L36-L38",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.ZeroizeZeroize.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ZERO_spec : Scalar52_as_Nat ZERO = 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Zero.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.ZERO`**:\n\nThe ZERO constant represents the scalar 0.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source": "    pub const ZERO: Scalar52 = Scalar52([0, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::ZERO",
   "lines": "L62-L62",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source": "    pub const ZERO: Scalar52 = Scalar52([0, 0, 0, 0, 0]);",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::ZERO",
   "lines": "L62-L62",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec (a b : Scalar52)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 52) (hb : ∀ i < 5, b[i]!.val < 2 ^ 52)\n    (ha' : Scalar52_as_Nat a < L) (hb' : Scalar52_as_Nat b ≤ L) :\n    add a b ⦃ v =>\n    Scalar52_as_Nat v ≡ Scalar52_as_Nat a + Scalar52_as_Nat b [MOD L] ∧\n    Scalar52_as_Nat v < L ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Add.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.add`**:\n- Requires the input values to be bounded by  2 ^ 259\n- The result represents the sum of the two input scalars modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn add(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        let mut sum = Scalar52::ZERO;\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        let mut i = 0;\n        while i < 5 {\n            carry = a[i] + b[i] + (carry >> 52);\n            sum[i] = carry & mask;\n            i += 1;\n        }\n\n        // subtract l if the sum is >= l\n        Scalar52::sub(&sum, &constants::L)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::add",
   "lines": "L177-L192",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
    "curve25519_dalek.backend.serial.u64.constants.L"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_loop_spec (a b sum : Scalar52) (mask carry : U64) (i : Usize)\n    (ha : ∀ j < 5, a[j]!.val < 2 ^ 52) (hb : ∀ j < 5, b[j]!.val < 2 ^ 52)\n    (ha' : Scalar52_as_Nat a < 2 ^ 259) (hb' : Scalar52_as_Nat b < 2 ^ 259)\n    (hmask : mask.val = 2 ^ 52 - 1) (hi : i.val ≤ 5)\n    (hcarry : i.val = 5 → carry.val < 2 ^ 52)\n    (hcarry : ∀ i < 5, carry.val < 2 ^ 53)\n    (hsum : ∀ j < 5, sum[j]!.val < 2 ^ 52)\n    (hsum' : ∀ j < 5, i.val ≤ j → sum[j]!.val = 0) :\n    add_loop a b sum mask carry i ⦃ sum' =>\n    (∀ j < 5, sum'[j]!.val < 2 ^ 52) ∧\n    (∀ j < i.val, sum'[j]!.val = sum[j]!.val) ∧\n    ∑ j ∈ Finset.Ico i.val 5, 2 ^ (52 * j) * sum'[j]!.val =\n      ∑ j ∈ Finset.Ico i.val 5, 2 ^ (52 * j) * (a[j]!.val + b[j]!.val) +\n      2 ^ (52 * i.val) * (carry.val / 2 ^ 52) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Add.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.add_loop`**:\n- Starting from index `i` with accumulator `sum` and carry `carry`\n- Computes limb-wise addition with carry propagation\n- Result limbs are bounded by 2^52\n- Parts of sum before index i are preserved\n- The result satisfies the modular arithmetic property -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        while i < 5 {\n            carry = a[i] + b[i] + (carry >> 52);\n            sum[i] = carry & mask;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::add",
   "lines": "L184-L188",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        while i < 5 {\n            carry = a[i] + b[i] + (carry >> 52);\n            sum[i] = carry & mask;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::add",
   "lines": "L184-L188",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64.index_mut"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_montgomery_spec (u : Scalar52) (h : ∀ i < 5, u[i]!.val < 2 ^ 62) :\n    as_montgomery u ⦃ m =>\n    Scalar52_as_Nat m ≡ (Scalar52_as_Nat u * R) [MOD L] ∧\n    (∀ i < 5, m[i]!.val < 2 ^ 62) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/AsMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.as_montgomery`**:\n- No panic (always returns successfully)\n- The result represents the input scalar multiplied by the Montgomery constant R = 2^260, modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn as_montgomery(&self) -> Scalar52 {\n        Scalar52::montgomery_mul(self, &constants::RR)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::as_montgomery",
   "lines": "L338-L340",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.as_montgomery",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
    "curve25519_dalek.backend.serial.u64.constants.RR"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_add_l_spec (self : Scalar52) (condition : subtle.Choice)\n    (hself : ∀ i < 5, self[i]!.val < 2 ^ 52)\n    (hself' : condition = Choice.one → 2 ^ 260 ≤ Scalar52_as_Nat self + L)\n    (hself'' : condition = Choice.one → Scalar52_as_Nat self < 2 ^ 260)\n    (hself''' : condition = Choice.zero → Scalar52_as_Nat self < L) :\n    conditional_add_l self condition ⦃ result =>\n    (∀ i < 5, result.2[i]!.val < 2 ^ 52) ∧\n    (Scalar52_as_Nat result.2 < L) ∧\n    (condition = Choice.one → Scalar52_as_Nat result.2 + 2 ^ 260 = Scalar52_as_Nat self + L) ∧\n    (condition = Choice.zero → Scalar52_as_Nat result.2 = Scalar52_as_Nat self) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/ConditionalAddL.lean",
   "spec_docstring":
   "/-- **Spec for `scalar.Scalar52.conditional_add_l`** (tailored for use in `sub`):\n- Requires input limbs bounded by 2^52\n- When condition is 1, requires input value in [2^260 - L, 2^260)\n- When condition is 1: result + 2^260 = input + L, with result < L and limbs < 2^52\n- When condition is 0: result unchanged with limbs < 2^52\n- Carry value not specified (not used by sub)\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub(crate) fn conditional_add_l(&mut self, condition: Choice) -> u64 {\n        let mut carry: u64 = 0;\n        let mask = (1u64 << 52) - 1;\n\n        let mut i = 0;\n        while i < 5 {\n            let addend = u64::conditional_select(&0, &constants::L[i], condition);\n            carry = (carry >> 52) + self[i] + addend;\n            self[i] = carry & mask;\n            i += 1;\n        }\n\n        carry\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::conditional_add_l",
   "lines": "L213-L226",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_add_l_loop_spec (self : Scalar52) (condition : subtle.Choice)\n    (carry : U64) (mask : U64) (i : Usize)\n    (hself : ∀ j < 5, self[j]!.val < 2 ^ 52)\n    (hmask : mask.val = 2 ^ 52 - 1) (hi : i.val ≤ 5)\n    (hcarry : carry.val < 2 ^ 53) :\n    conditional_add_l_loop self condition carry mask i ⦃ result =>\n    (∀ j < 5, result.2[j]!.val < 2 ^ 52) ∧\n    (Scalar52_as_Nat result.2 + 2 ^ 260 * (result.1.val / 2 ^ 52) =\n      Scalar52_as_Nat self + (if condition.val = 1#u8 then Scalar52_as_Nat constants.L else 0) +\n      2 ^ (52 * i.val) * (carry.val / 2 ^ 52) -\n      (if condition.val = 1#u8 then ∑ j ∈ Finset.Ico 0 i.val, 2 ^ (52 * j) * constants.L[j]!.val else 0)) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/ConditionalAddL.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source": "        while i < 5 {",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::conditional_add_l",
   "lines": "L218-L218",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source": "        while i < 5 {",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::conditional_add_l",
   "lines": "L218-L218",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
    "curve25519_dalek.backend.serial.u64.constants.L",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64.index_mut"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_spec (b : Array U8 32#usize) :\n    from_bytes b ⦃ u =>\n    Scalar52_as_Nat u = U8x32_as_Nat b ∧\n    ∀ i < 5, u[i]!.val < 2 ^ 52 ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.from_bytes`**:\n- No panic (always returns successfully)\n- The result represents the same number as the input byte array\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn from_bytes(bytes: &[u8; 32]) -> Scalar52 {\n        let mut words = [0u64; 4];\n        let mut i = 0;\n        while i < 4 {\n            let base = i * 8;\n            words[i] = (bytes[base] as u64)\n                | ((bytes[base + 1] as u64) << 8)\n                | ((bytes[base + 2] as u64) << 16)\n                | ((bytes[base + 3] as u64) << 24)\n                | ((bytes[base + 4] as u64) << 32)\n                | ((bytes[base + 5] as u64) << 40)\n                | ((bytes[base + 6] as u64) << 48)\n                | ((bytes[base + 7] as u64) << 56);\n            i += 1;\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52::ZERO;\n\n        s[0] =   words[0]                            & mask;\n        s[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s[4] =  (words[3] >> 16)                     & top_mask;\n\n        s\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes",
   "lines": "L66-L93",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64.index_mut",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        while i < 4 {\n            let base = i * 8;\n            words[i] = (bytes[base] as u64)\n                | ((bytes[base + 1] as u64) << 8)\n                | ((bytes[base + 2] as u64) << 16)\n                | ((bytes[base + 3] as u64) << 24)\n                | ((bytes[base + 4] as u64) << 32)\n                | ((bytes[base + 5] as u64) << 40)\n                | ((bytes[base + 6] as u64) << 48)\n                | ((bytes[base + 7] as u64) << 56);\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes",
   "lines": "L69-L80",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_wide_spec (b : Array U8 64#usize) :\n    from_bytes_wide b ⦃ u =>\n    Scalar52_as_Nat u = U8x64_as_Nat b % L ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromBytesWide.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.from_bytes_wide`**:\n- No panic (always returns successfully)\n- The result represents the input byte array reduced modulo L (canonical form) -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn from_bytes_wide(bytes: &[u8; 64]) -> Scalar52 {\n        let mut words = [0u64; 8];\n        let mut i = 0;\n        while i < 8 {\n            // Explicitly unrolled inner loop - 8 steps\n            words[i] |= (bytes[i * 8] as u64) << (0);\n            words[i] |= (bytes[(i * 8) + 1] as u64) << (8);\n            words[i] |= (bytes[(i * 8) + 2] as u64) << (2 * 8);\n            words[i] |= (bytes[(i * 8) + 3] as u64) << (3 * 8);\n            words[i] |= (bytes[(i * 8) + 4] as u64) << (4 * 8);\n            words[i] |= (bytes[(i * 8) + 5] as u64) << (5 * 8);\n            words[i] |= (bytes[(i * 8) + 6] as u64) << (6 * 8);\n            words[i] |= (bytes[(i * 8) + 7] as u64) << (7 * 8);\n            i += 1;\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52::ZERO;\n        let mut hi = Scalar52::ZERO;\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes_wide",
   "lines": "L97-L132",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64.index_mut",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
    "curve25519_dalek.backend.serial.u64.constants.R",
    "curve25519_dalek.backend.serial.u64.constants.RR",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        while i < 8 {\n            // Explicitly unrolled inner loop - 8 steps\n            words[i] |= (bytes[i * 8] as u64) << (0);\n            words[i] |= (bytes[(i * 8) + 1] as u64) << (8);\n            words[i] |= (bytes[(i * 8) + 2] as u64) << (2 * 8);\n            words[i] |= (bytes[(i * 8) + 3] as u64) << (3 * 8);\n            words[i] |= (bytes[(i * 8) + 4] as u64) << (4 * 8);\n            words[i] |= (bytes[(i * 8) + 5] as u64) << (5 * 8);\n            words[i] |= (bytes[(i * 8) + 6] as u64) << (6 * 8);\n            words[i] |= (bytes[(i * 8) + 7] as u64) << (7 * 8);\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes_wide",
   "lines": "L100-L111",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_montgomery_spec (self : Scalar52)\n    (h_bounds : ∀ i < 5, self[i]!.val < 2 ^ 62) :\n    from_montgomery self ⦃ u =>\n    (Scalar52_as_Nat u * R) % L = Scalar52_as_Nat self % L ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.from_montgomery`**:\n- No panic (always returns successfully)\n- The result represents the input scalar divided by the Montgomery constant R = 2^260, modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn from_montgomery(&self) -> Scalar52 {\n        let mut limbs = [0u128; 9];\n        let mut i = 0;\n        while i < 5 {\n            limbs[i] = self[i] as u128;\n            i += 1;\n        }\n        Scalar52::montgomery_reduce(&limbs)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_montgomery",
   "lines": "L345-L353",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_montgomery_loop_spec (self : Scalar52) (limbs : Array U128 9#usize) (i : Usize)\n    (hi : i.val ≤ 5) :\n    from_montgomery_loop self limbs i ⦃ result =>\n    (∀ j < 5, i.val ≤ j → result[j]! = UScalar.cast .U128 self[j]!) ∧\n    (∀ j < 9, 5 ≤ j → result[j]! = limbs[j]!) ∧\n    (∀ j < i.val, result[j]! = limbs[j]!) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `from_montgomery_loop`**:\n- Specification for the loop that copies limbs from a Scalar52 (5 × U64) into a 9-element U128 array\n- Ensures that:\n  - The loop always succeeds (no panic)\n  - Limbs at indices [i, 5) are copied from the input Scalar52 to the result array\n  - Limbs at indices [5, 9) remain unchanged from the input limbs array\n  - Limbs at indices [0, i) remain unchanged from the input limbs array\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        while i < 5 {\n            limbs[i] = self[i] as u128;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_montgomery",
   "lines": "L348-L351",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem montgomery_mul_spec (m m' : Scalar52)\n    (hm : ∀ i < 5, m[i]!.val < 2 ^ 62) (hm' : ∀ i < 5, m'[i]!.val < 2 ^ 62) :\n    montgomery_mul m m' ⦃ w =>\n    (Scalar52_as_Nat m * Scalar52_as_Nat m') ≡ (Scalar52_as_Nat w * R) [MOD L] ∧\n    (∀ i < 5, w[i]!.val < 2 ^ 62) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomeryMul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_mul`**:\n- No panic (always returns successfully)\n- The result w satisfies the Montgomery multiplication property:\n  (m * m') ≡ w * R (mod L), where R = 2^260 is the Montgomery constant\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_mul",
   "lines": "L326-L328",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem montgomery_reduce_spec (a : Array U128 9#usize)\n    (h_bounds : ∀ i < 9, a[i]!.val < 2 ^ 127) :\n    montgomery_reduce a ⦃ m =>\n    (Scalar52_as_Nat m * R) % L = Scalar52_wide_as_Nat a % L ∧\n    (∀ i < 5, m[i]!.val < 2 ^ 52) ∧\n    (Scalar52_as_Nat m < L) ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomeryReduce.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_reduce`**:\n- No panic (always returns successfully)\n- The result m satisfies the Montgomery reduction property:\n  m * R ≡ a (mod L), where R = 2^260 is the Montgomery constant\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {\n\n        #[inline(always)]\n        fn part1(sum: u128) -> (u128, u64) {\n            let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n            ((sum + m(p, constants::L[0])) >> 52, p)\n        }\n\n        #[inline(always)]\n        fn part2(sum: u128) -> (u128, u64) {\n            let w = (sum as u64) & ((1u64 << 52) - 1);\n            (sum >> 52, w)\n        }\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = part1(        limbs[0]);\n        let (carry, n1) = part1(carry + limbs[1] + m(n0, l[1]));\n        let (carry, n2) = part1(carry + limbs[2] + m(n0, l[2]) + m(n1, l[1]));\n        let (carry, n3) = part1(carry + limbs[3]               + m(n1, l[2]) + m(n2, l[1]));\n        let (carry, n4) = part1(carry + limbs[4] + m(n0, l[4])               + m(n2, l[2]) + m(n3, l[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = part2(carry + limbs[5]               + m(n1, l[4])               + m(n3, l[2])   + m(n4, l[1]));\n        let (carry, r1) = part2(carry + limbs[6]                             + m(n2,l[4])                  + m(n4, l[2]));\n        let (carry, r2) = part2(carry + limbs[7]                                           + m(n3, l[4])                );\n        let (carry, r3) = part2(carry + limbs[8]                                                           + m(n4, l[4]));\n        let         r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52([r0, r1, r2, r3, r4]), l)\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_reduce",
   "lines": "L274-L307",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce.part1",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
    "curve25519_dalek.backend.serial.u64.constants.L",
    "curve25519_dalek.backend.serial.u64.scalar.m",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce.part2",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        fn part1(sum: u128) -> (u128, u64) {\n            let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n            ((sum + m(p, constants::L[0])) >> 52, p)\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_reduce::part1",
   "lines": "L277-L280",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce.part1",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.LFACTOR",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
    "curve25519_dalek.backend.serial.u64.constants.L",
    "curve25519_dalek.backend.serial.u64.scalar.m"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        fn part2(sum: u128) -> (u128, u64) {\n            let w = (sum as u64) & ((1u64 << 52) - 1);\n            (sum >> 52, w)\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_reduce::part2",
   "lines": "L283-L286",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce.part2",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem montgomery_square_spec (m : Scalar52) (hm : ∀ i < 5, m[i]!.val < 2 ^ 62) :\n    montgomery_square m ⦃ w =>\n    (Scalar52_as_Nat m * Scalar52_as_Nat m) % L = (Scalar52_as_Nat w * R) % L ∧\n    (∀ i < 5, w[i]!.val < 2 ^ 62) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomerySquare.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_square`**:\n- No panic (always returns successfully)\n- The result w satisfies the Montgomery squaring property:\n  (m * m) ≡ w * R (mod L), where R = 2^260 is the Montgomery constant\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn montgomery_square(&self) -> Scalar52 {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_square",
   "lines": "L332-L334",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_square",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.square_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn mul(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::mul",
   "lines": "L311-L314",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.backend.serial.u64.constants.RR"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_internal_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 62) (hb : ∀ i < 5, b[i]!.val < 2 ^ 62) :\n    mul_internal a b ⦃ result =>\n    Scalar52_wide_as_Nat result = Scalar52_as_Nat a * Scalar52_as_Nat b ∧\n    (∀ i < 9, result[i]!.val < 2 ^ 127) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MulInternal.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.mul_internal`**:\n- Does not error and hence returns a result\n- The result represents the product of the two input field elements\n- Requires that each input limb is at most 62 bits to prevent overflow -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9] {\n        let mut z = [0u128; 9];\n\n        z[0] = m(a[0], b[0]);\n        z[1] = m(a[0], b[1]) + m(a[1], b[0]);\n        z[2] = m(a[0], b[2]) + m(a[1], b[1]) + m(a[2], b[0]);\n        z[3] = m(a[0], b[3]) + m(a[1], b[2]) + m(a[2], b[1]) + m(a[3], b[0]);\n        z[4] = m(a[0], b[4]) + m(a[1], b[3]) + m(a[2], b[2]) + m(a[3], b[1]) + m(a[4], b[0]);\n        z[5] =                 m(a[1], b[4]) + m(a[2], b[3]) + m(a[3], b[2]) + m(a[4], b[1]);\n        z[6] =                                 m(a[2], b[4]) + m(a[3], b[3]) + m(a[4], b[2]);\n        z[7] =                                                 m(a[3], b[4]) + m(a[4], b[3]);\n        z[8] =                                                                 m(a[4], b[4]);\n\n        z\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::mul_internal",
   "lines": "L231-L245",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
    "curve25519_dalek.backend.serial.u64.scalar.m"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn square(&self) -> Scalar52 {\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::square",
   "lines": "L319-L322",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.square",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.square_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.constants.RR"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square_internal_spec (a : Array U64 5#usize) (ha : ∀ i, i < 5 → (a[i]!).val < 2 ^ 62) :\n    square_internal a ⦃ result =>\n    Scalar52_wide_as_Nat result = Scalar52_as_Nat a * Scalar52_as_Nat a ∧\n    (∀ i < 9, result[i]!.val < 2 ^ 127) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/SquareInternal.lean",
   "spec_docstring":
   "/-- **Spec for `square_internal`**:\n- Does not error and hence returns a result\n- The result represents the square of the input field element\n- Requires each limb to be less than 62 bits to prevent overflow\n(The optimal bound on the limbs is 2^64 / √5  ≈ 2^62.839) -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    fn square_internal(a: &Scalar52) -> [u128; 9] {\n        let aa = [\n            a[0] * 2,\n            a[1] * 2,\n            a[2] * 2,\n            a[3] * 2,\n        ];\n\n        [\n            m( a[0], a[0]),\n            m(aa[0], a[1]),\n            m(aa[0], a[2]) + m( a[1], a[1]),\n            m(aa[0], a[3]) + m(aa[1], a[2]),\n            m(aa[0], a[4]) + m(aa[1], a[3]) + m( a[2], a[2]),\n                             m(aa[1], a[4]) + m(aa[2], a[3]),\n                                              m(aa[2], a[4]) + m( a[3], a[3]),\n                                                               m(aa[3], a[4]),\n                                                                                m(a[4], a[4])\n        ]\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::square_internal",
   "lines": "L250-L269",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.square_internal",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
    "curve25519_dalek.backend.serial.u64.scalar.m"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 52)\n    (hb : ∀ i < 5, b[i]!.val < 2 ^ 52)\n    (ha' : Scalar52_as_Nat a < Scalar52_as_Nat b + L)\n    (hb' : Scalar52_as_Nat b ≤ L) :\n    sub a b ⦃ result =>\n    Scalar52_as_Nat result + Scalar52_as_Nat b ≡ Scalar52_as_Nat a [MOD L] ∧\n    Scalar52_as_Nat result < L ∧\n    (∀ i < 5, result[i]!.val < 2 ^ 52) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Sub.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.sub`**:\n- Requires bounded limbs for both inputs\n- Requires both inputs to be bounded from above\n- The result represents (a - b) mod L\n- The result has bounded limbs and is canonical -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn sub(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        let mut difference = Scalar52::ZERO;\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        let mut i = 0;\n        while i < 5 {\n            borrow = a[i].wrapping_sub(b[i] + (borrow >> 63));\n            difference[i] = borrow & mask;\n            i += 1;\n        }\n\n        // conditionally add l if the difference is negative\n        difference.conditional_add_l(Choice::from((borrow >> 63) as u8));\n        difference\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::sub",
   "lines": "L195-L211",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_loop_spec (a b difference : Scalar52) (mask borrow : U64) (i : Usize)\n    (ha : ∀ j < 5, a[j]!.val < 2 ^ 52)\n    (hb : ∀ j < 5, b[j]!.val < 2 ^ 52)\n    (hdiff : ∀ j < i.val, difference[j]!.val < 2 ^ 52)\n    (hdiff_rest : ∀ j, i.val ≤ j → j < 5 → difference[j]!.val = 0)\n    (hmask : mask.val = 2 ^ 52 - 1)\n    (hi : i.val ≤ 5)\n    (hborrow : borrow.val / 2 ^ 63 ≤ 1)\n    (hinv : Scalar52_partial_as_Nat a i.val + borrow.val / 2 ^ 63 * 2 ^ (52 * i.val) =\n            Scalar52_partial_as_Nat b i.val + Scalar52_partial_as_Nat difference i.val) :\n    sub_loop a b difference mask borrow i ⦃ result =>\n    (∀ j < 5, result.1[j]!.val < 2 ^ 52) ∧\n    (Scalar52_as_Nat a + result.2.val / 2 ^ 63 * 2 ^ 260 =\n     Scalar52_as_Nat b + Scalar52_as_Nat result.1) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Sub.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.sub_loop`**:\n\nThe loop computes the subtraction a - b with borrow propagation.\nAfter processing indices 0..i, the loop invariant holds:\n  partial_a(i) + (borrow / 2^63) * 2^(52*i) = partial_b(i) + partial_diff(i)\n\nWhen the loop completes (i = 5), this gives:\n  A + (borrow / 2^63) * 2^260 = B + D\n\nWhere (borrow / 2^63) = 1 means A < B (underflow occurred), and the difference D\nrepresents (A - B) mod 2^260.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        while i < 5 {\n            borrow = a[i].wrapping_sub(b[i] + (borrow >> 63));\n            difference[i] = borrow & mask;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::sub",
   "lines": "L202-L206",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "        while i < 5 {\n            borrow = a[i].wrapping_sub(b[i] + (borrow >> 63));\n            difference[i] = borrow & mask;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::sub",
   "lines": "L202-L206",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexUsizeU64.index",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreOpsIndexIndexMutUsizeU64.index_mut"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (u : Scalar52) :\n    to_bytes u ⦃ b =>\n    U8x32_as_Nat b ≡ Scalar52_as_Nat u [MOD L] ∧\n    U8x32_as_Nat b < L ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.to_bytes`**:\n- No panic (always returns successfully)\n- The result byte array represents the same number as the input unpacked scalar modulo L\n- The result is in canonical form (less than L) -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "    pub fn to_bytes(self) -> [u8; 32] {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.0[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.0[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.0[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.0[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.0[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.0[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.0[ 0] >> 48) | (self.0[ 1] << 4)) as u8;\n        s[ 7] =  (self.0[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.0[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.0[ 1] >> 20)                      as u8;\n        s[10] =  (self.0[ 1] >> 28)                      as u8;\n        s[11] =  (self.0[ 1] >> 36)                      as u8;\n        s[12] =  (self.0[ 1] >> 44)                      as u8;\n        s[13] =  (self.0[ 2] >>  0)                      as u8;\n        s[14] =  (self.0[ 2] >>  8)                      as u8;\n        s[15] =  (self.0[ 2] >> 16)                      as u8;\n        s[16] =  (self.0[ 2] >> 24)                      as u8;\n        s[17] =  (self.0[ 2] >> 32)                      as u8;\n        s[18] =  (self.0[ 2] >> 40)                      as u8;\n        s[19] = ((self.0[ 2] >> 48) | (self.0[ 3] << 4)) as u8;\n        s[20] =  (self.0[ 3] >>  4)                      as u8;\n        s[21] =  (self.0[ 3] >> 12)                      as u8;\n        s[22] =  (self.0[ 3] >> 20)                      as u8;\n        s[23] =  (self.0[ 3] >> 28)                      as u8;\n        s[24] =  (self.0[ 3] >> 36)                      as u8;\n        s[25] =  (self.0[ 3] >> 44)                      as u8;\n        s[26] =  (self.0[ 4] >>  0)                      as u8;\n        s[27] =  (self.0[ 4] >>  8)                      as u8;\n        s[28] =  (self.0[ 4] >> 16)                      as u8;\n        s[29] =  (self.0[ 4] >> 24)                      as u8;\n        s[30] =  (self.0[ 4] >> 32)                      as u8;\n        s[31] =  (self.0[ 4] >> 40)                      as u8;\n\n        s\n    }",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::to_bytes",
   "lines": "L137-L174",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem m_spec (x y : U64) :\n    m x y ⦃ result =>\n    result.val = x.val * y.val ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/M.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.m`**:\n- Does not overflow and hence returns a result\n- The result equals the product of the two input values -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_source":
   "fn m(x: u64, y: u64) -> u128 {\n    (x as u128) * (y as u128)\n}",
   "rust_name": "curve25519_dalek::backend::serial::u64::scalar::m",
   "lines": "L56-L58",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.m",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/mod.rs",
   "rust_source":
   "pub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}",
   "rust_name": "curve25519_dalek::backend::variable_base_mul",
   "lines": "L253-L263",
   "lean_name": "curve25519_dalek.backend.variable_base_mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.get_selected_backend",
    "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/constants.rs",
   "rust_source":
   "pub(crate) const BASEPOINT_ORDER_PRIVATE: Scalar = Scalar {\n    bytes: [\n        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde,\n        0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x10,\n    ],\n};",
   "rust_name": "curve25519_dalek::constants::BASEPOINT_ORDER_PRIVATE",
   "lines": "L75-L81",
   "lean_name": "curve25519_dalek.constants.BASEPOINT_ORDER_PRIVATE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem RISTRETTO_BASEPOINT_POINT_spec :\n    RISTRETTO_BASEPOINT_POINT = backend.serial.u64.constants.ED25519_BASEPOINT_POINT ∧\n    RISTRETTO_BASEPOINT_POINT.IsValid ∧\n    4 • RISTRETTO_BASEPOINT_POINT.toPoint ≠ 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Constants/RISTRETTO_BASEPOINT_POINT.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `constants.RISTRETTO_BASEPOINT_POINT`**:\n    • constants.RISTRETTO_BASEPOINT_POINT is a valid RistrettoPoint (which amongst other things\n      implies that it fulfills the curve equation)\n    • constants.RISTRETTO_BASEPOINT_POINT has the same representation as the Edwards basepoint\n    • constants.RISTRETTO_BASEPOINT_POINT is not the identity point (i.e., the EdwardsPoint representing the\n      basepoint is not in the same Ristretto equivalence class as the EdwardsPoint identity point, which\n      is equivalent to saying that the difference between both points is not in E[4])\n-/",
   "source": "curve25519-dalek/src/constants.rs",
   "rust_source":
   "pub const RISTRETTO_BASEPOINT_POINT: RistrettoPoint = RistrettoPoint(ED25519_BASEPOINT_POINT);",
   "rust_name": "curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT",
   "lines": "L66-L66",
   "lean_name": "curve25519_dalek.constants.RISTRETTO_BASEPOINT_POINT",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::clone::Clone for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L171-L171",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::clone::Clone for curve25519_dalek::edwards::CompressedEdwardsY}::clone",
   "lines": "L171-L171",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::cmp::Eq for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L171-L171",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCmpPartialEqCompressedEdwardsY",
    "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCmpEq.assert_receiver_is_total_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::cmp::Eq for curve25519_dalek::edwards::CompressedEdwardsY}::assert_receiver_is_total_eq",
   "lines": "L171-L171",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCmpEq.assert_receiver_is_total_eq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::cmp::PartialEq<curve25519_dalek::edwards::CompressedEdwardsY> for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L171-L171",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCmpPartialEqCompressedEdwardsY",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCmpPartialEqCompressedEdwardsY.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::cmp::PartialEq<curve25519_dalek::edwards::CompressedEdwardsY> for curve25519_dalek::edwards::CompressedEdwardsY}::eq",
   "lines": "L171-L171",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCmpPartialEqCompressedEdwardsY.eq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl TryFrom<&[u8]> for CompressedEdwardsY {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }\n}",
   "rust_name": "curve25519_dalek::edwards::{core::convert::TryFrom<&0 (",
   "lines": "L251-L257",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreConvertTryFromShared0SliceU8TryFromSliceError",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreConvertTryFromShared0SliceU8TryFromSliceError.try_from"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
   "rust_name": "curve25519_dalek::edwards::{core::convert::TryFrom<&0 (",
   "lines": "L254-L256",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreConvertTryFromShared0SliceU8TryFromSliceError.try_from",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.edwards.CompressedEdwardsY.from_slice"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl Default for CompressedEdwardsY {\n    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::default::Default for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L401-L405",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::default::Default for curve25519_dalek::edwards::CompressedEdwardsY}::default",
   "lines": "L402-L404",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::marker::Copy for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L171-L171",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::marker::StructuralPartialEq for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L171-L171",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.CoreMarkerStructuralPartialEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl Identity for CompressedEdwardsY {\n    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L392-L399",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::CompressedEdwardsY}::identity",
   "lines": "L393-L398",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl ConstantTimeEq for CompressedEdwardsY {\n    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{subtle::ConstantTimeEq for curve25519_dalek::edwards::CompressedEdwardsY}",
   "lines": "L174-L178",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{subtle::ConstantTimeEq for curve25519_dalek::edwards::CompressedEdwardsY}::ct_eq",
   "lines": "L175-L177",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.edwards.CompressedEdwardsY.as_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec\n    (self : edwards.CompressedEdwardsY) :\n    as_bytes self ⦃ result =>\n    result = self ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/CompressedEdwardsY/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec for `edwards.CompressedEdwardsY.as_bytes`**:\n- The function succeeds (always returns `ok`)\n- The result is exactly the internal byte array representation.\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::as_bytes",
   "lines": "L188-L190",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem decompress_spec (cey : edwards.CompressedEdwardsY) :\n    edwards.CompressedEdwardsY.decompress cey ⦃ result =>\n\n      (∀ ep, result = some ep →\n        let y_encoded := (U8x32_as_Nat cey) % (2^255)\n        let x_sign_bit := cey[31]!.val.testBit 7\n\n        (∃ Z_inv x_val y_val x_is_neg,\n          field.FieldElement51.invert ep.Z = ok Z_inv ∧\n          (Field51_as_Nat ep.X * Field51_as_Nat Z_inv) % p = x_val ∧\n          (Field51_as_Nat ep.Y * Field51_as_Nat Z_inv) % p = y_val ∧\n          field.FieldElement51.is_negative ep.X = ok x_is_neg ∧\n\n          (y_val * y_val % p = (x_val * x_val + 1 + d * x_val * x_val * y_val * y_val) % p) ∧\n\n          y_val % p = y_encoded % p ∧\n\n          (x_sign_bit ↔ x_is_neg.val = 1#u8) ∧\n\n          (Field51_as_Nat ep.T % p = (Field51_as_Nat ep.X * Field51_as_Nat ep.Y) % p))) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Edwards/CompressedEdwardsY/Decompress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.CompressedEdwardsY.decompress`**:\n- No panic (always returns successfully)\n- If the function returns Some(ep) with ep = (X, Y, Z, T), then:\n  - The affine coordinates (x,y) where x = X/Z and y = Y/Z satisfy the curve equation\n    ax² + y² = 1 + dx²y² (mod p)\n  - y equals the y-coordinate encoded in the input byte array (bytes 0-30 and low 7 bits of byte 31)\n  - The sign (parity) of x matches the high bit of byte 31 in the input byte array\n  - T = X * Y (mod p)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn decompress(&self) -> Option<EdwardsPoint> {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        if is_valid_y_coord.into() {\n            Some(decompress::step_2(self, X, Y, Z))\n        } else {\n            None\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::decompress",
   "lines": "L201-L209",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.decompress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.decompress.step_1",
    "curve25519_dalek.edwards.decompress.step_2"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        #[allow(clippy::redundant_closure)]\n        bytes.try_into().map(|b| CompressedEdwardsY(b))\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::from_slice",
   "lines": "L414-L417",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.from_slice",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedEdwardsY"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "        bytes.try_into().map(|b| CompressedEdwardsY(b))",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::from_slice::{core::ops::function::FnOnce<(",
   "lines": "L416-L416",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedEdwardsY",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedEdwardsY.call_once"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "        bytes.try_into().map(|b| CompressedEdwardsY(b))",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::from_slice::{core::ops::function::FnOnce<(",
   "lines": "L416-L416",
   "lean_name":
   "curve25519_dalek.edwards.CompressedEdwardsY.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedEdwardsY.call_once",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::to_bytes",
   "lines": "L193-L195",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.to_bytes",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::clone::Clone for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L379-L379",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::clone::Clone for curve25519_dalek::edwards::EdwardsPoint}::clone",
   "lines": "L379-L379",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "impl Eq for EdwardsPoint {}",
   "rust_name":
   "curve25519_dalek::edwards::{core::cmp::Eq for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L512-L512",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCmpPartialEqEdwardsPoint"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl PartialEq for EdwardsPoint {\n    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::cmp::PartialEq<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L506-L510",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCmpPartialEqEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCmpPartialEqEdwardsPoint.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::cmp::PartialEq<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::eq",
   "lines": "L507-L509",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCmpPartialEqEdwardsPoint.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl Default for EdwardsPoint {\n    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::default::Default for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L431-L435",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::default::Default for curve25519_dalek::edwards::EdwardsPoint}::default",
   "lines": "L432-L434",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::edwards::{core::marker::Copy for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L379-L379",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl AddAssign<$rhs> for $lhs {\n            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::AddAssign<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L43-L47",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddAssignEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddAssignEdwardsPoint.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::AddAssign<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::add_assign",
   "lines": "L44-L46",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddAssignEdwardsPoint.add_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddAssignSharedAEdwardsPoint.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl<'a> AddAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::AddAssign<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L767-L771",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddAssignSharedAEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddAssignSharedAEdwardsPoint.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::AddAssign<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::edwards::EdwardsPoint}::add_assign",
   "lines": "L768-L770",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddAssignSharedAEdwardsPoint.add_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Add<$rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L31-L36",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem add_spec (self other : EdwardsPoint) (h_self_valid : self.IsValid) (h_other_valid : other.IsValid) :\n    add self other ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = self.toPoint + other.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Add.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.AddEdwardsPointEdwardsPointEdwardsPoint.add`**:\n• The function always succeeds (no panic) for valid inputs\n• The result is a valid Edwards point\n• The result represents the sum of the inputs (in the context of elliptic curve addition)\n-/",
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::add",
   "lines": "L33-L35",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Add<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<&'b (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L17-L22",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddSharedBEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddSharedBEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<&'b (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::add",
   "lines": "L19-L21",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddSharedBEdwardsPointEdwardsPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl MulAssign<$rhs> for $lhs {\n            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L117-L121",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulAssignScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulAssignScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::edwards::EdwardsPoint}::mul_assign",
   "lines": "L118-L120",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulAssignScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl<'a> MulAssign<&'a Scalar> for EdwardsPoint {\n    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::MulAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L837-L842",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulAssignSharedAScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::MulAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::edwards::EdwardsPoint}::mul_assign",
   "lines": "L838-L841",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L105-L110",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::mul",
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L91-L96",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulSharedBScalarEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulSharedBScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::mul",
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulSharedBScalarEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithMulSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl Neg for EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        -&self\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Neg<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L825-L831",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source": "    fn neg(self) -> EdwardsPoint {\n        -&self\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Neg<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::neg",
   "lines": "L828-L830",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint.neg",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithNegEdwardsPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl SubAssign<$rhs> for $lhs {\n            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::SubAssign<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L80-L84",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubAssignEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubAssignEdwardsPoint.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::SubAssign<curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::sub_assign",
   "lines": "L81-L83",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubAssignEdwardsPoint.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubAssignSharedAEdwardsPoint.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl<'a> SubAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::SubAssign<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L788-L792",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubAssignSharedAEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubAssignSharedAEdwardsPoint.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::SubAssign<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::edwards::EdwardsPoint}::sub_assign",
   "lines": "L789-L791",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubAssignSharedAEdwardsPoint.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Sub<$rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L68-L73",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::sub",
   "lines": "L70-L72",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubEdwardsPointEdwardsPoint.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Sub<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<&'b (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L54-L59",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubSharedBEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubSharedBEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Sub<&'b (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::sub",
   "lines": "L56-L58",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithSubSharedBEdwardsPointEdwardsPoint.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithSubSharedAEdwardsPointEdwardsPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl Identity for EdwardsPoint {\n    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L420-L429",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    spec identity (fun q =>\n    q.X = ZERO ∧ q.Y = ONE ∧ q.Z = ONE ∧ q.T = ZERO) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity.identity`**:\n- No panic (always returns successfully)\n- The resulting EdwardsPoint is the identity element with coordinates (X=0, Y=1, Z=1, T=0)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::EdwardsPoint}::identity",
   "lines": "L421-L428",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl ValidityCheck for EdwardsPoint {\n    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::ValidityCheck for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L465-L472",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsValidityCheck",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsValidityCheck.is_valid"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::ValidityCheck for curve25519_dalek::edwards::EdwardsPoint}::is_valid",
   "lines": "L466-L471",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsValidityCheck.is_valid",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective",
    "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.Insts.Curve25519_dalekTraitsValidityCheck.is_valid",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl ConditionallySelectable for EdwardsPoint {\n    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{subtle::ConditionallySelectable for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L478-L487",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{subtle::ConditionallySelectable for curve25519_dalek::edwards::EdwardsPoint}::conditional_select",
   "lines": "L479-L486",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "impl ConstantTimeEq for EdwardsPoint {\n    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::{subtle::ConstantTimeEq for curve25519_dalek::edwards::EdwardsPoint}",
   "lines": "L493-L504",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem ct_eq_spec (e1 e2 : EdwardsPoint)\n  -- Bounds are needed for the internal field multiplications\n  (h_e1_X : ∀ i, i < 5 → e1.X.val[i]!.val ≤ 2 ^ 53)\n  (h_e1_Y : ∀ i, i < 5 → e1.Y.val[i]!.val ≤ 2 ^ 53)\n  (h_e1_Z : ∀ i, i < 5 → e1.Z.val[i]!.val ≤ 2 ^ 53)\n  (h_e2_X : ∀ i, i < 5 → e2.X.val[i]!.val ≤ 2 ^ 53)\n  (h_e2_Y : ∀ i, i < 5 → e2.Y.val[i]!.val ≤ 2 ^ 53)\n  (h_e2_Z : ∀ i, i < 5 → e2.Z.val[i]!.val ≤ 2 ^ 53) :\n  ct_eq e1 e2 ⦃ c =>\n  (c = Choice.one ↔\n    (Field51_as_Nat e1.X * Field51_as_Nat e2.Z) ≡ (Field51_as_Nat e2.X * Field51_as_Nat e1.Z) [MOD p] ∧\n    (Field51_as_Nat e1.Y * Field51_as_Nat e2.Z) ≡ (Field51_as_Nat e2.Y * Field51_as_Nat e1.Z) [MOD p]) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/CtEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.ConstantTimeEqEdwardsPoint.ct_eq`**:\n- No panic (always returns successfully)\n- The result is Choice.one (true) if and only if the two points are equal (mod p) in affine coordinates\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{subtle::ConstantTimeEq for curve25519_dalek::edwards::EdwardsPoint}::ct_eq",
   "lines": "L494-L503",
   "lean_name":
   "curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(crate) fn as_affine_niels(&self) -> AffineNielsPoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let xy2d = &(&x * &y) * &constants::EDWARDS_D2;\n        AffineNielsPoint {\n            y_plus_x: &y + &x,\n            y_minus_x: &y - &x,\n            xy2d,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::as_affine_niels",
   "lines": "L543-L553",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.as_affine_niels",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_projective_spec (e : EdwardsPoint) :\n    edwards.EdwardsPoint.as_projective e ⦃ q =>\n    q.X = e.X ∧ q.Y = e.Y ∧ q.Z = e.Z ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/AsProjective.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.as_projective`**:\n- No panic (always returns successfully)\n- The resulting ProjectivePoint coordinates match the EdwardsPoint coordinates (X, Y, Z)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::as_projective",
   "lines": "L533-L539",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.as_projective",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_projective_niels_spec (e : EdwardsPoint)\n    (h_bounds : ∀ i < 5, e.X[i]!.val < 2 ^ 53 ∧ e.Y[i]!.val < 2 ^ 53 ∧\n      e.Z[i]!.val < 2 ^ 53 ∧ e.T[i]!.val < 2 ^ 53) :\n    as_projective_niels e ⦃ pn =>\n    let X := Field51_as_Nat e.X\n    let Y := Field51_as_Nat e.Y\n    let Z := Field51_as_Nat e.Z\n    let T := Field51_as_Nat e.T\n    let A := Field51_as_Nat pn.Y_plus_X\n    let B := Field51_as_Nat pn.Y_minus_X\n    let Z' := Field51_as_Nat pn.Z\n    let C := Field51_as_Nat pn.T2d\n    let d2 := Field51_as_Nat EDWARDS_D2\n    A % p = (Y + X) % p ∧\n    (B + X) % p = Y % p ∧\n    Z' % p = Z % p ∧\n    C % p = (T * d2) % p ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Edwards/EdwardsPoint/AsProjectiveNiels.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.as_projective_niels`**:\n- No panic (always returns successfully)\n- For the input Edwards point (X, Y, Z, T), the resulting ProjectiveNielsPoint has coordinates:\n  - A ≡ Y + X (mod p)\n  - B ≡ Y - X (mod p)\n  - Z' = Z\n  - C ≡ T * 2 * d (mod p)\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(crate) fn as_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::as_projective_niels",
   "lines": "L520-L527",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.as_projective_niels",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem compress_spec (self : EdwardsPoint) (hX : ∀ i < 5, self.X[i]!.val < 2 ^ 54)\n      (hY : ∀ i < 5, self.Y[i]!.val < 2 ^ 54) (hZ : ∀ i < 5, self.Z[i]!.val < 2 ^ 54)\n      -- (hself : self.IsValid)\n      :\n    compress self ⦃ result => True ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Compress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.compress`**:\n- No panic when Z is invertible / not zero (always returns successfully)\n- On success, returns a CompressedEdwardsY (U8x32 byte array) where:\n  - Bytes 0-30 and the low 7 bits of byte 31 encode the affine y-coordinate in little-endian\n  - The high bit of byte 31 encodes the sign (parity) of the affine x-coordinate\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn compress(&self) -> CompressedEdwardsY {\n        self.to_affine().compress()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::compress",
   "lines": "L607-L609",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.compress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.to_affine",
    "curve25519_dalek.edwards.affine.AffinePoint.compress"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem double_spec (e : EdwardsPoint) (he_valid : e.IsValid) :\n    double e ⦃ result =>\n    result.IsValid ∧ result.toPoint = e.toPoint + e.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Double.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.double`**:\n- No panic (always returns successfully)\n- Returns the doubled point 2P (= P + P in elliptic curve addition) where P is the input EdwardsPoint\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(crate) fn double(&self) -> EdwardsPoint {\n        self.as_projective().double().as_extended()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::double",
   "lines": "L745-L747",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.double",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective",
    "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_small_order_spec (self : EdwardsPoint) (hself : self.IsValid) :\n    is_small_order self ⦃ result =>\n    (result ↔ h • self.toPoint = 0) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/IsSmallOrder.lean",
   "spec_docstring":
   "/-- **Spec for `edwards.EdwardsPoint.is_small_order`**:\n- Returns `true` if and only if the point has small order (is in the torsion subgroup E[8])\n- This is determined by checking if multiplying by the cofactor yields the identity element\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::is_small_order",
   "lines": "L1367-L1369",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.is_small_order",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.mul_by_cofactor",
    "curve25519_dalek.traits.IsIdentity.Blanket.is_identity",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConstantTimeEq",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER_PRIVATE).is_identity()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::is_torsion_free",
   "lines": "L1397-L1399",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.is_torsion_free",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAEdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint.mul",
    "curve25519_dalek.constants.BASEPOINT_ORDER_PRIVATE",
    "curve25519_dalek.traits.IsIdentity.Blanket.is_identity",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConstantTimeEq",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_base_spec (scalar : scalar.Scalar) :\n    mul_base scalar ⦃ res =>\n    EdwardsPoint.IsValid res ∧\n    res.toPoint = (U8x32_as_Nat scalar.bytes) • constants.ED25519_BASEPOINT_POINT.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/MulBase.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.mul_base`**:\n- No panic (always returns successfully)\n- Delegates to scalar multiplication with the Edwards basepoint constant\n- The returned EdwardsPoint equals the output of that scalar multiplication\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_base",
   "lines": "L877-L887",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_base",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint.mul",
    "curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_base_clamped_spec (bytes : Array U8 32#usize) :\n    mul_base_clamped bytes ⦃ result =>\n    EdwardsPoint.IsValid result ∧\n    (∃ clamped_scalar,\n    h ∣ U8x32_as_Nat clamped_scalar ∧\n    U8x32_as_Nat clamped_scalar < 2 ^ 255 ∧\n    2 ^ 254 ≤ U8x32_as_Nat clamped_scalar ∧\n    result.toPoint = ((U8x32_as_Nat clamped_scalar) • constants.ED25519_BASEPOINT_POINT.toPoint)) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Edwards/EdwardsPoint/MulBaseClamped.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.mul_base_clamped`**:\n- No panic (always returns successfully)\n- Clamps input bytes with `scalar.clamp_integer`\n- Delegates to `edwards.EdwardsPoint.mul_base` with the clamped scalar\n- The returned EdwardsPoint matches the basepoint multiplication result\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_base_clamped",
   "lines": "L907-L915",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_base_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.edwards.EdwardsPoint.mul_base"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_by_cofactor_spec (self : EdwardsPoint) (hself : self.IsValid) :\n    mul_by_cofactor self ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = h • self.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/MulByCofactor.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.mul_by_cofactor`**:\n- No panic (always returns successfully)\n- Returns an EdwardsPoint that represents 8e = (2 ^ 3) * e\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_by_cofactor",
   "lines": "L1325-L1327",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_by_cofactor",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_by_pow_2_spec (self : EdwardsPoint) (k : U32) (hself : self.IsValid) (hk : k.val > 0) :\n    ∃ result : EdwardsPoint, mul_by_pow_2 self k = ok result ∧\n    result.IsValid ∧\n    result.toPoint = (2 ^ k.val) • self.toPoint := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/MulByPow2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.mul_by_pow_2`**:\n- For k = 1, returns the doubled point 2e for the input point e\n- For k > 1, returns a point equal to double(mul_by_pow_2(e, k-1))\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        let mut i = 0;\n        while i < k - 1 {\n            r = s.double();\n            s = r.as_projective();\n            i += 1;\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_by_pow_2",
   "lines": "L1330-L1342",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective",
    "curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2_loop",
    "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "        while i < k - 1 {\n            r = s.double();\n            s = r.as_projective();\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_by_pow_2",
   "lines": "L1335-L1339",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_projective"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_clamped",
   "lines": "L891-L903",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_affine_spec (e : EdwardsPoint)\n    (hX : ∀ i < 5, e.X[i]!.val < 2 ^ 54)\n    (hY : ∀ i < 5, e.Y[i]!.val < 2 ^ 54)\n    (hZ : ∀ i < 5, e.Z[i]!.val < 2 ^ 54) :\n    to_affine e ⦃ ap =>\n\n    let X := Field51_as_Nat e.X\n    let Y := Field51_as_Nat e.Y\n    let Z := Field51_as_Nat e.Z\n    let x := Field51_as_Nat ap.x\n    let y := Field51_as_Nat ap.y\n\n    (if Z % p = 0 then\n      x % p = 0 ∧ y % p = 0\n    else\n      (x * Z) % p = X % p ∧\n      (y * Z) % p = Y % p) ∧\n      (∀ i < 5, ap.x[i]!.val < 2 ^ 52) ∧\n      (∀ i < 5, ap.y[i]!.val < 2 ^ 52) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/ToAffine.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.to_affine`**:\n- No panic (always returns successfully)\n- For the input Edwards point (X, Y, Z, T), the resulting AffinePoint has coordinates:\n  - If Z ≢ 0 (mod p): x * Z ≡ X (mod p) and y * Z ≡ Y (mod p)\n  - If Z ≡ 0 (mod p): x ≡ 0 (mod p) and y ≡ 0 (mod p)\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::to_affine",
   "lines": "L556-L561",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.to_affine",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem to_montgomery_spec (e : EdwardsPoint)\n    (h_Y_bounds : ∀ i < 5, e.Y[i]!.val < 2 ^ 53) (h_Z_bounds : ∀ i < 5, e.Z[i]!.val < 2 ^ 53) :\n    to_montgomery e ⦃ mp =>\n    (let Y := Field51_as_Nat e.Y\n    let Z := Field51_as_Nat e.Z\n    let u := U8x32_as_Nat mp\n    if Z % p = Y % p then\n      u % p = 0\n    else\n      (u * Z) % p = (u * Y + (Z + Y)) % p) ∧\n    (∀ n : ℕ, fromEdwards (n • e.toPoint) = n • (MontgomeryPoint.mkPoint mp)) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/ToMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.to_montgomery`**:\n- No panic (always returns successfully)\n- For the input Edwards point (X, Y, Z, T), the resulting MontgomeryPoint has u-coordinate:\n  - If Z ≢ Y (mod p): u ≡ (Z+Y) * (Z-Y)^(-1) (mod p)\n  - If Z ≡ Y (mod p): u ≡ 0 (mod p)\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::to_montgomery",
   "lines": "L572-L582",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.to_montgomery",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source": "#[derive(Copy, Clone, Debug)]",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::clone::Clone for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L11-L11",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source": "#[derive(Copy, Clone, Debug)]",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::clone::Clone for curve25519_dalek::edwards::affine::AffinePoint}::clone",
   "lines": "L11-L11",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source": "impl Eq for AffinePoint {}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::cmp::Eq for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L53-L53",
   "lean_name": "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCmpPartialEqAffinePoint"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "impl PartialEq for AffinePoint {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::cmp::PartialEq<curve25519_dalek::edwards::affine::AffinePoint> for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L47-L51",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCmpPartialEqAffinePoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCmpPartialEqAffinePoint.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::cmp::PartialEq<curve25519_dalek::edwards::affine::AffinePoint> for curve25519_dalek::edwards::affine::AffinePoint}::eq",
   "lines": "L48-L50",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCmpPartialEqAffinePoint.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "impl Default for AffinePoint {\n    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::default::Default for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L32-L36",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::default::Default for curve25519_dalek::edwards::affine::AffinePoint}::default",
   "lines": "L33-L35",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source": "#[derive(Copy, Clone, Debug)]",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::marker::Copy for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L11-L11",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "impl Identity for AffinePoint {\n    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L38-L45",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::affine::AffinePoint}::identity",
   "lines": "L39-L44",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "impl ConditionallySelectable for AffinePoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{subtle::ConditionallySelectable for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L23-L30",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.edwards.affine.AffinePoint.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{subtle::ConditionallySelectable for curve25519_dalek::edwards::affine::AffinePoint}::conditional_select",
   "lines": "L24-L29",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "impl ConstantTimeEq for AffinePoint {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{subtle::ConstantTimeEq for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L17-L21",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{subtle::ConstantTimeEq for curve25519_dalek::edwards::affine::AffinePoint}::ct_eq",
   "lines": "L18-L20",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source": "impl DefaultIsZeroes for AffinePoint {}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{zeroize::DefaultIsZeroes for curve25519_dalek::edwards::affine::AffinePoint}",
   "lines": "L56-L56",
   "lean_name":
   "curve25519_dalek.edwards.affine.AffinePoint.Insts.ZeroizeDefaultIsZeroes",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.edwards.affine.AffinePoint.Insts.CoreDefaultDefault"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem compress_spec (self : AffinePoint) -- (hself : self.IsValid)\n    (h : Field51_as_Nat self.y < 2 ^ 255) :\n    compress self ⦃ result =>\n    True -- result.IsValid ∧ result.toPoint = self.toPoint\n     ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Edwards/Affine/AffinePoint/Compress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.affine.AffinePoint.compress`**:\n- Requires: `y`-coordinate of the AffinePoint, when converted to 32 bytes, has leading bit zero\n- Returns a CompressedEdwardsY equal to the input AffinePoint\n-/",
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    pub fn compress(self) -> CompressedEdwardsY {\n        let mut s = self.y.to_bytes();\n        s[31] ^= self.x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{curve25519_dalek::edwards::affine::AffinePoint}::compress",
   "lines": "L71-L75",
   "lean_name": "curve25519_dalek.edwards.affine.AffinePoint.compress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
    "curve25519_dalek.field.FieldElement51.is_negative"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    pub fn to_edwards(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: &self.x * &self.y,\n        }\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{curve25519_dalek::edwards::affine::AffinePoint}::to_edwards",
   "lines": "L60-L67",
   "lean_name": "curve25519_dalek.edwards.affine.AffinePoint.to_edwards",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y²-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy²+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }",
   "rust_name": "curve25519_dalek::edwards::decompress::step_1",
   "lines": "L216-L227",
   "lean_name": "curve25519_dalek.edwards.decompress.step_1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.as_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.field.FieldElement51.sqrt_ratio_i"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_source":
   "    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        let x_neg = -&X;\n        X.conditional_assign(&x_neg, compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }",
   "rust_name": "curve25519_dalek::edwards::decompress::step_2",
   "lines": "L230-L248",
   "lean_name": "curve25519_dalek.edwards.decompress.step_2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.as_bytes",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invert_spec (r : backend.serial.u64.field.FieldElement51) (h_bounds : ∀ i, i < 5 → (r[i]!).val < 2 ^ 54) :\n    invert r ⦃ r' =>\n    let r_nat := Field51_as_Nat r % p\n    let r'_nat := Field51_as_Nat r' % p\n    (r_nat ≠ 0 → (r'_nat * r_nat) % p = 1) ∧\n    (r_nat = 0 → r'_nat = 0) ∧\n    (∀ i, i < 5 → (r'[i]!).val < 2 ^ 52) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/Invert.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::invert",
   "lines": "L254-L263",
   "lean_name": "curve25519_dalek.field.FieldElement51.invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.pow22501",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invsqrt_spec\n    (v : backend.serial.u64.field.FieldElement51)\n    (h_v_bounds : ∀ i, i < 5 → (v[i]!).val ≤ 2 ^ 52 - 1) :\n    invsqrt v ⦃ res =>\n    let v_nat := Field51_as_Nat v % p\n    let r_nat := Field51_as_Nat res.snd % p\n    let i_nat := Field51_as_Nat SQRT_M1 % p\n    -- Unconditional bounds\n    (∀ i < 5, res.snd[i]!.val ≤ 2 ^ 53 - 1) ∧\n    -- Non-negativity\n    (r_nat % 2 = 0) ∧\n    -- Case 1: If v ≡ 0 (mod p), then c.val = 0 and r ≡ 0 (mod p)\n    (v_nat = 0 → res.fst.val = 0#u8 ∧ r_nat = 0) ∧\n    -- Case 2: If v ≢ 0 and ∃ x, x^2 * v ≡ 1 (mod p), then c.val = 1 and r^2 * v ≡ 1 (mod p)\n    (v_nat ≠ 0 ∧ (∃ x : Nat, (x ^ 2 * v_nat) % p = 1) →\n      res.fst.val = 1#u8 ∧ (r_nat ^ 2 * v_nat) % p = 1) ∧\n    -- Case 3: If v ≢ 0 and ¬∃ x, x^2 * v ≡ 1 (mod p), then c.val = 0 and r^2 * v ≡ i (mod p)\n    (v_nat ≠ 0 ∧ ¬(∃ x : Nat, (x ^ 2 * v_nat) % p = 1) →\n      res.fst.val = 0#u8 ∧ (r_nat ^ 2 * v_nat) % p = i_nat) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/InvSqrt.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `field.FieldElement51.invsqrt`**:\n- No panic for field element inputs v (always returns (c, r) successfully)\n- Output limbs bounded by 2^53 - 1\n- Result r is non-negative (r_nat % 2 = 0)\n- The result satisfies exactly one of three mutually exclusive cases:\n  1. If v ≡ 0 (mod p), then c.val = 0 and r ≡ 0 (mod p)\n  2. If v ≢ 0 and ∃ x, x^2 * v ≡ 1 (mod p), then c.val = 1 and r^2 * v ≡ 1 (mod p)\n  3. If v ≢ 0 and ¬∃ x, x^2 * v ≡ 1 (mod p), then c.val = 0 and r^2 * v ≡ SQRT_M1 (mod p)\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::invsqrt",
   "lines": "L352-L354",
   "lean_name": "curve25519_dalek.field.FieldElement51.invsqrt",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_negative_spec (r : backend.serial.u64.field.FieldElement51) :\n    is_negative r ⦃ c =>\n    (c.val = 1#u8 ↔ (Field51_as_Nat r % p) % 2 = 1) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/IsNegative.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    pub(crate) fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::is_negative",
   "lines": "L149-L152",
   "lean_name": "curve25519_dalek.field.FieldElement51.is_negative",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_zero_spec (r : backend.serial.u64.field.FieldElement51) :\n    is_zero r ⦃ c =>\n    (c.val = 1#u8 ↔ Field51_as_Nat r % p = 0) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/IsZero.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    pub(crate) fn is_zero(&self) -> Choice {\n        let zero = [0u8; 32];\n        let bytes = self.to_bytes();\n\n        bytes.ct_eq(&zero)\n    }",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::is_zero",
   "lines": "L159-L164",
   "lean_name": "curve25519_dalek.field.FieldElement51.is_zero",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem pow22501_spec (r : backend.serial.u64.field.FieldElement51) (h_bounds : ∀ i, i < 5 → (r[i]!).val < 2 ^ 54) :\n    pow22501 r ⦃ result =>\n    let r1 := result.1\n    let r2 := result.2\n    Field51_as_Nat r1 % p = (Field51_as_Nat r ^ (2 ^ 250 - 1)) % p ∧\n    Field51_as_Nat r2 % p = (Field51_as_Nat r ^ 11) % p ∧\n    (∀ i, i < 5 → (r1[i]!).val < 2 ^ 52) ∧\n    (∀ i, i < 5 → (r2[i]!).val < 2 ^ 52) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/Pow22501.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `field.FieldElement51.pow22501`**:\n- No panic (always returns (r1, r2) successfully)\n- Field51_as_Nat(r1) ≡ Field51_as_Nat(r)^(2^250-1) (mod p)\n  Field51_as_Nat(r2) ≡ Field51_as_Nat(r)^11 (mod p)\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    fn pow22501(&self) -> (FieldElement, FieldElement) {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        let t0  = self.square();           // 1         e_0 = 2^1\n        let t1  = t0.square().square();    // 3         e_1 = 2^3\n        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0\n        let t3  = &t0 * &t2;               // 3,1,0\n        let t4  = t3.square();             // 4,2,1\n        let t5  = &t2 * &t4;               // 4,3,2,1,0\n        let t6  = t5.pow2k(5);             // 9,8,7,6,5\n        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0\n        let t8  = t7.pow2k(10);            // 19..10\n        let t9  = &t8 * &t7;               // 19..0\n        let t10 = t9.pow2k(20);            // 39..20\n        let t11 = &t10 * &t9;              // 39..0\n        let t12 = t11.pow2k(10);           // 49..10\n        let t13 = &t12 * &t7;              // 49..0\n        let t14 = t13.pow2k(50);           // 99..50\n        let t15 = &t14 * &t13;             // 99..0\n        let t16 = t15.pow2k(100);          // 199..100\n        let t17 = &t16 * &t15;             // 199..0\n        let t18 = t17.pow2k(50);           // 249..50\n        let t19 = &t18 * &t13;             // 249..0\n\n        (t19, t3)\n    }",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow22501",
   "lines": "L169-L203",
   "lean_name": "curve25519_dalek.field.FieldElement51.pow22501",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem pow_p58_spec (r : backend.serial.u64.field.FieldElement51) (h_bounds : ∀ i, i < 5 → (r[i]!).val ≤ 2 ^ 52 - 1) :\n    pow_p58 r ⦃ r' =>\n    Field51_as_Nat r' % p = (Field51_as_Nat r ^ (2 ^ 252 - 3)) % p ∧\n    (∀ i, i < 5 → (r'[i]!).val ≤ 2 ^ 52 - 1) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/PowP58.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `field.FieldElement51.pow_p58`**:\n- No panic for field element inputs r (always returns r' successfully)\n- Field51_as_Nat(r') ≡ Field51_as_Nat(r)^(2^252-3) (mod p)\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    fn pow_p58(&self) -> FieldElement {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();    // 249..0\n        let t20 = t19.pow2k(2);            // 251..2\n        let t21 = self * &t20;             // 251..2,0\n\n        t21\n    }",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow_p58",
   "lines": "L268-L277",
   "lean_name": "curve25519_dalek.field.FieldElement51.pow_p58",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.pow22501",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sqrt_ratio_i_spec\n    (u : backend.serial.u64.field.FieldElement51)\n    (v : backend.serial.u64.field.FieldElement51)\n    (h_u_bounds : ∀ i, i < 5 → (u[i]!).val ≤ 2 ^ 52 - 1)\n    (h_v_bounds : ∀ i, i < 5 → (v[i]!).val ≤ 2 ^ 52 - 1) :\n    sqrt_ratio_i u v ⦃ c =>\n    let u_nat := Field51_as_Nat u % p\n    let v_nat := Field51_as_Nat v % p\n    let r_nat := Field51_as_Nat c.2 % p\n    let i_nat := Field51_as_Nat backend.serial.u64.constants.SQRT_M1 % p\n    (∀ i < 5,  c.2[i]!.val ≤ 2 ^ 53 - 1) ∧\n    (r_nat % 2 = 0) ∧\n    (u_nat = 0 →\n      c.1.val = 1#u8 ∧ r_nat = 0) ∧\n    (u_nat ≠ 0 ∧ v_nat = 0 →\n      c.1.val = 0#u8 ∧ r_nat = 0) ∧\n    (u_nat ≠ 0 ∧ v_nat ≠ 0 ∧ (∃ x : Nat, (x^2 * v_nat) % p = u_nat) →\n      c.1.val = 1#u8 ∧ (r_nat ^ 2 * v_nat) % p = u_nat) ∧\n    (u_nat ≠ 0 ∧ v_nat ≠ 0 ∧ (¬(∃ x : Nat, (x^2 * v_nat) % p = u_nat)) →\n      c.1.val = 0#u8 ∧ (r_nat ^2 * v_nat) % p = (i_nat * u_nat) % p)\n    ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/SqrtRatioi.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_source":
   "    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n        let flipped_sign_sqrt = check.ct_eq(&(-u));\n        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        let r_neg = -&r;\n        r.conditional_assign(&r_neg, r_is_negative);\n\n        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n\n        (was_nonzero_square, r)\n    }",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::sqrt_ratio_i",
   "lines": "L291-L338",
   "lean_name": "curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.field.FieldElement51.pow_p58",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
    "curve25519_dalek.field.FieldElement51.is_negative"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug, Default)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::clone::Clone for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L73-L73",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug, Default)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::clone::Clone for curve25519_dalek::montgomery::MontgomeryPoint}::clone",
   "lines": "L73-L73",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "impl Eq for MontgomeryPoint {}",
   "rust_name":
   "curve25519_dalek::montgomery::{core::cmp::Eq for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L99-L99",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCmpPartialEqMontgomeryPoint"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl PartialEq for MontgomeryPoint {\n    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{core::cmp::PartialEq<curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L93-L97",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCmpPartialEqMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCmpPartialEqMontgomeryPoint.eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem eq_spec (u v : MontgomeryPoint) :\n    eq u v ⦃ b =>\n    (b = true ↔\n      (U8x32_as_Nat u % 2 ^ 255) ≡ (U8x32_as_Nat v % 2 ^ 255) [MOD p]) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Eq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.PartialEqMontgomeryPointMontgomeryPoint.eq`**:\n- No panic (always returns successfully)\n- Returns true iff the u-coordinates are equal modulo p\n- Implemented via constant-time equality followed by Choice-to-Bool conversion\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::cmp::PartialEq<curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}::eq",
   "lines": "L94-L96",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCmpPartialEqMontgomeryPoint.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug, Default)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::default::Default for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L73-L73",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug, Default)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::default::Default for curve25519_dalek::montgomery::MontgomeryPoint}::default",
   "lines": "L73-L73",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug, Default)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::marker::Copy for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L73-L73",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl MulAssign<$rhs> for $lhs {\n            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L117-L121",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulAssignScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulAssignScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::montgomery::MontgomeryPoint}::mul_assign",
   "lines": "L118-L120",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulAssignScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulAssignShared0Scalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl MulAssign<&Scalar> for MontgomeryPoint {\n    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::MulAssign<&0 (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L454-L458",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulAssignShared0Scalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulAssignShared0Scalar.mul_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_assign_spec (P : MontgomeryPoint) (scalar : scalar.Scalar) :\n    mul_assign P scalar ⦃ res =>\n    let m:= (U8x32_as_Nat scalar.bytes) % 2^255\n    MontgomeryPoint.mkPoint res = m • (MontgomeryPoint.mkPoint P) ⦄\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulAssign.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulAssignMontgomeryPointShared0Scalar.mul_assign`**:\n- No panic (always returns successfully)\n- Delegates to `montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul`\n- The returned MontgomeryPoint equals the Montgomery ladder result for the given scalar and point\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::MulAssign<&0 (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::montgomery::MontgomeryPoint}::mul_assign",
   "lines": "L455-L457",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulAssignShared0Scalar.mul_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L105-L110",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulScalarMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}::mul",
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L91-L96",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulSharedBScalarMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulSharedBScalarMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (P : MontgomeryPoint) (rhs : scalar.Scalar) :\n    mul P rhs ⦃ res =>\n    let m:= (U8x32_as_Nat rhs.bytes) % 2^255\n    MontgomeryPoint.mkPoint res = m • (MontgomeryPoint.mkPoint P) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulMontgomeryPointSharedBScalarMontgomeryPoint.mul`**:\n- No panic (always returns successfully given valid inputs)\n- Implements scalar multiplication via delegation to the underlying operation\n- The result is mathematically equivalent to [scalar]point\n- Mathematical properties of the result:\n  * The result encodes the u-coordinate of the scalar multiplication [scalar]point\n  * Mathematically equivalent to MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul\n  * If point has u-coordinate u₀ and scalar is n (as an integer ≤ 2^255), then the result\n    encodes u₀([n]point), the u-coordinate of the n-fold sum of point on the Montgomery curve\n  * The Montgomery ladder maintains the invariant that x0 and x1 represent points\n    differing by point throughout the computation\n  * The computation maintains constant-time guarantees inherited from the underlying\n    Montgomery ladder implementation\n  * The returned MontgomeryPoint is a valid 32-byte encoding with value reduced modulo 2^255\n-/",
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}::mul",
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreOpsArithMulSharedBScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1MontgomeryPoint.Insts.CoreOpsArithMulShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl Identity for MontgomeryPoint {\n    /// Return the group identity element, which has order 4.\n    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L112-L117",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    spec identity (fun q =>\n    (∀ i : Fin 32, q[i]! = 0#u8) ∧\n    U8x32_as_Nat q = 0) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.Insts.Curve25519_dalekTraitsIdentity.identity`**:\n- No panic (always returns successfully)\n- The resulting MontgomeryPoint is 32 zero bytes\n- Interpreted as a natural number via `U8x32_as_Nat`, the result equals 0\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::MontgomeryPoint}::identity",
   "lines": "L114-L116",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl ConditionallySelectable for MontgomeryPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConditionallySelectable for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L87-L91",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.montgomery.MontgomeryPoint.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : montgomery.MontgomeryPoint)\n    (choice : subtle.Choice) :\n    conditional_select a b choice ⦃ res =>\n      ∀ i < 32,\n        res[i]! = (if choice.val = 1#u8 then b[i]! else a[i]!) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec for `montgomery.MontgomeryPoint.Insts.SubtleConditionallySelectable.conditional_select`**:\n- No panic (always returns successfully)\n- For each byte i, the result byte equals `b[i]` when `choice = 1`,\n  and equals `a[i]` when `choice = 0` (constant-time conditional select)\n- Consequently, when `choice = Choice.one` (value 1), the whole result equals `b`;\n  when `choice = Choice.zero` (value 0), the result equals `a`.\n\nThis implements constant-time conditional selection for Montgomery curve points,\nwhere the points are represented as 32-byte arrays containing the u-coordinate.\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConditionallySelectable for curve25519_dalek::montgomery::MontgomeryPoint}::conditional_select",
   "lines": "L88-L90",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl ConstantTimeEq for MontgomeryPoint {\n    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConstantTimeEq for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L78-L85",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ct_eq_spec (u v : MontgomeryPoint) :\n    ct_eq u v ⦃ c =>\n    (c = Choice.one ↔\n      (U8x32_as_Nat u % 2 ^ 255) ≡ (U8x32_as_Nat v % 2 ^ 255) [MOD p]) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/CtEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.ConstantTimeEqMontgomeryPoint.ct_eq`**:\n- No panic (always returns successfully)\n- Choice.one is returned iff the u-coordinates match modulo p\n- The comparison proceeds via `FieldElement51.from_bytes` and constant-time equality\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConstantTimeEq for curve25519_dalek::montgomery::MontgomeryPoint}::ct_eq",
   "lines": "L79-L84",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl Zeroize for MontgomeryPoint {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{zeroize::Zeroize for curve25519_dalek::montgomery::MontgomeryPoint}",
   "lines": "L120-L124",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.ZeroizeZeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MontgomeryPoint.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{zeroize::Zeroize for curve25519_dalek::montgomery::MontgomeryPoint}::zeroize",
   "lines": "L121-L123",
   "lean_name":
   "curve25519_dalek.montgomery.MontgomeryPoint.Insts.ZeroizeZeroize.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec (mp : montgomery.MontgomeryPoint) :\n    montgomery.MontgomeryPoint.as_bytes mp ⦃ result =>\n    result = mp ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof for `montgomery.MontgomeryPoint.as_bytes`**:\n\nSince MontgomeryPoint is defined as Array U8 32 in Lean, as_bytes returns the input unchanged.\n\nFormal specification:\n- The function always succeeds\n- Returns the input unchanged (result = self)\n- Preserves the field element representation\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::as_bytes",
   "lines": "L199-L201",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_base_spec (scalar : scalar.Scalar) :\n    mul_base scalar ⦃ result =>\n    Montgomery.MontgomeryPoint.mkPoint result = (U8x32_as_Nat scalar.bytes) • (fromEdwards constants.ED25519_BASEPOINT_POINT.toPoint) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulBase.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.mul_base`**:\n- No panic (always returns successfully)\n- Delegates to `edwards.EdwardsPoint.mul_base` and `edwards.EdwardsPoint.to_montgomery`\n- The returned MontgomeryPoint is the Montgomery conversion of the Edwards basepoint result\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    pub fn mul_base(scalar: &Scalar) -> Self {\n        EdwardsPoint::mul_base(scalar).to_montgomery()\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::mul_base",
   "lines": "L128-L130",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.mul_base",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.mul_base",
    "curve25519_dalek.edwards.EdwardsPoint.to_montgomery"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_base_clamped_spec (bytes : Array U8 32#usize) :\n    mul_base_clamped bytes ⦃ result =>\n    (∃ clamped_scalar_nat,\n    h ∣ clamped_scalar_nat ∧\n    clamped_scalar_nat < 2 ^ 255 ∧\n    2 ^ 254 ≤ clamped_scalar_nat ∧\n     MontgomeryPoint.mkPoint result = clamped_scalar_nat • (fromEdwards constants.ED25519_BASEPOINT_POINT.toPoint)) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulBaseClamped.lean",
   "spec_docstring":
   "/--\n**Spec and proof concerning `montgomery.MontgomeryPoint.mul_base_clamped`**:\n- No panic (always returns successfully)\n- Clamps input bytes with `scalar.clamp_integer`\n- Delegates to `montgomery.MontgomeryPoint.mul_base` with the clamped scalar\n- The returned MontgomeryPoint matches the basepoint multiplication result\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::mul_base_clamped",
   "lines": "L150-L158",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.mul_base_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.montgomery.MontgomeryPoint.mul_base"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_clamped_spec (P : MontgomeryPoint) (bytes : Array U8 32#usize) :\n    mul_clamped P bytes ⦃ res =>\n    (∃ clamped_scalar,\n    h ∣ U8x32_as_Nat clamped_scalar ∧\n    U8x32_as_Nat clamped_scalar < 2 ^ 255 ∧\n    2 ^ 254 ≤ U8x32_as_Nat clamped_scalar ∧\n    let m:= (U8x32_as_Nat clamped_scalar)\n    MontgomeryPoint.mkPoint res = m • (MontgomeryPoint.mkPoint P)) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulClamped.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.mul_clamped`**:\n- No panic (always returns successfully)\n- Clamps input bytes with `scalar.clamp_integer`\n- Delegates to `montgomery.MulScalarMontgomeryPointMontgomeryPoint.mul`\n- The returned MontgomeryPoint matches the clamped scalar multiplication result\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::mul_clamped",
   "lines": "L134-L146",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.mul_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulMontgomeryPointMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (mp : montgomery.MontgomeryPoint) :\n    montgomery.MontgomeryPoint.to_bytes mp ⦃ result =>\n    result = mp ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof for `montgomery.MontgomeryPoint.to_bytes`**:\n\nSince MontgomeryPoint is defined as Array U8 32 in Lean, to_bytes returns the input unchanged.\n\nFormal specification:\n- The function always succeeds\n- Returns the input unchanged (result = self)\n- Preserves the field element representation\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::to_bytes",
   "lines": "L204-L206",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem to_edwards_spec (mp : MontgomeryPoint) (sign : U8) :\n    to_edwards mp sign ⦃ opt_e =>\n    let u := U8x32_as_Nat mp\n\n    ((u + 1) % p = 0 → opt_e = none) ∧\n\n    ((u + 1) % p ≠ 0 →\n      (opt_e = none ∨ -- can still return none if y cannot be decompressed into a valid Edwards point\n       ∃ e x_sign,\n       opt_e = some e ∧\n       field.FieldElement51.is_negative e.X = ok x_sign ∧\n       let y := Field51_as_Nat e.Y\n\n       y * (u + 1) % p = (u - 1) % p ∧\n       (x_sign.val = 1#u8 ↔ sign.val.testBit 0))) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/ToEdwards.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.to_edwards`**:\n- Returns None if u ≡ -1 (mod p)\n- Returns None if the y-coordinate cannot be decompressed to a valid Edwards point\n- Otherwise, returns Some(EdwardsPoint) where:\n  - The y-coordinate satisfies: y * (u + 1) ≡ (u-1) (mod p)\n  - The sign of x matches the input sign parameter\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    pub fn to_edwards(&self, sign: u8) -> Option<EdwardsPoint> {\n        // To decompress the Montgomery u coordinate to an\n        // `EdwardsPoint`, we apply the birational map to obtain the\n        // Edwards y coordinate, then do Edwards decompression.\n        //\n        // The birational map is y = (u-1)/(u+1).\n        //\n        // The exceptional points are the zeros of the denominator,\n        // i.e., u = -1.\n        //\n        // But when u = -1, v^2 = u*(u^2+486662*u+1) = 486660.\n        //\n        // Since this is nonsquare mod p, u = -1 corresponds to a point\n        // on the twist, not the curve, so we can reject it early.\n\n        let u = FieldElement::from_bytes(&self.0);\n\n        if u == FieldElement::MINUS_ONE {\n            return None;\n        }\n\n        let one = FieldElement::ONE;\n\n        let y = &(&u - &one) * &(&u + &one).invert();\n\n        let mut y_bytes = y.to_bytes();\n        y_bytes[31] ^= sign << 7;\n\n        CompressedEdwardsY(y_bytes).decompress()\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::to_edwards",
   "lines": "L224-L253",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.to_edwards",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.CoreCmpPartialEqFieldElement51.eq",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
    "curve25519_dalek.edwards.CompressedEdwardsY.decompress"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::clone::Clone for curve25519_dalek::montgomery::ProjectivePoint}",
   "lines": "L289-L289",
   "lean_name":
   "curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::clone::Clone for curve25519_dalek::montgomery::ProjectivePoint}::clone",
   "lines": "L289-L289",
   "lean_name":
   "curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl Default for ProjectivePoint {\n    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{core::default::Default for curve25519_dalek::montgomery::ProjectivePoint}",
   "lines": "L305-L309",
   "lean_name":
   "curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::default::Default for curve25519_dalek::montgomery::ProjectivePoint}::default",
   "lines": "L306-L308",
   "lean_name":
   "curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.IdentityMontgomeryProjectivePoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source": "#[derive(Copy, Clone, Debug)]",
   "rust_name":
   "curve25519_dalek::montgomery::{core::marker::Copy for curve25519_dalek::montgomery::ProjectivePoint}",
   "lines": "L289-L289",
   "lean_name":
   "curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "impl ConditionallySelectable for ProjectivePoint {\n    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }\n}",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConditionallySelectable for curve25519_dalek::montgomery::ProjectivePoint}",
   "lines": "L311-L322",
   "lean_name":
   "curve25519_dalek.montgomery.ProjectivePoint.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.ProjectivePoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.montgomery.ProjectivePoint.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : montgomery.ProjectivePoint)\n    (choice : subtle.Choice) :\n    conditional_select a b choice ⦃ res =>\n      (∀ i < 5, res.U[i]! = (if choice.val = 1#u8 then b.U[i]! else a.U[i]!)) ∧\n      (∀ i < 5, res.W[i]! = (if choice.val = 1#u8 then b.W[i]! else a.W[i]!)) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/ProjectivePoint/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec for `montgomery.ProjectivePoint.Insts.SubtleConditionallySelectable.conditional_select`**:\n- No panic (always returns successfully)\n- For both U and W coordinates:\n  - Each limb of the result equals the corresponding limb from `b` when `choice = 1`\n  - Each limb of the result equals the corresponding limb from `a` when `choice = 0`\n- Consequently, when `choice = Choice.one` (value 1), the whole result equals `b`;\n  when `choice = Choice.zero` (value 0), the result equals `a`.\n\nThis implements constant-time conditional selection for Montgomery curve points\nin projective coordinates (U:W).\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConditionallySelectable for curve25519_dalek::montgomery::ProjectivePoint}::conditional_select",
   "lines": "L312-L321",
   "lean_name":
   "curve25519_dalek.montgomery.ProjectivePoint.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem as_affine_spec (self : montgomery.ProjectivePoint)\n    (hU : self.U.IsValid)\n    (hW : self.W.IsValid)\n    (h_valid : self.W.toField ≠ 0) :\n    as_affine self ⦃ res => bytesToField res = self.U.toField  / self.W.toField  ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/AsAffine.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.ProjectivePoint.as_affine`**:\n- No panic (always returns successfully when input limbs satisfy bounds)\n- Returns bytesToField(result) = U/W (mod p) where p = 2^255 - 19\n- Does not verify curve validity (pure encoding of field element U/W)\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::ProjectivePoint}::as_affine",
   "lines": "L331-L334",
   "lean_name": "curve25519_dalek.montgomery.ProjectivePoint.as_affine",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem differential_add_and_double_spec\n    (P Q : montgomery.ProjectivePoint)\n    (affine_PmQ : backend.serial.u64.field.FieldElement51)\n    (hP_valid : P.IsValid)\n    (hQ_valid : Q.IsValid)\n    (h_ladder_state : valid_ladder_state P Q affine_PmQ) :\n    differential_add_and_double P Q affine_PmQ ⦃ res =>\n      let (P', Q') := res\n      P'.IsValid ∧ Q'.IsValid ∧\n      (∀ (P_affine Q_affine : Montgomery.Point),\n        (Montgomery.get_u P_affine = Field51_as_Nat P.U / Field51_as_Nat P.W ∧\n         Montgomery.get_u Q_affine = Field51_as_Nat Q.U / Field51_as_Nat Q.W ∧\n         Montgomery.get_u (P_affine - Q_affine) = Field51_as_Nat affine_PmQ) →\n        (Field51_as_Nat P'.U / Field51_as_Nat P'.W = Montgomery.get_u (2 • P_affine)) ∧\n        (Field51_as_Nat Q'.U / Field51_as_Nat Q'.W = Montgomery.get_u (P_affine + Q_affine)))\n    ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/ProjectivePoint/DifferentialAddAndDouble.lean",
   "spec_docstring":
   "/-- **Spec for `montgomery.differential_add_and_double`**:\n\n- No panic (always succeeds for valid inputs)\n- Requires: P and Q are valid projective points (W ≠ 0)\n- Requires: (P, Q, affine_PmQ) form a valid ladder state\n  (i.e., affine_PmQ contains the u-coordinate of P-Q)\n- Returns (P', Q') representing [2]P and P+Q in projective coordinates\n- Ensures: outputs P' and Q' are also valid projective points\n- Correctness: the u-coordinates of the outputs correspond to point doubling and\n  differential addition on the Montgomery curve\n- All operations are constant-time field operations\n\n**Mathematical Specification:**\nGiven valid projective points P=(U:W) and Q, plus the u-coordinate of (P-Q),\ncomputes P'=(U':W') representing [2]P and Q' representing P+Q.\n\nIn Montgomery curve arithmetic, only u-coordinates are needed for the ladder.\nThe Montgomery ladder invariant maintains that the difference Q-P is known.\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}",
   "rust_name": "curve25519_dalek::montgomery::differential_add_and_double",
   "lines": "L352-L390",
   "lean_name": "curve25519_dalek.montgomery.differential_add_and_double",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_source":
   "pub(crate) fn elligator_encode(r_0: &FieldElement) -> (MontgomeryPoint, Choice) {\n    let one = FieldElement::ONE;\n    let d_1 = &one + &r_0.square2(); /* 2r^2 */\n\n    let d = &MONTGOMERY_A_NEG * &(d_1.invert()); /* A/(1+2r^2) */\n\n    let d_sq = &d.square();\n    let au = &MONTGOMERY_A * &d;\n\n    let inner = &(d_sq + &au) + &one;\n    let eps = &d * &inner; /* eps = d^3 + Ad^2 + d */\n\n    let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);\n\n    let zero = FieldElement::ZERO;\n    let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/\n    let mut u = &d + &Atemp; /* d, or d+A if nonsquare */\n    let u_neg = -&u;\n    u.conditional_assign(&u_neg, !eps_is_sq); /* d, or -d-A if nonsquare */\n\n    (MontgomeryPoint(u.to_bytes()), eps_is_sq)\n}",
   "rust_name": "curve25519_dalek::montgomery::elligator_encode",
   "lines": "L263-L284",
   "lean_name": "curve25519_dalek.montgomery.elligator_encode",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square2",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A",
    "curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_select",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::clone::Clone for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::clone::Clone for curve25519_dalek::ristretto::CompressedRistretto}::clone",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::cmp::Eq for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCmpPartialEqCompressedRistretto",
    "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCmpEq.assert_receiver_is_total_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::cmp::Eq for curve25519_dalek::ristretto::CompressedRistretto}::assert_receiver_is_total_eq",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCmpEq.assert_receiver_is_total_eq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::cmp::PartialEq<curve25519_dalek::ristretto::CompressedRistretto> for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCmpPartialEqCompressedRistretto",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCmpPartialEqCompressedRistretto.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::cmp::PartialEq<curve25519_dalek::ristretto::CompressedRistretto> for curve25519_dalek::ristretto::CompressedRistretto}::eq",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCmpPartialEqCompressedRistretto.eq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl TryFrom<&[u8]> for CompressedRistretto {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }\n}",
   "rust_name": "curve25519_dalek::ristretto::{core::convert::TryFrom<&0 (",
   "lines": "L357-L363",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreConvertTryFromShared0SliceU8TryFromSliceError",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreConvertTryFromShared0SliceU8TryFromSliceError.try_from"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
   "rust_name": "curve25519_dalek::ristretto::{core::convert::TryFrom<&0 (",
   "lines": "L360-L362",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreConvertTryFromShared0SliceU8TryFromSliceError.try_from",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.from_slice"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl Default for CompressedRistretto {\n    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::default::Default for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L351-L355",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::default::Default for curve25519_dalek::ristretto::CompressedRistretto}::default",
   "lines": "L352-L354",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::marker::Copy for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone, Eq, PartialEq, Hash)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::marker::StructuralPartialEq for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L219-L219",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.CoreMarkerStructuralPartialEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl Identity for CompressedRistretto {\n    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::traits::Identity for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L345-L349",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::traits::Identity for curve25519_dalek::ristretto::CompressedRistretto}::identity",
   "lines": "L346-L348",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl ConstantTimeEq for CompressedRistretto {\n    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{subtle::ConstantTimeEq for curve25519_dalek::ristretto::CompressedRistretto}",
   "lines": "L222-L226",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{subtle::ConstantTimeEq for curve25519_dalek::ristretto::CompressedRistretto}::ct_eq",
   "lines": "L223-L225",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.ristretto.CompressedRistretto.as_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec (cr : CompressedRistretto) :\n    as_bytes cr ⦃ b =>\n    b = cr ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.CompressedRistretto.as_bytes`**:\n    • The operation never panics (always returns successfully)\n    • as_bytes(cr) = cr, i.e., the function is the identity operation\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::as_bytes",
   "lines": "L235-L237",
   "lean_name": "curve25519_dalek.ristretto.CompressedRistretto.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem decompress_spec (comp : CompressedRistretto) :\n    decompress comp ⦃ result =>\n    (¬comp.IsValid → result = none) ∧\n    (comp.IsValid →\n        ∃ rist,\n        result = some rist ∧\n        RistrettoPoint.IsValid rist ∧\n        decompress_pure comp = some rist.toPoint) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/Decompress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.CompressedRistretto.decompress`**:\n- The function always succeeds for all U8x32 input arrays (no panic)\n- If the input is not valid, then the output is none\n- If the input is valid, then the output is a valid Ristretto point that reflects the\n  output of the pure mathematical decompression function\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::decompress",
   "lines": "L257-L271",
   "lean_name": "curve25519_dalek.ristretto.CompressedRistretto.decompress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.decompress.step_1",
    "curve25519_dalek.ristretto.decompress.step_2"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        #[allow(clippy::redundant_closure)]\n        bytes.try_into().map(|b| CompressedRistretto(b))\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::from_slice",
   "lines": "L245-L248",
   "lean_name": "curve25519_dalek.ristretto.CompressedRistretto.from_slice",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedRistretto"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "        bytes.try_into().map(|b| CompressedRistretto(b))",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::from_slice::{core::ops::function::FnOnce<(",
   "lines": "L247-L247",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedRistretto",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedRistretto.call_once"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "        bytes.try_into().map(|b| CompressedRistretto(b))",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::from_slice::{core::ops::function::FnOnce<(",
   "lines": "L247-L247",
   "lean_name":
   "curve25519_dalek.ristretto.CompressedRistretto.from_slice.closure.Insts.CoreOpsFunctionFnOnceTupleArrayU832CompressedRistretto.call_once",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (cr : CompressedRistretto) :\n    to_bytes cr ⦃ b =>\n    b = cr ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.CompressedRistretto.to_bytes`**:\n    • The operation never panics (always returns successfully)\n    • to_bytes(cr) = cr, i.e., the function is the identity operation\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::to_bytes",
   "lines": "L230-L232",
   "lean_name": "curve25519_dalek.ristretto.CompressedRistretto.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::clone::Clone for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L493-L493",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::clone::Clone for curve25519_dalek::ristretto::RistrettoPoint}::clone",
   "lines": "L493-L493",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "impl Eq for RistrettoPoint {}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::cmp::Eq for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L881-L881",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCmpPartialEqRistrettoPoint"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl PartialEq for RistrettoPoint {\n    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::cmp::PartialEq<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L858-L862",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCmpPartialEqRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCmpPartialEqRistrettoPoint.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::cmp::PartialEq<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::eq",
   "lines": "L859-L861",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCmpPartialEqRistrettoPoint.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl Default for RistrettoPoint {\n    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::default::Default for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L848-L852",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::default::Default for curve25519_dalek::ristretto::RistrettoPoint}::default",
   "lines": "L849-L851",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "#[derive(Copy, Clone)]",
   "rust_name":
   "curve25519_dalek::ristretto::{core::marker::Copy for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L493-L493",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl AddAssign<$rhs> for $lhs {\n            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::AddAssign<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L43-L47",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddAssignRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddAssignRistrettoPoint.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::AddAssign<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::add_assign",
   "lines": "L44-L46",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddAssignRistrettoPoint.add_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddAssignShared0RistrettoPoint.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl AddAssign<&RistrettoPoint> for RistrettoPoint {\n    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::AddAssign<&0 (curve25519_dalek::ristretto::RistrettoPoint)> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L901-L905",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddAssignShared0RistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddAssignShared0RistrettoPoint.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::AddAssign<&0 (curve25519_dalek::ristretto::RistrettoPoint)> for curve25519_dalek::ristretto::RistrettoPoint}::add_assign",
   "lines": "L902-L904",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddAssignShared0RistrettoPoint.add_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithAddSharedARistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Add<$rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L31-L36",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddRistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::add",
   "lines": "L33-L35",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddRistrettoPointRistrettoPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithAddSharedARistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Add<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<&'b (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L17-L22",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddSharedBRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddSharedBRistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<&'b (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::add",
   "lines": "L19-L21",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddSharedBRistrettoPointRistrettoPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithAddSharedARistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl MulAssign<$rhs> for $lhs {\n            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L117-L121",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulAssignScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulAssignScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::ristretto::RistrettoPoint}::mul_assign",
   "lines": "L118-L120",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulAssignScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl<'a> MulAssign<&'a Scalar> for RistrettoPoint {\n    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::MulAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L959-L964",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulAssignSharedAScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::MulAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::ristretto::RistrettoPoint}::mul_assign",
   "lines": "L960-L963",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L105-L110",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulScalarRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulScalarRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::mul",
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulScalarRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L91-L96",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulSharedBScalarRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulSharedBScalarRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::mul",
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithMulSharedBScalarRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithMulSharedAScalarRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl Neg for RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn neg(self) -> RistrettoPoint {\n        -&self\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Neg<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L951-L957",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithNegRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithNegRistrettoPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source": "    fn neg(self) -> RistrettoPoint {\n        -&self\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Neg<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::neg",
   "lines": "L954-L956",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithNegRistrettoPoint.neg",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithNegRistrettoPoint.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl SubAssign<$rhs> for $lhs {\n            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::SubAssign<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L80-L84",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubAssignRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubAssignRistrettoPoint.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::SubAssign<curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::sub_assign",
   "lines": "L81-L83",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubAssignRistrettoPoint.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubAssignShared0RistrettoPoint.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl SubAssign<&RistrettoPoint> for RistrettoPoint {\n    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::SubAssign<&0 (curve25519_dalek::ristretto::RistrettoPoint)> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L923-L927",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubAssignShared0RistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubAssignShared0RistrettoPoint.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::SubAssign<&0 (curve25519_dalek::ristretto::RistrettoPoint)> for curve25519_dalek::ristretto::RistrettoPoint}::sub_assign",
   "lines": "L924-L926",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubAssignShared0RistrettoPoint.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithSubSharedARistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Sub<$rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L68-L73",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubRistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::sub",
   "lines": "L70-L72",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubRistrettoPointRistrettoPoint.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithSubSharedARistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Sub<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<&'b (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L54-L59",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubSharedBRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubSharedBRistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Sub<&'b (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::sub",
   "lines": "L56-L58",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithSubSharedBRistrettoPointRistrettoPoint.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0RistrettoPoint.Insts.CoreOpsArithSubSharedARistrettoPointRistrettoPoint.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl Identity for RistrettoPoint {\n    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::traits::Identity for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L842-L846",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.Curve25519_dalekTraitsIdentity",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::traits::Identity for curve25519_dalek::ristretto::RistrettoPoint}::identity",
   "lines": "L843-L845",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.Curve25519_dalekTraitsIdentity.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.Curve25519_dalekTraitsIdentity.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl ConditionallySelectable for RistrettoPoint {\n    /// Conditionally select between `self` and `other`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use subtle::ConditionallySelectable;\n    /// use subtle::Choice;\n    /// #\n    /// # use curve25519_dalek::traits::Identity;\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// # use curve25519_dalek::constants;\n    /// # fn main() {\n    ///\n    /// let A = RistrettoPoint::identity();\n    /// let B = constants::RISTRETTO_BASEPOINT_POINT;\n    ///\n    /// let mut P = A;\n    ///\n    /// P = RistrettoPoint::conditional_select(&A, &B, Choice::from(0));\n    /// assert_eq!(P, A);\n    /// P = RistrettoPoint::conditional_select(&A, &B, Choice::from(1));\n    /// assert_eq!(P, B);\n    /// # }\n    /// ```\n    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{subtle::ConditionallySelectable for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L1167-L1199",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreMarkerCopy",
    "curve25519_dalek.ristretto.RistrettoPoint.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{subtle::ConditionallySelectable for curve25519_dalek::ristretto::RistrettoPoint}::conditional_select",
   "lines": "L1192-L1198",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "impl ConstantTimeEq for RistrettoPoint {\n    /// Test equality between two `RistrettoPoint`s.\n    ///\n    /// # Returns\n    ///\n    /// * `Choice(1)` if the two `RistrettoPoint`s are equal;\n    /// * `Choice(0)` otherwise.\n    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }\n}",
   "rust_name":
   "curve25519_dalek::ristretto::{subtle::ConstantTimeEq for curve25519_dalek::ristretto::RistrettoPoint}",
   "lines": "L864-L879",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.RistrettoPoint.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{subtle::ConstantTimeEq for curve25519_dalek::ristretto::RistrettoPoint}::ct_eq",
   "lines": "L871-L878",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem compress_spec (rist : RistrettoPoint) (h_rist_valid : rist.IsValid) :\n    compress rist ⦃ result =>\n    result.IsValid ∧\n    math.compress_pure rist.toPoint = U8x32_as_Nat result ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Compress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.compress`**:\n• The function always succeeds (no panic) for all valid RistrettoPoint inputs\n• The output is a valid CompressedRistretto 32-byte representation\n• The output accurately reflects the output of the pure mathematical compression function\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let z_plus_y = Z + &Y;\n        let z_minus_y = Z - &Y;\n        let u1 = &z_plus_y * &z_minus_y;\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let u2_sq = u2.square();\n        let u1_u2_sq = &u1 * &u2_sq;\n        let (_, invsqrt) = u1_u2_sq.invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let i2_T = &i2 * T;\n        let z_inv = &i1 * &i2_T;\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let t_z_inv = T * &z_inv;\n        let rotate = t_z_inv.is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        let x_z_inv = &X * &z_inv;\n        let y_sign = x_z_inv.is_negative();\n        let y_neg = -&Y;\n        Y.conditional_assign(&y_neg, y_sign);\n\n        let z_minus_y2 = Z - &Y;\n        let mut s = &den_inv * &z_minus_y2;\n        let s_is_negative = s.is_negative();\n        let s_neg = -&s;\n        s.conditional_assign(&s_neg, s_is_negative);\n\n        CompressedRistretto(s.to_bytes())\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::compress",
   "lines": "L498-L542",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.compress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.field.FieldElement51.invsqrt",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
    "curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D",
    "curve25519_dalek.field.FieldElement51.is_negative",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem coset4_spec (self : RistrettoPoint) (h_self_valid : self.IsValid) :\n    coset4 self ⦃ result =>\n    result.val[0].IsValid ∧ result.val[0].toPoint = self.toPoint + EIGHT_TORSION.val[0].toPoint ∧\n    result.val[1].IsValid ∧ result.val[1].toPoint = self.toPoint + EIGHT_TORSION.val[2].toPoint ∧\n    result.val[2].IsValid ∧ result.val[2].toPoint = self.toPoint + EIGHT_TORSION.val[4].toPoint ∧\n    result.val[3].IsValid ∧ result.val[3].toPoint = self.toPoint + EIGHT_TORSION.val[6].toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Coset4.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.coset4`**:\n• The function always succeeds (no panic) for valid RistrettoPoint input self\n• The four output Edwards points are all valid and are given by\n\n  - self + T₀ = self (where T₀ is the identity)\n  - self + T₂ (where T₂ is EIGHT_TORSION[2])\n  - self + T₄ (where T₄ is EIGHT_TORSION[4])\n  - self + T₆ (where T₆ is EIGHT_TORSION[6])\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::coset4",
   "lines": "L659-L666",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.coset4",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithAddEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem elligator_ristretto_flavor_spec\n    (s : backend.serial.u64.field.FieldElement51)\n    (h_s_valid : s.IsValid) :\n    elligator_ristretto_flavor s ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = (elligator_ristretto_flavor_pure s.toField).val ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/ElligatorRistrettoFlavor.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.elligator_ristretto_flavor`**:\n• The function always succeeds (no panic) for all valid field element inputs\n• The output is indeed a valid RistrettoPoint (i.e., an even Edwards point that lies on the curve)\n• The output point corresponds to `elligator_ristretto_flavor_pure s.toField`, bridging\n  the implementation to the pure mathematical Elligator map defined in Representation.lean\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r_0_sq = r_0.square();\n        let r = i * &r_0_sq;\n        let r_plus_one = &r + &one;\n        let N_s = &r_plus_one * one_minus_d_sq;\n        let d_times_r = d * &r;\n        let c_minus_dr = &c - &d_times_r;\n        let r_plus_d = &r + d;\n        let D = &c_minus_dr * &r_plus_d;\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        let s_prime_neg = -&s_prime;\n        s_prime.conditional_assign(&s_prime_neg, s_prime_is_pos);\n\n        let not_sq = !Ns_D_is_sq;\n        s.conditional_assign(&s_prime, not_sq);\n        c.conditional_assign(&r, not_sq);\n\n        let r_minus_one = &r - &one;\n        let c_r_minus_one = &c * &r_minus_one;\n        let c_r_minus_one_d = &c_r_minus_one * d_minus_one_sq;\n        let N_t = &c_r_minus_one_d - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        let s_plus_s = &s + &s;\n        let cp_X = &s_plus_s * &D;\n        let cp_Z = &N_t * &constants::SQRT_AD_MINUS_ONE;\n        let cp_Y = &FieldElement::ONE - &s_sq;\n        let cp_T = &FieldElement::ONE + &s_sq;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: cp_X,\n                Z: cp_Z,\n                Y: cp_Y,\n                T: cp_T,\n            }\n            .as_extended(),\n        )\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::elligator_ristretto_flavor",
   "lines": "L676-L728",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.elligator_ristretto_flavor",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.constants.MINUS_ONE",
    "curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
    "curve25519_dalek.field.FieldElement51.is_negative",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_uniform_bytes_spec (bytes : Array U8 64#usize) :\n    from_uniform_bytes bytes ⦃ (rist : RistrettoPoint) =>\n      rist.IsValid ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/FromUniformBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.from_uniform_bytes`**:\n- The function always succeeds (no panic) for arbitrary 64-byte inputs\n- The output is a mathematically valid Ristretto point (i.e., an even Edwards point that lies on the curve)\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::from_uniform_bytes",
   "lines": "L823-L839",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.from_uniform_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.ristretto.RistrettoPoint.elligator_ristretto_flavor",
    "curve25519_dalek.ristretto.RistrettoPoint.Insts.CoreOpsArithAddRistrettoPointRistrettoPoint.add"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_base_spec (s : scalar.Scalar)\n    (h_s_canonical : U8x32_as_Nat s.bytes < L) :\n    mul_base s ⦃ result =>\n    result.IsValid ∧\n    result.toPoint = (U8x32_as_Nat s.bytes) • constants.RISTRETTO_BASEPOINT_POINT.toPoint ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Mul_Base.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.mul_base`**:\n• The function always succeeds (no panic) for canonical input Scalars s\n• The result is a valid RistrettoPoint\n• The result = b + ... + b represents the Ristretto basepoint b added to itself s-times\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::mul_base",
   "lines": "L988-L998",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.mul_base",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.SharedAScalar.Insts.CoreOpsArithMulRistrettoPointRistrettoPoint.mul",
    "curve25519_dalek.constants.RISTRETTO_BASEPOINT_POINT"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem step_1_spec (c : CompressedRistretto) :\n    step_1 c ⦃ (s_encoding_is_canonical, s_is_negative, s) =>\n    (∀ i < 5, s[i]!.val < 2^51) ∧\n    s.IsValid ∧\n    (s.toField = ((U8x32_as_Nat c % 2^255 : ℕ) : ZMod p)) ∧\n    (s_encoding_is_canonical.val = 1#u8 ↔ U8x32_as_Nat c < p) ∧\n    (s_is_negative.val = 1#u8 ↔ math.is_negative s.toField) ∧\n    (ristretto.decompress_step1 c = some s.toField ↔\n      (s_encoding_is_canonical.val = 1#u8 ∧ s_is_negative.val = 0#u8)) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/Step1.lean",
   "spec_docstring":
   "/-- **Spec for `step_1`**\nReflects the Rust implementation:\n1.  Computes `s` from bytes.\n2.  Computes `s_encoding_is_canonical` (checks if bytes < p).\n3.  Computes `s_is_negative` (checks sign).\n\nIt proves two things:\n1.  **Low-Level Correctness**: The flags match the specific bitwise conditions (`< p`, `is_negative`).\n2.  **High-Level Correctness**: The function returns a valid result **iff** `decompress_step1` would return `some`.\n\nNamely:\n1. Existence: The function always succeeds\n2. Safety: The resulting field element has valid limb bounds\n3. Value Consistency: The field element `s` is the integer value of the bytes `c`\n4. Granular Flag Meanings\n5. The bridge that proves \"Passing the Rust checks\" iff \"decompress_step1 Succeeding\"\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }",
   "rust_name": "curve25519_dalek::ristretto::decompress::step_1",
   "lines": "L277-L295",
   "lean_name": "curve25519_dalek.ristretto.decompress.step_1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.as_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
    "curve25519_dalek.field.FieldElement51.is_negative"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem step_2_spec (s : backend.serial.u64.field.FieldElement51)\n    (h_s : ∀ i < 5, s[i]!.val < 2 ^ 52) :\n    step_2 s ⦃ (ok1, c, c1, pt) =>\n    (let s_val := s.toField\n     let u1 := 1 - s_val ^ 2\n     let u2 := 1 + s_val ^ 2\n     let v := (-Ed25519.d) * u1 ^ 2 - u2 ^ 2\n     (ok1.val = 1#u8 ↔ (v * u2 ^ 2 ≠ 0 ∧ IsSquare (v * u2 ^ 2))) ∧\n     (c.val = 1#u8 ↔ math.is_negative pt.T.toField) ∧\n     (c1.val = 1#u8 ↔ pt.Y.toField = 0)) ∧\n    (∀ (P : Point Ed25519), ristretto.decompress_step2 s.toField = some P ↔\n      (ok1.val = 1#u8 ∧ c.val = 0#u8 ∧ c1.val = 0#u8 ∧ pt.toPoint = P)) ∧\n    (ok1.val = 1#u8 ∧ c.val = 0#u8 ∧ c1.val = 0#u8 → RistrettoPoint.IsValid pt) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/Step2.lean",
   "spec_docstring":
   "/-- **Spec for `step_2`**\nReflects the Rust implementation:\n1.  Performs the algebraic lift (Elligator map) to compute a point `pt`.\n2.  Computes validity flags `ok1` (square exists), `c` (non-negative T), `c1` (non-zero Y).\n\nIt proves:\n1.  **Low-Level Correctness**: The flags correspond exactly to their mathematical definitions.\n2.  **High-Level Correctness**: The function returns a result that matches `decompress_step2` **iff** the flags indicate success.\n\nNamely:\n    • The function always succeeds (no panic) for any valid field element `s`\n    • ok1 is true if and only if the inverse square root of v · u2² exists\n    • c is true if and only if t is negative\n    • c1 is true if and only if y is zero\n    • pt is a valid RistrettoPoint when ok1 = 1, c = 0, and c1 = 0\nMoreover if the high-level function returns `some P`, then:\na) The Rust flags must be set to success (1, 0, 0)\nb) The Rust point `pt` must match the mathematical point `P`\nAnd conversely.\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_source":
   "    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as²\n        let u2 = &one + &ss; //  1 - as²    where a=-1\n        let u2_sqr = u2.square(); // (1 - as²)²\n\n        // v == ad(1+as²)² - (1-as²)²            where d=-121665/121666\n        let neg_d = -&constants::EDWARDS_D;\n        let u1_sq = u1.square();\n        let neg_d_u1_sq = &neg_d * &u1_sq;\n        let v = &neg_d_u1_sq - &u2_sqr;\n\n        let v_u2_sqr = &v * &u2_sqr;\n        let (ok, I) = v_u2_sqr.invsqrt(); // 1/sqrt(v*u_2²)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dx_v = &Dx * &v;\n        let Dy = &I * &Dx_v; // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s²/(ad(1+as²)² - (1-as²)²))\n        let s_plus_s = &s + &s;\n        let mut x = &s_plus_s * &Dx;\n        let x_neg = x.is_negative();\n        let x_negated = -&x;\n        x.conditional_assign(&x_negated, x_neg);\n\n        // y == (1-as²)/(1+as²)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as²) sqrt(4s²/(ad(1+as²)² - (1-as²)²)))/(1-as²)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }",
   "rust_name": "curve25519_dalek::ristretto::decompress::step_2",
   "lines": "L297-L342",
   "lean_name": "curve25519_dalek.ristretto.decompress.step_2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithSubSharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithAddSharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithNegFieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.Shared0FieldElement51.Insts.CoreOpsArithMulSharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.field.FieldElement51.invsqrt",
    "curve25519_dalek.field.FieldElement51.is_negative",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.Insts.SubtleConditionallySelectable.conditional_assign",
    "curve25519_dalek.field.FieldElement51.is_zero"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "#[derive(Copy, Clone, Hash)]",
   "rust_name":
   "curve25519_dalek::scalar::{core::clone::Clone for curve25519_dalek::scalar::Scalar}",
   "lines": "L194-L194",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreCloneClone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreCloneClone.clone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "#[derive(Copy, Clone, Hash)]",
   "rust_name":
   "curve25519_dalek::scalar::{core::clone::Clone for curve25519_dalek::scalar::Scalar}::clone",
   "lines": "L194-L194",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreCloneClone.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "impl Eq for Scalar {}",
   "rust_name":
   "curve25519_dalek::scalar::{core::cmp::Eq for curve25519_dalek::scalar::Scalar}",
   "lines": "L293-L293",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreCmpEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreCmpPartialEqScalar"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl PartialEq for Scalar {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::cmp::PartialEq<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L294-L298",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreCmpPartialEqScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreCmpPartialEqScalar.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::cmp::PartialEq<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::eq",
   "lines": "L295-L297",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreCmpPartialEqScalar.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl From<u128> for Scalar {\n    fn from(x: u128) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u128> for curve25519_dalek::scalar::Scalar}",
   "lines": "L546-L553",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU128",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU128.from"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn from(x: u128) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u128> for curve25519_dalek::scalar::Scalar}::from",
   "lines": "L547-L552",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU128.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl From<u16> for Scalar {\n    fn from(x: u16) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u16> for curve25519_dalek::scalar::Scalar}",
   "lines": "L498-L505",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU16",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU16.from"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn from(x: u16) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u16> for curve25519_dalek::scalar::Scalar}::from",
   "lines": "L499-L504",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU16.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl From<u32> for Scalar {\n    fn from(x: u32) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u32> for curve25519_dalek::scalar::Scalar}",
   "lines": "L507-L514",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU32",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU32.from"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn from(x: u32) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u32> for curve25519_dalek::scalar::Scalar}::from",
   "lines": "L508-L513",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU32.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    fn from(x: u64) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u64> for curve25519_dalek::scalar::Scalar}",
   "lines": "L516-L544",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU64",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU64.from"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn from(x: u64) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u64> for curve25519_dalek::scalar::Scalar}::from",
   "lines": "L538-L543",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU64.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl From<u8> for Scalar {\n    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u8> for curve25519_dalek::scalar::Scalar}",
   "lines": "L490-L496",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU8",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU8.from"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u8> for curve25519_dalek::scalar::Scalar}::from",
   "lines": "L491-L495",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreConvertFromU8.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl Default for Scalar {\n    fn default() -> Scalar {\n        Scalar::ZERO\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::default::Default for curve25519_dalek::scalar::Scalar}",
   "lines": "L484-L488",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreDefaultDefault",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreDefaultDefault.default"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "    fn default() -> Scalar {\n        Scalar::ZERO\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::default::Default for curve25519_dalek::scalar::Scalar}::default",
   "lines": "L485-L487",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreDefaultDefault.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "#[derive(Copy, Clone, Hash)]",
   "rust_name":
   "curve25519_dalek::scalar::{core::marker::Copy for curve25519_dalek::scalar::Scalar}",
   "lines": "L194-L194",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreMarkerCopy",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.Insts.CoreCloneClone"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl AddAssign<$rhs> for $lhs {\n            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::AddAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L43-L47",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddAssignScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddAssignScalar.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::AddAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::add_assign",
   "lines": "L44-L46",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddAssignScalar.add_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddAssignSharedAScalar.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl<'a> AddAssign<&'a Scalar> for Scalar {\n    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::AddAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}",
   "lines": "L332-L336",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddAssignSharedAScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddAssignSharedAScalar.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::AddAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}::add_assign",
   "lines": "L333-L335",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddAssignSharedAScalar.add_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddSharedBScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Add<$rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L31-L36",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::add",
   "lines": "L33-L35",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddScalarScalar.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithAddSharedAScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Add<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L17-L22",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddSharedBScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddSharedBScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::add",
   "lines": "L19-L21",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithAddSharedBScalarScalar.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithAddSharedAScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "impl Mul<AffinePoint> for Scalar {\n    type Output = EdwardsPoint;\n\n    #[inline]\n    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::ops::arith::Mul<curve25519_dalek::edwards::affine::AffinePoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L78-L85",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAffinePointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAffinePointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::ops::arith::Mul<curve25519_dalek::edwards::affine::AffinePoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L82-L84",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAffinePointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulShared0AffinePointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl MulAssign<$rhs> for $lhs {\n            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L117-L121",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAssignScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAssignScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::mul_assign",
   "lines": "L118-L120",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAssignScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl<'a> MulAssign<&'a Scalar> for Scalar {\n    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::MulAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}",
   "lines": "L315-L319",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAssignSharedAScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::MulAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}::mul_assign",
   "lines": "L316-L318",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulAssignSharedAScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L105-L110",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulEdwardsPointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::montgomery::MontgomeryPoint, curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L105-L110",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulMontgomeryPointMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulMontgomeryPointMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (scalar : Scalar) (P : montgomery.MontgomeryPoint) :\n    mul scalar P ⦃ res =>\n    let m:= (U8x32_as_Nat scalar.bytes) % 2^255\n    MontgomeryPoint.mkPoint res = m • (MontgomeryPoint.mkPoint P) ⦄\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulScalarMontgomeryPointMontgomeryPoint.mul`**:\n- No panic (always returns successfully given valid inputs)\n- Implements scalar multiplication via delegation to the underlying operation\n- The result is mathematically equivalent to [scalar]point\n- Mathematical properties of the result:\n  * The result encodes the u-coordinate of the scalar multiplication [scalar]point\n  * Mathematically equivalent to MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul\n  * If point has u-coordinate u₀ and scalar is n (as an integer ≤ 2^255), then the result\n    encodes u₀([n]point), the u-coordinate of the n-fold sum of point on the Montgomery curve\n  * The Montgomery ladder maintains the invariant that x0 and x1 represent points\n    differing by point throughout the computation\n  * The computation maintains constant-time guarantees inherited from the underlying\n    Montgomery ladder implementation\n  * The returned MontgomeryPoint is a valid 32-byte encoding with value reduced modulo 2^255\n-/",
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::montgomery::MontgomeryPoint, curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulMontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1Scalar.Insts.CoreOpsArithMulShared0MontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L105-L110",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulRistrettoPointRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulRistrettoPointRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedARistrettoPointRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L105-L110",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "impl Mul<&AffinePoint> for Scalar {\n    type Output = EdwardsPoint;\n\n    #[inline]\n    fn mul(self, rhs: &AffinePoint) -> EdwardsPoint {\n        rhs.to_edwards() * self\n    }\n}",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::ops::arith::Mul<&0 (curve25519_dalek::edwards::affine::AffinePoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L87-L94",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulShared0AffinePointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulShared0AffinePointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_source":
   "    fn mul(self, rhs: &AffinePoint) -> EdwardsPoint {\n        rhs.to_edwards() * self\n    }",
   "rust_name":
   "curve25519_dalek::edwards::affine::{core::ops::arith::Mul<&0 (curve25519_dalek::edwards::affine::AffinePoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L91-L93",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulShared0AffinePointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.affine.AffinePoint.to_edwards",
    "curve25519_dalek.edwards.EdwardsPoint.Insts.CoreOpsArithMulScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'b (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L91-L96",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBEdwardsPointEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'b (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBEdwardsPointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&'b (curve25519_dalek::montgomery::MontgomeryPoint), curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L91-L96",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBMontgomeryPointMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBMontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&'b (curve25519_dalek::montgomery::MontgomeryPoint), curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBMontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared1Scalar.Insts.CoreOpsArithMulShared0MontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'b (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::scalar::Scalar}",
   "lines": "L91-L96",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBRistrettoPointRistrettoPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBRistrettoPointRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'b (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBRistrettoPointRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedARistrettoPointRistrettoPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L91-L96",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::mul",
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithMulSharedBScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithMulSharedAScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl Neg for Scalar {\n    type Output = Scalar;\n    fn neg(self) -> Scalar {\n        -&self\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Neg<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L382-L387",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithNegScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithNegScalar.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "    fn neg(self) -> Scalar {\n        -&self\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Neg<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::neg",
   "lines": "L384-L386",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithNegScalar.neg",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithNegScalar.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl SubAssign<$rhs> for $lhs {\n            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::SubAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L80-L84",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubAssignScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubAssignScalar.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::SubAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::sub_assign",
   "lines": "L81-L83",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubAssignScalar.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubAssignSharedAScalar.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl<'a> SubAssign<&'a Scalar> for Scalar {\n    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::SubAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}",
   "lines": "L352-L356",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubAssignSharedAScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubAssignSharedAScalar.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::SubAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}::sub_assign",
   "lines": "L353-L355",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubAssignSharedAScalar.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubSharedBScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl Sub<$rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L68-L73",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::sub",
   "lines": "L70-L72",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithSubSharedAScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "        impl<'b> Sub<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}",
   "lines": "L54-L59",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubSharedBScalarScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubSharedBScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_source":
   "            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::sub",
   "lines": "L56-L58",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsArithSubSharedBScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0Scalar.Insts.CoreOpsArithSubSharedAScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::index::Index<usize, u8> for curve25519_dalek::scalar::Scalar}",
   "lines": "L306-L313",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.CoreOpsIndexIndexUsizeU8",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsIndexIndexUsizeU8.index"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::index::Index<usize, u8> for curve25519_dalek::scalar::Scalar}::index",
   "lines": "L310-L312",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.CoreOpsIndexIndexUsizeU8.index",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConditionallySelectable for curve25519_dalek::scalar::Scalar}",
   "lines": "L389-L398",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.SubtleConditionallySelectable",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreMarkerCopy",
    "curve25519_dalek.scalar.Scalar.Insts.SubtleConditionallySelectable.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConditionallySelectable for curve25519_dalek::scalar::Scalar}::conditional_select",
   "lines": "L390-L397",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.SubtleConditionallySelectable.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.SubtleConditionallySelectable.conditional_select_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConditionallySelectable for curve25519_dalek::scalar::Scalar}::conditional_select",
   "lines": "L393-L395",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.SubtleConditionallySelectable.conditional_select_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConstantTimeEq for curve25519_dalek::scalar::Scalar}",
   "lines": "L300-L304",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.SubtleConstantTimeEq",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ct_eq_spec (s s' : scalar.Scalar) :\n    ct_eq s s' ⦃ c =>\n    c = Choice.one ↔ s.bytes = s'.bytes ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/CtEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.Insts.SubtleConstantTimeEq.ct_eq`**:\n- No panic (always returns successfully)\n- Returns `Choice` representing equality in constant time\n- The result is Choice.one (true) if and only if the two scalars are equal (same byte representation)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConstantTimeEq for curve25519_dalek::scalar::Scalar}::ct_eq",
   "lines": "L301-L303",
   "lean_name":
   "curve25519_dalek.scalar.Scalar.Insts.SubtleConstantTimeEq.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "impl Zeroize for Scalar {\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}",
   "rust_name":
   "curve25519_dalek::scalar::{zeroize::Zeroize for curve25519_dalek::scalar::Scalar}",
   "lines": "L556-L560",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.ZeroizeZeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.ZeroizeZeroize.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{zeroize::Zeroize for curve25519_dalek::scalar::Scalar}::zeroize",
   "lines": "L557-L559",
   "lean_name": "curve25519_dalek.scalar.Scalar.Insts.ZeroizeZeroize.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ONE_spec : U8x32_as_Nat ONE.bytes = 1 := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/One.lean",
   "spec_docstring":
   "/-- **Spec for `scalar.Scalar.ONE`**:\n\nThe ONE constant represents the scalar 1.\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub const ONE: Self = Self {\n        bytes: [\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n    };",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ONE",
   "lines": "L567-L572",
   "lean_name": "curve25519_dalek.scalar.Scalar.ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ZERO_spec : U8x32_as_Nat ZERO.bytes = 0 := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Zero.lean",
   "spec_docstring":
   "/-- **Spec for `scalar.Scalar.ZERO`**:\n\nThe ZERO constant represents the scalar 0.\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "    pub const ZERO: Self = Self { bytes: [0u8; 32] };",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ZERO",
   "lines": "L564-L564",
   "lean_name": "curve25519_dalek.scalar.Scalar.ZERO",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.ZERO_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source": "    pub const ZERO: Self = Self { bytes: [0u8; 32] };",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ZERO",
   "lines": "L564-L564",
   "lean_name": "curve25519_dalek.scalar.Scalar.ZERO_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec (s : Scalar) :\n    as_bytes s ⦃ b =>\n    b = s.bytes ∧ mk b = s ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.as_bytes`**:\n- No panic (always returns successfully)\n- The result is the byte representation of the scalar (s.bytes)\n- Converting the result back to a Scalar via the constructor yields the original scalar\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.bytes\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_bytes",
   "lines": "L706-L708",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        let mut i = 0;\n        while i < 32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n            i += 1;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        let mut i = 0;\n        while i < 63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n            i += 1;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16",
   "lines": "L995-L1031",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsIndexIndexUsizeU8.index",
    "curve25519_dalek.scalar.Scalar.as_radix_16_loop0",
    "curve25519_dalek.scalar.Scalar.as_radix_16_loop1"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16::bot_half",
   "lines": "L1003-L1005",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16.bot_half",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16::top_half",
   "lines": "L1007-L1009",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16.top_half",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while i < 32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16",
   "lines": "L1012-L1016",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16_loop0",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.Insts.CoreOpsIndexIndexUsizeU8.index",
    "curve25519_dalek.scalar.Scalar.as_radix_16.bot_half",
    "curve25519_dalek.scalar.Scalar.as_radix_16.top_half"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while i < 63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16",
   "lines": "L1021-L1026",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16_loop1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = (256 + w - 1) / w;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        // TODO: upstream uses `match w { 8 => ..., _ => ... }` — see\n        // TODO comment in to_radix_2w_size_hint for why we use if/else.\n        if w == 8 {\n            digits[digits_count] += carry as i8;\n        } else {\n            digits[digits_count - 1] += (carry << w) as i8;\n        }\n\n        digits\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_2w",
   "lines": "L1080-L1140",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_2w",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.as_radix_16",
    "curve25519_dalek.scalar.read_le_u64_into",
    "curve25519_dalek.scalar.Scalar.as_radix_2w_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_2w",
   "lines": "L1099-L1121",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_2w_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub fn batch_invert(inputs: &mut [Scalar]) -> Scalar {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n\n        let n = inputs.len();\n        let one: UnpackedScalar = Scalar::ONE.unpack().as_montgomery();\n\n        let mut scratch = vec![one; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = Scalar::ONE.unpack().as_montgomery();\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        // (using while loop to avoid iter_mut().zip() which pulls in Iterator traits)\n        let mut i = 0;\n        while i < n {\n            let input = &mut inputs[i];\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n            i += 1;\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        acc = acc.montgomery_invert().from_montgomery();\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place (using while loop to avoid .rev() which causes Charon trait mismatch)\n        let mut i = n;\n        while i > 0 {\n            i -= 1;\n            let input = &mut inputs[i];\n            let scratch_val = &scratch[i];\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch_val).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        Zeroize::zeroize(&mut scratch);\n\n        ret\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "lines": "L788-L845",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.scalar.Scalar.ONE",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.as_montgomery",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.CoreCloneClone",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop0",
    "curve25519_dalek.scalar.Scalar52.pack",
    "curve25519_dalek.scalar.Scalar.ZERO",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop1",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.Insts.ZeroizeZeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while i < n {\n            let input = &mut inputs[i];\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "lines": "L808-L818",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert_loop0",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.batch_invert_loop0.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while i < n {\n            let input = &mut inputs[i];\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n            i += 1;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "lines": "L808-L818",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert_loop0.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.as_montgomery",
    "curve25519_dalek.scalar.Scalar52.pack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while i > 0 {\n            i -= 1;\n            let input = &mut inputs[i];\n            let scratch_val = &scratch[i];\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch_val).pack();\n            acc = tmp;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "lines": "L832-L839",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert_loop1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.batch_invert_loop1.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while i > 0 {\n            i -= 1;\n            let input = &mut inputs[i];\n            let scratch_val = &scratch[i];\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch_val).pack();\n            acc = tmp;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "lines": "L832-L839",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert_loop1.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_mod_order_spec (b : Array U8 32#usize) :\n    from_bytes_mod_order b ⦃ s =>\n    U8x32_as_Nat s.bytes ≡ U8x32_as_Nat b [MOD L] ∧ U8x32_as_Nat s.bytes < L ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/FromBytesModOrder.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.from_bytes_mod_order`**:\n- No panic (always returns successfully)\n- The result scalar s, when converted to nat, equals the input bytes converted to nat modulo L\n- The result scalar s is less than L (the group order) -/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::from_bytes_mod_order",
   "lines": "L237-L246",
   "lean_name": "curve25519_dalek.scalar.Scalar.from_bytes_mod_order",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.reduce",
    "curve25519_dalek.scalar.Scalar.Insts.CoreOpsIndexIndexUsizeU8.index"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_mod_order_wide_spec (b : Array U8 64#usize) :\n    from_bytes_mod_order_wide b ⦃ s =>\n    U8x32_as_Nat s.bytes ≡ U8x64_as_Nat b [MOD L] ∧\n    U8x32_as_Nat s.bytes < L ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Scalar/Scalar/FromBytesModOrderWide.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.from_bytes_mod_order_wide`**:\n- No panic (always returns successfully)\n- The result scalar s, when converted to nat, equals the input bytes converted to nat modulo L\n- The result scalar s is less than L (the group order) -/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::from_bytes_mod_order_wide",
   "lines": "L250-L252",
   "lean_name": "curve25519_dalek.scalar.Scalar.from_bytes_mod_order_wide",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_canonical_bytes_spec (b : Array U8 32#usize) :\n    from_canonical_bytes b ⦃ s =>\n    (U8x32_as_Nat b < L → s.is_some = Choice.one ∧ s.value.bytes = b) ∧\n    (L ≤ U8x32_as_Nat b → s.is_some = Choice.zero) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/FromCanonicalBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.from_canonical_bytes`**:\n- No panic (always returns successfully)\n- When the input bytes represent a canonical value (< L), the function returns a CtOption Scalar\n  where is_some = Choice.one and the scalar's byte representation equals the input bytes\n- When the input bytes represent a non-canonical value (≥ L), the function returns a CtOption Scalar\n  where is_some = Choice.zero (i.e., None)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::from_canonical_bytes",
   "lines": "L261-L265",
   "lean_name": "curve25519_dalek.scalar.Scalar.from_canonical_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.is_canonical"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invert_spec (s : Scalar) (h : U8x32_as_Nat s.bytes % L ≠ 0) :\n    invert s ⦃ s' =>\n    U8x32_as_Nat s.bytes * U8x32_as_Nat s'.bytes ≡ 1 [MOD L] ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Invert.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.invert`**:\n- Precondition: The input scalar s must be non-zero modulo L (inverting zero has undefined behavior)\n- No panic (returns successfully for non-zero input)\n- The result s' satisfies the multiplicative inverse property:\n  U8x32_as_Nat(s.bytes) * U8x32_as_Nat(s'.bytes) ≡ 1 (mod L)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub fn invert(&self) -> Scalar {\n        self.unpack().invert().pack()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::invert",
   "lines": "L747-L749",
   "lean_name": "curve25519_dalek.scalar.Scalar.invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.scalar.Scalar52.invert",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_canonical_spec (s : Scalar) :\n    is_canonical s ⦃ c =>\n    (c = Choice.one ↔ U8x32_as_Nat s.bytes < L) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/IsCanonical.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.is_canonical`**:\n- No panic (always returns successfully)\n- Returns Choice.one if and only if the scalar's bytes represent a value less than L (the group order)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::is_canonical",
   "lines": "L1158-L1160",
   "lean_name": "curve25519_dalek.scalar.Scalar.is_canonical",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.reduce",
    "curve25519_dalek.scalar.Scalar.Insts.SubtleConstantTimeEq.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::non_adjacent_form",
   "lines": "L931-L983",
   "lean_name": "curve25519_dalek.scalar.Scalar.non_adjacent_form",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.read_le_u64_into",
    "curve25519_dalek.scalar.Scalar.non_adjacent_form_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::non_adjacent_form",
   "lines": "L947-L980",
   "lean_name": "curve25519_dalek.scalar.Scalar.non_adjacent_form_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.non_adjacent_form_loop.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::non_adjacent_form",
   "lines": "L947-L980",
   "lean_name": "curve25519_dalek.scalar.Scalar.non_adjacent_form_loop.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem reduce_spec (s : Scalar) :\n    reduce s ⦃ s' =>\n      U8x32_as_Nat s'.bytes ≡ U8x32_as_Nat s.bytes [MOD L] ∧\n      U8x32_as_Nat s'.bytes < L ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Reduce.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::reduce",
   "lines": "L1149-L1154",
   "lean_name": "curve25519_dalek.scalar.Scalar.reduce",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.constants.R",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (s : Scalar) :\n    to_bytes s ⦃ a =>\n    a = s.bytes ∧ mk a = s ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.to_bytes`**:\n- No panic (always returns successfully)\n- The result array a is the byte array representation of the scalar (s.bytes)\n- Converting the result a back to a Scalar via the constructor yields the original scalar s\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::to_bytes",
   "lines": "L691-L693",
   "lean_name": "curve25519_dalek.scalar.Scalar.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        // TODO: upstream uses `match w { 4..=7 => ..., 8 => ... }` but Aeneas\n        // translates usize match arms as scalar patterns which fail Lean's\n        // dependent elimination for Usize (see FIXME in\n        // aeneas/backends/lean/Aeneas/Std/Scalar/Notations.lean:131-142).\n        // Using if/else avoids the issue.\n        let digits_count = if w <= 7 {\n            (256 + w - 1) / w\n        } else if w == 8 {\n            // See comment in to_radix_2w on handling the terminal carry.\n            (256 + w - 1) / w + 1_usize\n        } else {\n            panic!(\"invalid radix parameter\")\n        };\n\n        debug_assert!(digits_count <= 64);\n        digits_count\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::to_radix_2w_size_hint",
   "lines": "L1036-L1056",
   "lean_name": "curve25519_dalek.scalar.Scalar.to_radix_2w_size_hint",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem unpack_spec (s : Scalar) :\n    unpack s ⦃ u =>\n    Scalar52_as_Nat u = U8x32_as_Nat s.bytes ∧\n    (∀ i < 5, u[i]!.val < 2 ^ 62) ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Unpack.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.unpack`**:\n- No panic (always returns successfully)\n- Packing the result back yields the original scalar: pack(u) = s\n- Both the packed s and the unpacked u represent the same natural number\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::unpack",
   "lines": "L1143-L1145",
   "lean_name": "curve25519_dalek.scalar.Scalar.unpack",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invert_spec (u : Scalar52) (h : Scalar52_as_Nat u % L ≠ 0) (hu : ∀ i < 5, u[i]!.val < 2 ^ 62) :\n    invert u ⦃ u' =>\n    (Scalar52_as_Nat u * Scalar52_as_Nat u') ≡ 1 [MOD L] ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Invert.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.invert`**:\n- Precondition: The unpacked input scalar u must be non-zero modulo L (inverting zero has undefined behavior)\n- No panic (returns successfully for non-zero input)\n- The result u' satisfies the multiplicative inverse property:\n  Scalar52_as_Nat(u) * Scalar52_as_Nat(u') ≡ 1 (mod L)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::invert",
   "lines": "L1232-L1234",
   "lean_name": "curve25519_dalek.scalar.Scalar52.invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.as_montgomery",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem montgomery_invert_spec (u : Scalar52) (h : Scalar52_as_Nat u % L ≠ 0)\n    (h_bounds : ∀ i < 5, u[i]!.val < 2 ^ 62) :\n    montgomery_invert u ⦃ u' =>\n    (Scalar52_as_Nat u * Scalar52_as_Nat u') % L = (R * R) % L ∧\n    (∀ i < 5, u'[i]!.val < 2 ^ 62) ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomeryInvert.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_invert`**:\n- Precondition: u must be non-zero modulo L (i.e., represent a non-zero value in Montgomery form)\n- No panic (always returns successfully for non-zero inputs)\n- The result u' satisfies the property that Montgomery multiplication of u and u'\n  yields R mod L (the Montgomery representation of 1)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            let mut i = 0;\n            while i <  squarings {\n                *y = y.montgomery_square();\n                i += 1;\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_invert",
   "lines": "L1174-L1229",
   "lean_name": "curve25519_dalek.scalar.Scalar52.montgomery_invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_square",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            let mut i = 0;\n            while i <  squarings {\n                *y = y.montgomery_square();\n                i += 1;\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_invert::square_multiply",
   "lines": "L1191-L1198",
   "lean_name":
   "curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "            while i <  squarings {\n                *y = y.montgomery_square();\n                i += 1;\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_invert::square_multiply",
   "lines": "L1193-L1196",
   "lean_name":
   "curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply_loop.mutual"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "            while i <  squarings {\n                *y = y.montgomery_square();\n                i += 1;\n            }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_invert::square_multiply",
   "lines": "L1193-L1196",
   "lean_name":
   "curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply_loop.mutual",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_square"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem pack_spec (u : backend.serial.u64.scalar.Scalar52) :\n    pack u ⦃ s =>\n    U8x32_as_Nat s.bytes ≡ Scalar52_as_Nat u [MOD L] ∧\n    U8x32_as_Nat s.bytes < L ⦄ := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Pack.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.pack`**:\n- No panic (always returns successfully)\n- Both the unpacked r and the packed s represent the same natural number modulo L\n- The packed scalar is in canonical form (less than L) -/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::pack",
   "lines": "L1165-L1169",
   "lean_name": "curve25519_dalek.scalar.Scalar52.pack",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem clamp_integer_spec (bytes : Array U8 32#usize) :\n    clamp_integer bytes ⦃ result =>\n    h ∣ U8x32_as_Nat result ∧\n    U8x32_as_Nat result < 2^255 ∧\n    2^254 ≤ U8x32_as_Nat result ⦄ := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/ClampInteger.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.clamp_integer`**:\n- No panic\n- (as_nat_32_u8 result) is divisible by h (cofactor of curve25519)\n- as_nat_32_u8 result < 2^255\n- 2^254 ≤ as_nat_32_u8 result\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "pub const fn clamp_integer(mut bytes: [u8; 32]) -> [u8; 32] {\n    bytes[0] &= 0b1111_1000;\n    bytes[31] &= 0b0111_1111;\n    bytes[31] |= 0b0100_0000;\n    bytes\n}",
   "rust_name": "curve25519_dalek::scalar::clamp_integer",
   "lines": "L1415-L1420",
   "lean_name": "curve25519_dalek.scalar.clamp_integer",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "fn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(src.len() == 8 * dst.len());\n    let mut i = 0;\n    while i < dst.len() {\n        let start = i * 8;\n        dst[i] = u64::from_le_bytes([\n            src[start],\n            src[start + 1],\n            src[start + 2],\n            src[start + 3],\n            src[start + 4],\n            src[start + 5],\n            src[start + 6],\n            src[start + 7],\n        ]);\n        i += 1;\n    }\n}",
   "rust_name": "curve25519_dalek::scalar::read_le_u64_into",
   "lines": "L1376-L1393",
   "lean_name": "curve25519_dalek.scalar.read_le_u64_into",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.scalar.read_le_u64_into_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_source":
   "    while i < dst.len() {\n        let start = i * 8;\n        dst[i] = u64::from_le_bytes([\n            src[start],\n            src[start + 1],\n            src[start + 2],\n            src[start + 3],\n            src[start + 4],\n            src[start + 5],\n            src[start + 6],\n            src[start + 7],\n        ]);\n        i += 1;\n    }",
   "rust_name": "curve25519_dalek::scalar::read_le_u64_into",
   "lines": "L1379-L1392",
   "lean_name": "curve25519_dalek.scalar.read_le_u64_into_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/traits.rs",
   "rust_source":
   "    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }",
   "rust_name":
   "curve25519_dalek::traits::{curve25519_dalek::traits::IsIdentity for T}::is_identity",
   "lines": "L45-L47",
   "lean_name": "curve25519_dalek.traits.IsIdentity.Blanket.is_identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_source":
   "            pub fn select(&self, x: i8) -> T {\n                debug_assert!(x >= $neg);\n                debug_assert!(x as i16 <= $size as i16); // XXX We have to convert to i16s here for the radix-256 case.. this is wrong.\n\n                // Compute xabs = |x|\n                let xmask = x as i16 >> 7;\n                let xabs = (x as i16 + xmask) ^ xmask;\n\n                // Set t = 0 * P = identity\n                let mut t = T::identity();\n                for j in $range {\n                    // Copy `points[j-1] == j*P` onto `t` in constant time if `|x| == j`.\n                    let c = (xabs as u16).ct_eq(&(j as u16));\n                    t.conditional_assign(&self.0[j - 1], c);\n                }\n                // Now t == |x| * P.\n\n                let neg_mask = Choice::from((xmask & 1) as u8);\n                let t_neg = -t;\n                t.conditional_assign(&t_neg, neg_mask);\n                // Now t == x * P.\n\n                t\n            }",
   "rust_name":
   "curve25519_dalek::window::{curve25519_dalek::window::LookupTable<T>}::select",
   "lines": "L55-L78",
   "lean_name": "curve25519_dalek.window.LookupTable.select",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": ["curve25519_dalek.window.LookupTable.select_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_source":
   "                for j in $range {\n                    // Copy `points[j-1] == j*P` onto `t` in constant time if `|x| == j`.\n                    let c = (xabs as u16).ct_eq(&(j as u16));\n                    t.conditional_assign(&self.0[j - 1], c);\n                }\n                // Now t == |x| * P.\n\n                let neg_mask = Choice::from((xmask & 1) as u8);\n                let t_neg = -t;\n                t.conditional_assign(&t_neg, neg_mask);\n                // Now t == x * P.\n\n                t\n            }\n        }\n\n        impl<T: Copy + Default> Default for $name<T> {\n            fn default() -> $name<T> {\n                $name([T::default(); $size])\n            }\n        }\n\n        impl<T: Debug> Debug for $name<T> {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?}(\", stringify!($name))?;\n\n                for x in self.0.iter() {\n                    write!(f, \"{:?}\", x)?;\n                }\n\n                write!(f, \")\")\n            }\n        }\n\n        impl<'a> From<&'a EdwardsPoint> for $name<ProjectiveNielsPoint> {\n            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_projective_niels(); $size];\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_projective_niels();\n                }\n                $name(points)\n            }\n        }\n\n        impl<'a> From<&'a EdwardsPoint> for $name<AffineNielsPoint> {\n            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_affine_niels(); $size];\n                // XXX batch inversion would be good if perf mattered here\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_affine_niels()\n                }\n                $name(points)\n            }\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        impl<T> Zeroize for $name<T>\n        where\n            T: Copy + Default + Zeroize,\n        {\n            fn zeroize(&mut self) {\n                self.0.iter_mut().zeroize();\n            }\n        }\n    };\n} // End macro_rules! impl_lookup_table\n\n// The first one has to be named \"LookupTable\" because it's used as a constructor for consts.\n// This is radix-16\nimpl_lookup_table! {\n    Name = LookupTable,\n    Size = 8,\n    SizeNeg = -8,\n    SizeRange = 1..9,",
   "rust_name":
   "curve25519_dalek::window::{curve25519_dalek::window::LookupTable<T>}::select",
   "lines": "L65-L138",
   "lean_name": "curve25519_dalek.window.LookupTable.select_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_source":
   "            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_projective_niels(); $size];\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_projective_niels();\n                }\n                $name(points)\n            }",
   "rust_name":
   "curve25519_dalek::window::{core::convert::From<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::window::LookupTable<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint>}::from",
   "lines": "L100-L106",
   "lean_name":
   "curve25519_dalek.window.LookupTableProjectiveNielsPoint.Insts.CoreConvertFromSharedAEdwardsPoint.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective_niels",
    "curve25519_dalek.window.LookupTableProjectiveNielsPoint.Insts.CoreConvertFromSharedAEdwardsPoint.from_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_source":
   "                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_projective_niels();\n                }\n                $name(points)\n            }\n        }\n\n        impl<'a> From<&'a EdwardsPoint> for $name<AffineNielsPoint> {\n            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_affine_niels(); $size];\n                // XXX batch inversion would be good if perf mattered here\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_affine_niels()\n                }\n                $name(points)\n            }\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        impl<T> Zeroize for $name<T>\n        where\n            T: Copy + Default + Zeroize,\n        {\n            fn zeroize(&mut self) {\n                self.0.iter_mut().zeroize();\n            }\n        }\n    };\n} // End macro_rules! impl_lookup_table\n\n// The first one has to be named \"LookupTable\" because it's used as a constructor for consts.\n// This is radix-16\nimpl_lookup_table! {\n    Name = LookupTable,\n    Size = 8,\n    SizeNeg = -8,\n    SizeRange = 1..9,\n    ConversionRange = 0..7",
   "rust_name":
   "curve25519_dalek::window::{core::convert::From<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::window::LookupTable<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint>}::from",
   "lines": "L102-L139",
   "lean_name":
   "curve25519_dalek.window.LookupTableProjectiveNielsPoint.Insts.CoreConvertFromSharedAEdwardsPoint.from_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "externally_verified": false,
   "dependencies":
   ["curve25519_dalek.Shared0EdwardsPoint.Insts.CoreOpsArithAddSharedAProjectiveNielsPointCompletedPoint.add",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended",
    "curve25519_dalek.edwards.EdwardsPoint.as_projective_niels"]}]}